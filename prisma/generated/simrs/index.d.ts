
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model PaymentMethod
 * 
 */
export type PaymentMethod = $Result.DefaultSelection<Prisma.$PaymentMethodPayload>
/**
 * Model Bed
 * 
 */
export type Bed = $Result.DefaultSelection<Prisma.$BedPayload>
/**
 * Model Room
 * 
 */
export type Room = $Result.DefaultSelection<Prisma.$RoomPayload>
/**
 * Model Unit
 * 
 */
export type Unit = $Result.DefaultSelection<Prisma.$UnitPayload>
/**
 * Model BedStatus
 * 
 */
export type BedStatus = $Result.DefaultSelection<Prisma.$BedStatusPayload>
/**
 * Model Class
 * 
 */
export type Class = $Result.DefaultSelection<Prisma.$ClassPayload>
/**
 * Model Department
 * 
 */
export type Department = $Result.DefaultSelection<Prisma.$DepartmentPayload>
/**
 * Model Product
 * 
 */
export type Product = $Result.DefaultSelection<Prisma.$ProductPayload>
/**
 * Model ServiceReceipt
 * 
 */
export type ServiceReceipt = $Result.DefaultSelection<Prisma.$ServiceReceiptPayload>
/**
 * Model StockDetail
 * 
 */
export type StockDetail = $Result.DefaultSelection<Prisma.$StockDetailPayload>
/**
 * Model DoctorSchedule
 * 
 */
export type DoctorSchedule = $Result.DefaultSelection<Prisma.$DoctorSchedulePayload>
/**
 * Model Employee
 * 
 */
export type Employee = $Result.DefaultSelection<Prisma.$EmployeePayload>
/**
 * Model Reservation
 * 
 */
export type Reservation = $Result.DefaultSelection<Prisma.$ReservationPayload>
/**
 * Model Patient
 * 
 */
export type Patient = $Result.DefaultSelection<Prisma.$PatientPayload>
/**
 * Model Gender
 * 
 */
export type Gender = $Result.DefaultSelection<Prisma.$GenderPayload>
/**
 * Model ReferralSource
 * 
 */
export type ReferralSource = $Result.DefaultSelection<Prisma.$ReferralSourcePayload>

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more PaymentMethods
 * const paymentMethods = await prisma.paymentMethod.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more PaymentMethods
   * const paymentMethods = await prisma.paymentMethod.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.paymentMethod`: Exposes CRUD operations for the **PaymentMethod** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PaymentMethods
    * const paymentMethods = await prisma.paymentMethod.findMany()
    * ```
    */
  get paymentMethod(): Prisma.PaymentMethodDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.bed`: Exposes CRUD operations for the **Bed** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Beds
    * const beds = await prisma.bed.findMany()
    * ```
    */
  get bed(): Prisma.BedDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.room`: Exposes CRUD operations for the **Room** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Rooms
    * const rooms = await prisma.room.findMany()
    * ```
    */
  get room(): Prisma.RoomDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.unit`: Exposes CRUD operations for the **Unit** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Units
    * const units = await prisma.unit.findMany()
    * ```
    */
  get unit(): Prisma.UnitDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.bedStatus`: Exposes CRUD operations for the **BedStatus** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BedStatuses
    * const bedStatuses = await prisma.bedStatus.findMany()
    * ```
    */
  get bedStatus(): Prisma.BedStatusDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.class`: Exposes CRUD operations for the **Class** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Classes
    * const classes = await prisma.class.findMany()
    * ```
    */
  get class(): Prisma.ClassDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.department`: Exposes CRUD operations for the **Department** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Departments
    * const departments = await prisma.department.findMany()
    * ```
    */
  get department(): Prisma.DepartmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.product`: Exposes CRUD operations for the **Product** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Products
    * const products = await prisma.product.findMany()
    * ```
    */
  get product(): Prisma.ProductDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.serviceReceipt`: Exposes CRUD operations for the **ServiceReceipt** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ServiceReceipts
    * const serviceReceipts = await prisma.serviceReceipt.findMany()
    * ```
    */
  get serviceReceipt(): Prisma.ServiceReceiptDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.stockDetail`: Exposes CRUD operations for the **StockDetail** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StockDetails
    * const stockDetails = await prisma.stockDetail.findMany()
    * ```
    */
  get stockDetail(): Prisma.StockDetailDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.doctorSchedule`: Exposes CRUD operations for the **DoctorSchedule** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DoctorSchedules
    * const doctorSchedules = await prisma.doctorSchedule.findMany()
    * ```
    */
  get doctorSchedule(): Prisma.DoctorScheduleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.employee`: Exposes CRUD operations for the **Employee** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Employees
    * const employees = await prisma.employee.findMany()
    * ```
    */
  get employee(): Prisma.EmployeeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.reservation`: Exposes CRUD operations for the **Reservation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reservations
    * const reservations = await prisma.reservation.findMany()
    * ```
    */
  get reservation(): Prisma.ReservationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.patient`: Exposes CRUD operations for the **Patient** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Patients
    * const patients = await prisma.patient.findMany()
    * ```
    */
  get patient(): Prisma.PatientDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.gender`: Exposes CRUD operations for the **Gender** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Genders
    * const genders = await prisma.gender.findMany()
    * ```
    */
  get gender(): Prisma.GenderDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.referralSource`: Exposes CRUD operations for the **ReferralSource** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ReferralSources
    * const referralSources = await prisma.referralSource.findMany()
    * ```
    */
  get referralSource(): Prisma.ReferralSourceDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.11.1
   * Query Engine version: f40f79ec31188888a2e33acda0ecc8fd10a853a9
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    PaymentMethod: 'PaymentMethod',
    Bed: 'Bed',
    Room: 'Room',
    Unit: 'Unit',
    BedStatus: 'BedStatus',
    Class: 'Class',
    Department: 'Department',
    Product: 'Product',
    ServiceReceipt: 'ServiceReceipt',
    StockDetail: 'StockDetail',
    DoctorSchedule: 'DoctorSchedule',
    Employee: 'Employee',
    Reservation: 'Reservation',
    Patient: 'Patient',
    Gender: 'Gender',
    ReferralSource: 'ReferralSource'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "paymentMethod" | "bed" | "room" | "unit" | "bedStatus" | "class" | "department" | "product" | "serviceReceipt" | "stockDetail" | "doctorSchedule" | "employee" | "reservation" | "patient" | "gender" | "referralSource"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      PaymentMethod: {
        payload: Prisma.$PaymentMethodPayload<ExtArgs>
        fields: Prisma.PaymentMethodFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaymentMethodFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaymentMethodFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodPayload>
          }
          findFirst: {
            args: Prisma.PaymentMethodFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaymentMethodFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodPayload>
          }
          findMany: {
            args: Prisma.PaymentMethodFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodPayload>[]
          }
          create: {
            args: Prisma.PaymentMethodCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodPayload>
          }
          createMany: {
            args: Prisma.PaymentMethodCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PaymentMethodCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodPayload>[]
          }
          delete: {
            args: Prisma.PaymentMethodDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodPayload>
          }
          update: {
            args: Prisma.PaymentMethodUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodPayload>
          }
          deleteMany: {
            args: Prisma.PaymentMethodDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PaymentMethodUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PaymentMethodUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodPayload>[]
          }
          upsert: {
            args: Prisma.PaymentMethodUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodPayload>
          }
          aggregate: {
            args: Prisma.PaymentMethodAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePaymentMethod>
          }
          groupBy: {
            args: Prisma.PaymentMethodGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentMethodGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaymentMethodCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentMethodCountAggregateOutputType> | number
          }
        }
      }
      Bed: {
        payload: Prisma.$BedPayload<ExtArgs>
        fields: Prisma.BedFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BedFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BedPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BedFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BedPayload>
          }
          findFirst: {
            args: Prisma.BedFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BedPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BedFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BedPayload>
          }
          findMany: {
            args: Prisma.BedFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BedPayload>[]
          }
          create: {
            args: Prisma.BedCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BedPayload>
          }
          createMany: {
            args: Prisma.BedCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BedCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BedPayload>[]
          }
          delete: {
            args: Prisma.BedDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BedPayload>
          }
          update: {
            args: Prisma.BedUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BedPayload>
          }
          deleteMany: {
            args: Prisma.BedDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BedUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BedUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BedPayload>[]
          }
          upsert: {
            args: Prisma.BedUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BedPayload>
          }
          aggregate: {
            args: Prisma.BedAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBed>
          }
          groupBy: {
            args: Prisma.BedGroupByArgs<ExtArgs>
            result: $Utils.Optional<BedGroupByOutputType>[]
          }
          count: {
            args: Prisma.BedCountArgs<ExtArgs>
            result: $Utils.Optional<BedCountAggregateOutputType> | number
          }
        }
      }
      Room: {
        payload: Prisma.$RoomPayload<ExtArgs>
        fields: Prisma.RoomFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RoomFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RoomFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomPayload>
          }
          findFirst: {
            args: Prisma.RoomFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RoomFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomPayload>
          }
          findMany: {
            args: Prisma.RoomFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomPayload>[]
          }
          create: {
            args: Prisma.RoomCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomPayload>
          }
          createMany: {
            args: Prisma.RoomCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RoomCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomPayload>[]
          }
          delete: {
            args: Prisma.RoomDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomPayload>
          }
          update: {
            args: Prisma.RoomUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomPayload>
          }
          deleteMany: {
            args: Prisma.RoomDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RoomUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RoomUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomPayload>[]
          }
          upsert: {
            args: Prisma.RoomUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomPayload>
          }
          aggregate: {
            args: Prisma.RoomAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRoom>
          }
          groupBy: {
            args: Prisma.RoomGroupByArgs<ExtArgs>
            result: $Utils.Optional<RoomGroupByOutputType>[]
          }
          count: {
            args: Prisma.RoomCountArgs<ExtArgs>
            result: $Utils.Optional<RoomCountAggregateOutputType> | number
          }
        }
      }
      Unit: {
        payload: Prisma.$UnitPayload<ExtArgs>
        fields: Prisma.UnitFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UnitFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UnitFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload>
          }
          findFirst: {
            args: Prisma.UnitFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UnitFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload>
          }
          findMany: {
            args: Prisma.UnitFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload>[]
          }
          create: {
            args: Prisma.UnitCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload>
          }
          createMany: {
            args: Prisma.UnitCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UnitCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload>[]
          }
          delete: {
            args: Prisma.UnitDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload>
          }
          update: {
            args: Prisma.UnitUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload>
          }
          deleteMany: {
            args: Prisma.UnitDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UnitUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UnitUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload>[]
          }
          upsert: {
            args: Prisma.UnitUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload>
          }
          aggregate: {
            args: Prisma.UnitAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUnit>
          }
          groupBy: {
            args: Prisma.UnitGroupByArgs<ExtArgs>
            result: $Utils.Optional<UnitGroupByOutputType>[]
          }
          count: {
            args: Prisma.UnitCountArgs<ExtArgs>
            result: $Utils.Optional<UnitCountAggregateOutputType> | number
          }
        }
      }
      BedStatus: {
        payload: Prisma.$BedStatusPayload<ExtArgs>
        fields: Prisma.BedStatusFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BedStatusFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BedStatusPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BedStatusFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BedStatusPayload>
          }
          findFirst: {
            args: Prisma.BedStatusFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BedStatusPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BedStatusFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BedStatusPayload>
          }
          findMany: {
            args: Prisma.BedStatusFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BedStatusPayload>[]
          }
          create: {
            args: Prisma.BedStatusCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BedStatusPayload>
          }
          createMany: {
            args: Prisma.BedStatusCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BedStatusCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BedStatusPayload>[]
          }
          delete: {
            args: Prisma.BedStatusDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BedStatusPayload>
          }
          update: {
            args: Prisma.BedStatusUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BedStatusPayload>
          }
          deleteMany: {
            args: Prisma.BedStatusDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BedStatusUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BedStatusUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BedStatusPayload>[]
          }
          upsert: {
            args: Prisma.BedStatusUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BedStatusPayload>
          }
          aggregate: {
            args: Prisma.BedStatusAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBedStatus>
          }
          groupBy: {
            args: Prisma.BedStatusGroupByArgs<ExtArgs>
            result: $Utils.Optional<BedStatusGroupByOutputType>[]
          }
          count: {
            args: Prisma.BedStatusCountArgs<ExtArgs>
            result: $Utils.Optional<BedStatusCountAggregateOutputType> | number
          }
        }
      }
      Class: {
        payload: Prisma.$ClassPayload<ExtArgs>
        fields: Prisma.ClassFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClassFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClassFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload>
          }
          findFirst: {
            args: Prisma.ClassFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClassFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload>
          }
          findMany: {
            args: Prisma.ClassFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload>[]
          }
          create: {
            args: Prisma.ClassCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload>
          }
          createMany: {
            args: Prisma.ClassCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ClassCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload>[]
          }
          delete: {
            args: Prisma.ClassDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload>
          }
          update: {
            args: Prisma.ClassUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload>
          }
          deleteMany: {
            args: Prisma.ClassDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClassUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ClassUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload>[]
          }
          upsert: {
            args: Prisma.ClassUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload>
          }
          aggregate: {
            args: Prisma.ClassAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClass>
          }
          groupBy: {
            args: Prisma.ClassGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClassGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClassCountArgs<ExtArgs>
            result: $Utils.Optional<ClassCountAggregateOutputType> | number
          }
        }
      }
      Department: {
        payload: Prisma.$DepartmentPayload<ExtArgs>
        fields: Prisma.DepartmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DepartmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DepartmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          findFirst: {
            args: Prisma.DepartmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DepartmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          findMany: {
            args: Prisma.DepartmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>[]
          }
          create: {
            args: Prisma.DepartmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          createMany: {
            args: Prisma.DepartmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DepartmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>[]
          }
          delete: {
            args: Prisma.DepartmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          update: {
            args: Prisma.DepartmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          deleteMany: {
            args: Prisma.DepartmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DepartmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DepartmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>[]
          }
          upsert: {
            args: Prisma.DepartmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          aggregate: {
            args: Prisma.DepartmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDepartment>
          }
          groupBy: {
            args: Prisma.DepartmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<DepartmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.DepartmentCountArgs<ExtArgs>
            result: $Utils.Optional<DepartmentCountAggregateOutputType> | number
          }
        }
      }
      Product: {
        payload: Prisma.$ProductPayload<ExtArgs>
        fields: Prisma.ProductFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          findFirst: {
            args: Prisma.ProductFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          findMany: {
            args: Prisma.ProductFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          create: {
            args: Prisma.ProductCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          createMany: {
            args: Prisma.ProductCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          delete: {
            args: Prisma.ProductDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          update: {
            args: Prisma.ProductUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          deleteMany: {
            args: Prisma.ProductDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProductUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          upsert: {
            args: Prisma.ProductUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          aggregate: {
            args: Prisma.ProductAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProduct>
          }
          groupBy: {
            args: Prisma.ProductGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductCountArgs<ExtArgs>
            result: $Utils.Optional<ProductCountAggregateOutputType> | number
          }
        }
      }
      ServiceReceipt: {
        payload: Prisma.$ServiceReceiptPayload<ExtArgs>
        fields: Prisma.ServiceReceiptFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ServiceReceiptFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceReceiptPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ServiceReceiptFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceReceiptPayload>
          }
          findFirst: {
            args: Prisma.ServiceReceiptFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceReceiptPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ServiceReceiptFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceReceiptPayload>
          }
          findMany: {
            args: Prisma.ServiceReceiptFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceReceiptPayload>[]
          }
          create: {
            args: Prisma.ServiceReceiptCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceReceiptPayload>
          }
          createMany: {
            args: Prisma.ServiceReceiptCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ServiceReceiptCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceReceiptPayload>[]
          }
          delete: {
            args: Prisma.ServiceReceiptDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceReceiptPayload>
          }
          update: {
            args: Prisma.ServiceReceiptUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceReceiptPayload>
          }
          deleteMany: {
            args: Prisma.ServiceReceiptDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ServiceReceiptUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ServiceReceiptUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceReceiptPayload>[]
          }
          upsert: {
            args: Prisma.ServiceReceiptUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceReceiptPayload>
          }
          aggregate: {
            args: Prisma.ServiceReceiptAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateServiceReceipt>
          }
          groupBy: {
            args: Prisma.ServiceReceiptGroupByArgs<ExtArgs>
            result: $Utils.Optional<ServiceReceiptGroupByOutputType>[]
          }
          count: {
            args: Prisma.ServiceReceiptCountArgs<ExtArgs>
            result: $Utils.Optional<ServiceReceiptCountAggregateOutputType> | number
          }
        }
      }
      StockDetail: {
        payload: Prisma.$StockDetailPayload<ExtArgs>
        fields: Prisma.StockDetailFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StockDetailFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockDetailPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StockDetailFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockDetailPayload>
          }
          findFirst: {
            args: Prisma.StockDetailFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockDetailPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StockDetailFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockDetailPayload>
          }
          findMany: {
            args: Prisma.StockDetailFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockDetailPayload>[]
          }
          create: {
            args: Prisma.StockDetailCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockDetailPayload>
          }
          createMany: {
            args: Prisma.StockDetailCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StockDetailCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockDetailPayload>[]
          }
          delete: {
            args: Prisma.StockDetailDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockDetailPayload>
          }
          update: {
            args: Prisma.StockDetailUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockDetailPayload>
          }
          deleteMany: {
            args: Prisma.StockDetailDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StockDetailUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.StockDetailUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockDetailPayload>[]
          }
          upsert: {
            args: Prisma.StockDetailUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockDetailPayload>
          }
          aggregate: {
            args: Prisma.StockDetailAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStockDetail>
          }
          groupBy: {
            args: Prisma.StockDetailGroupByArgs<ExtArgs>
            result: $Utils.Optional<StockDetailGroupByOutputType>[]
          }
          count: {
            args: Prisma.StockDetailCountArgs<ExtArgs>
            result: $Utils.Optional<StockDetailCountAggregateOutputType> | number
          }
        }
      }
      DoctorSchedule: {
        payload: Prisma.$DoctorSchedulePayload<ExtArgs>
        fields: Prisma.DoctorScheduleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DoctorScheduleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoctorSchedulePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DoctorScheduleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoctorSchedulePayload>
          }
          findFirst: {
            args: Prisma.DoctorScheduleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoctorSchedulePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DoctorScheduleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoctorSchedulePayload>
          }
          findMany: {
            args: Prisma.DoctorScheduleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoctorSchedulePayload>[]
          }
          create: {
            args: Prisma.DoctorScheduleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoctorSchedulePayload>
          }
          createMany: {
            args: Prisma.DoctorScheduleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DoctorScheduleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoctorSchedulePayload>[]
          }
          delete: {
            args: Prisma.DoctorScheduleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoctorSchedulePayload>
          }
          update: {
            args: Prisma.DoctorScheduleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoctorSchedulePayload>
          }
          deleteMany: {
            args: Prisma.DoctorScheduleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DoctorScheduleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DoctorScheduleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoctorSchedulePayload>[]
          }
          upsert: {
            args: Prisma.DoctorScheduleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoctorSchedulePayload>
          }
          aggregate: {
            args: Prisma.DoctorScheduleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDoctorSchedule>
          }
          groupBy: {
            args: Prisma.DoctorScheduleGroupByArgs<ExtArgs>
            result: $Utils.Optional<DoctorScheduleGroupByOutputType>[]
          }
          count: {
            args: Prisma.DoctorScheduleCountArgs<ExtArgs>
            result: $Utils.Optional<DoctorScheduleCountAggregateOutputType> | number
          }
        }
      }
      Employee: {
        payload: Prisma.$EmployeePayload<ExtArgs>
        fields: Prisma.EmployeeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmployeeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmployeeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          findFirst: {
            args: Prisma.EmployeeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmployeeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          findMany: {
            args: Prisma.EmployeeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>[]
          }
          create: {
            args: Prisma.EmployeeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          createMany: {
            args: Prisma.EmployeeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EmployeeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>[]
          }
          delete: {
            args: Prisma.EmployeeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          update: {
            args: Prisma.EmployeeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          deleteMany: {
            args: Prisma.EmployeeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmployeeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EmployeeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>[]
          }
          upsert: {
            args: Prisma.EmployeeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          aggregate: {
            args: Prisma.EmployeeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmployee>
          }
          groupBy: {
            args: Prisma.EmployeeGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmployeeGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmployeeCountArgs<ExtArgs>
            result: $Utils.Optional<EmployeeCountAggregateOutputType> | number
          }
        }
      }
      Reservation: {
        payload: Prisma.$ReservationPayload<ExtArgs>
        fields: Prisma.ReservationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReservationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReservationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReservationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReservationPayload>
          }
          findFirst: {
            args: Prisma.ReservationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReservationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReservationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReservationPayload>
          }
          findMany: {
            args: Prisma.ReservationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReservationPayload>[]
          }
          create: {
            args: Prisma.ReservationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReservationPayload>
          }
          createMany: {
            args: Prisma.ReservationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReservationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReservationPayload>[]
          }
          delete: {
            args: Prisma.ReservationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReservationPayload>
          }
          update: {
            args: Prisma.ReservationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReservationPayload>
          }
          deleteMany: {
            args: Prisma.ReservationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReservationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ReservationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReservationPayload>[]
          }
          upsert: {
            args: Prisma.ReservationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReservationPayload>
          }
          aggregate: {
            args: Prisma.ReservationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReservation>
          }
          groupBy: {
            args: Prisma.ReservationGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReservationGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReservationCountArgs<ExtArgs>
            result: $Utils.Optional<ReservationCountAggregateOutputType> | number
          }
        }
      }
      Patient: {
        payload: Prisma.$PatientPayload<ExtArgs>
        fields: Prisma.PatientFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PatientFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PatientFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>
          }
          findFirst: {
            args: Prisma.PatientFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PatientFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>
          }
          findMany: {
            args: Prisma.PatientFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>[]
          }
          create: {
            args: Prisma.PatientCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>
          }
          createMany: {
            args: Prisma.PatientCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PatientCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>[]
          }
          delete: {
            args: Prisma.PatientDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>
          }
          update: {
            args: Prisma.PatientUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>
          }
          deleteMany: {
            args: Prisma.PatientDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PatientUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PatientUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>[]
          }
          upsert: {
            args: Prisma.PatientUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>
          }
          aggregate: {
            args: Prisma.PatientAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePatient>
          }
          groupBy: {
            args: Prisma.PatientGroupByArgs<ExtArgs>
            result: $Utils.Optional<PatientGroupByOutputType>[]
          }
          count: {
            args: Prisma.PatientCountArgs<ExtArgs>
            result: $Utils.Optional<PatientCountAggregateOutputType> | number
          }
        }
      }
      Gender: {
        payload: Prisma.$GenderPayload<ExtArgs>
        fields: Prisma.GenderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GenderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GenderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GenderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GenderPayload>
          }
          findFirst: {
            args: Prisma.GenderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GenderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GenderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GenderPayload>
          }
          findMany: {
            args: Prisma.GenderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GenderPayload>[]
          }
          create: {
            args: Prisma.GenderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GenderPayload>
          }
          createMany: {
            args: Prisma.GenderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GenderCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GenderPayload>[]
          }
          delete: {
            args: Prisma.GenderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GenderPayload>
          }
          update: {
            args: Prisma.GenderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GenderPayload>
          }
          deleteMany: {
            args: Prisma.GenderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GenderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.GenderUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GenderPayload>[]
          }
          upsert: {
            args: Prisma.GenderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GenderPayload>
          }
          aggregate: {
            args: Prisma.GenderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGender>
          }
          groupBy: {
            args: Prisma.GenderGroupByArgs<ExtArgs>
            result: $Utils.Optional<GenderGroupByOutputType>[]
          }
          count: {
            args: Prisma.GenderCountArgs<ExtArgs>
            result: $Utils.Optional<GenderCountAggregateOutputType> | number
          }
        }
      }
      ReferralSource: {
        payload: Prisma.$ReferralSourcePayload<ExtArgs>
        fields: Prisma.ReferralSourceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReferralSourceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralSourcePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReferralSourceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralSourcePayload>
          }
          findFirst: {
            args: Prisma.ReferralSourceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralSourcePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReferralSourceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralSourcePayload>
          }
          findMany: {
            args: Prisma.ReferralSourceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralSourcePayload>[]
          }
          create: {
            args: Prisma.ReferralSourceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralSourcePayload>
          }
          createMany: {
            args: Prisma.ReferralSourceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReferralSourceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralSourcePayload>[]
          }
          delete: {
            args: Prisma.ReferralSourceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralSourcePayload>
          }
          update: {
            args: Prisma.ReferralSourceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralSourcePayload>
          }
          deleteMany: {
            args: Prisma.ReferralSourceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReferralSourceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ReferralSourceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralSourcePayload>[]
          }
          upsert: {
            args: Prisma.ReferralSourceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralSourcePayload>
          }
          aggregate: {
            args: Prisma.ReferralSourceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReferralSource>
          }
          groupBy: {
            args: Prisma.ReferralSourceGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReferralSourceGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReferralSourceCountArgs<ExtArgs>
            result: $Utils.Optional<ReferralSourceCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    paymentMethod?: PaymentMethodOmit
    bed?: BedOmit
    room?: RoomOmit
    unit?: UnitOmit
    bedStatus?: BedStatusOmit
    class?: ClassOmit
    department?: DepartmentOmit
    product?: ProductOmit
    serviceReceipt?: ServiceReceiptOmit
    stockDetail?: StockDetailOmit
    doctorSchedule?: DoctorScheduleOmit
    employee?: EmployeeOmit
    reservation?: ReservationOmit
    patient?: PatientOmit
    gender?: GenderOmit
    referralSource?: ReferralSourceOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type PaymentMethodCountOutputType
   */

  export type PaymentMethodCountOutputType = {
    reservations: number
  }

  export type PaymentMethodCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    reservations?: boolean | PaymentMethodCountOutputTypeCountReservationsArgs
  }

  // Custom InputTypes
  /**
   * PaymentMethodCountOutputType without action
   */
  export type PaymentMethodCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethodCountOutputType
     */
    select?: PaymentMethodCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PaymentMethodCountOutputType without action
   */
  export type PaymentMethodCountOutputTypeCountReservationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReservationWhereInput
  }


  /**
   * Count Type RoomCountOutputType
   */

  export type RoomCountOutputType = {
    beds: number
  }

  export type RoomCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    beds?: boolean | RoomCountOutputTypeCountBedsArgs
  }

  // Custom InputTypes
  /**
   * RoomCountOutputType without action
   */
  export type RoomCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomCountOutputType
     */
    select?: RoomCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RoomCountOutputType without action
   */
  export type RoomCountOutputTypeCountBedsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BedWhereInput
  }


  /**
   * Count Type UnitCountOutputType
   */

  export type UnitCountOutputType = {
    rooms: number
    stockDetails: number
    doctorSchedules: number
    reservations: number
  }

  export type UnitCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rooms?: boolean | UnitCountOutputTypeCountRoomsArgs
    stockDetails?: boolean | UnitCountOutputTypeCountStockDetailsArgs
    doctorSchedules?: boolean | UnitCountOutputTypeCountDoctorSchedulesArgs
    reservations?: boolean | UnitCountOutputTypeCountReservationsArgs
  }

  // Custom InputTypes
  /**
   * UnitCountOutputType without action
   */
  export type UnitCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitCountOutputType
     */
    select?: UnitCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UnitCountOutputType without action
   */
  export type UnitCountOutputTypeCountRoomsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoomWhereInput
  }

  /**
   * UnitCountOutputType without action
   */
  export type UnitCountOutputTypeCountStockDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StockDetailWhereInput
  }

  /**
   * UnitCountOutputType without action
   */
  export type UnitCountOutputTypeCountDoctorSchedulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DoctorScheduleWhereInput
  }

  /**
   * UnitCountOutputType without action
   */
  export type UnitCountOutputTypeCountReservationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReservationWhereInput
  }


  /**
   * Count Type BedStatusCountOutputType
   */

  export type BedStatusCountOutputType = {
    beds: number
  }

  export type BedStatusCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    beds?: boolean | BedStatusCountOutputTypeCountBedsArgs
  }

  // Custom InputTypes
  /**
   * BedStatusCountOutputType without action
   */
  export type BedStatusCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BedStatusCountOutputType
     */
    select?: BedStatusCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BedStatusCountOutputType without action
   */
  export type BedStatusCountOutputTypeCountBedsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BedWhereInput
  }


  /**
   * Count Type ClassCountOutputType
   */

  export type ClassCountOutputType = {
    rooms: number
  }

  export type ClassCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rooms?: boolean | ClassCountOutputTypeCountRoomsArgs
  }

  // Custom InputTypes
  /**
   * ClassCountOutputType without action
   */
  export type ClassCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassCountOutputType
     */
    select?: ClassCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ClassCountOutputType without action
   */
  export type ClassCountOutputTypeCountRoomsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoomWhereInput
  }


  /**
   * Count Type DepartmentCountOutputType
   */

  export type DepartmentCountOutputType = {
    units: number
  }

  export type DepartmentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    units?: boolean | DepartmentCountOutputTypeCountUnitsArgs
  }

  // Custom InputTypes
  /**
   * DepartmentCountOutputType without action
   */
  export type DepartmentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentCountOutputType
     */
    select?: DepartmentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DepartmentCountOutputType without action
   */
  export type DepartmentCountOutputTypeCountUnitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UnitWhereInput
  }


  /**
   * Count Type ProductCountOutputType
   */

  export type ProductCountOutputType = {
    stockDetails: number
  }

  export type ProductCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    stockDetails?: boolean | ProductCountOutputTypeCountStockDetailsArgs
  }

  // Custom InputTypes
  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCountOutputType
     */
    select?: ProductCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountStockDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StockDetailWhereInput
  }


  /**
   * Count Type ServiceReceiptCountOutputType
   */

  export type ServiceReceiptCountOutputType = {
    stockDetails: number
  }

  export type ServiceReceiptCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    stockDetails?: boolean | ServiceReceiptCountOutputTypeCountStockDetailsArgs
  }

  // Custom InputTypes
  /**
   * ServiceReceiptCountOutputType without action
   */
  export type ServiceReceiptCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceReceiptCountOutputType
     */
    select?: ServiceReceiptCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ServiceReceiptCountOutputType without action
   */
  export type ServiceReceiptCountOutputTypeCountStockDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StockDetailWhereInput
  }


  /**
   * Count Type EmployeeCountOutputType
   */

  export type EmployeeCountOutputType = {
    doctorSchedules: number
    reservations: number
  }

  export type EmployeeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    doctorSchedules?: boolean | EmployeeCountOutputTypeCountDoctorSchedulesArgs
    reservations?: boolean | EmployeeCountOutputTypeCountReservationsArgs
  }

  // Custom InputTypes
  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeCountOutputType
     */
    select?: EmployeeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeCountDoctorSchedulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DoctorScheduleWhereInput
  }

  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeCountReservationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReservationWhereInput
  }


  /**
   * Count Type PatientCountOutputType
   */

  export type PatientCountOutputType = {
    reservations: number
  }

  export type PatientCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    reservations?: boolean | PatientCountOutputTypeCountReservationsArgs
  }

  // Custom InputTypes
  /**
   * PatientCountOutputType without action
   */
  export type PatientCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientCountOutputType
     */
    select?: PatientCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PatientCountOutputType without action
   */
  export type PatientCountOutputTypeCountReservationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReservationWhereInput
  }


  /**
   * Count Type GenderCountOutputType
   */

  export type GenderCountOutputType = {
    patients: number
  }

  export type GenderCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patients?: boolean | GenderCountOutputTypeCountPatientsArgs
  }

  // Custom InputTypes
  /**
   * GenderCountOutputType without action
   */
  export type GenderCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GenderCountOutputType
     */
    select?: GenderCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * GenderCountOutputType without action
   */
  export type GenderCountOutputTypeCountPatientsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PatientWhereInput
  }


  /**
   * Count Type ReferralSourceCountOutputType
   */

  export type ReferralSourceCountOutputType = {
    reservations: number
  }

  export type ReferralSourceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    reservations?: boolean | ReferralSourceCountOutputTypeCountReservationsArgs
  }

  // Custom InputTypes
  /**
   * ReferralSourceCountOutputType without action
   */
  export type ReferralSourceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferralSourceCountOutputType
     */
    select?: ReferralSourceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ReferralSourceCountOutputType without action
   */
  export type ReferralSourceCountOutputTypeCountReservationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReservationWhereInput
  }


  /**
   * Models
   */

  /**
   * Model PaymentMethod
   */

  export type AggregatePaymentMethod = {
    _count: PaymentMethodCountAggregateOutputType | null
    _avg: PaymentMethodAvgAggregateOutputType | null
    _sum: PaymentMethodSumAggregateOutputType | null
    _min: PaymentMethodMinAggregateOutputType | null
    _max: PaymentMethodMaxAggregateOutputType | null
  }

  export type PaymentMethodAvgAggregateOutputType = {
    id: number | null
  }

  export type PaymentMethodSumAggregateOutputType = {
    id: number | null
  }

  export type PaymentMethodMinAggregateOutputType = {
    id: number | null
    isEnabled: boolean | null
    displayName: string | null
  }

  export type PaymentMethodMaxAggregateOutputType = {
    id: number | null
    isEnabled: boolean | null
    displayName: string | null
  }

  export type PaymentMethodCountAggregateOutputType = {
    id: number
    isEnabled: number
    displayName: number
    _all: number
  }


  export type PaymentMethodAvgAggregateInputType = {
    id?: true
  }

  export type PaymentMethodSumAggregateInputType = {
    id?: true
  }

  export type PaymentMethodMinAggregateInputType = {
    id?: true
    isEnabled?: true
    displayName?: true
  }

  export type PaymentMethodMaxAggregateInputType = {
    id?: true
    isEnabled?: true
    displayName?: true
  }

  export type PaymentMethodCountAggregateInputType = {
    id?: true
    isEnabled?: true
    displayName?: true
    _all?: true
  }

  export type PaymentMethodAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PaymentMethod to aggregate.
     */
    where?: PaymentMethodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentMethods to fetch.
     */
    orderBy?: PaymentMethodOrderByWithRelationInput | PaymentMethodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaymentMethodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentMethods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentMethods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PaymentMethods
    **/
    _count?: true | PaymentMethodCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentMethodAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentMethodSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentMethodMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentMethodMaxAggregateInputType
  }

  export type GetPaymentMethodAggregateType<T extends PaymentMethodAggregateArgs> = {
        [P in keyof T & keyof AggregatePaymentMethod]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePaymentMethod[P]>
      : GetScalarType<T[P], AggregatePaymentMethod[P]>
  }




  export type PaymentMethodGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentMethodWhereInput
    orderBy?: PaymentMethodOrderByWithAggregationInput | PaymentMethodOrderByWithAggregationInput[]
    by: PaymentMethodScalarFieldEnum[] | PaymentMethodScalarFieldEnum
    having?: PaymentMethodScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentMethodCountAggregateInputType | true
    _avg?: PaymentMethodAvgAggregateInputType
    _sum?: PaymentMethodSumAggregateInputType
    _min?: PaymentMethodMinAggregateInputType
    _max?: PaymentMethodMaxAggregateInputType
  }

  export type PaymentMethodGroupByOutputType = {
    id: number
    isEnabled: boolean
    displayName: string
    _count: PaymentMethodCountAggregateOutputType | null
    _avg: PaymentMethodAvgAggregateOutputType | null
    _sum: PaymentMethodSumAggregateOutputType | null
    _min: PaymentMethodMinAggregateOutputType | null
    _max: PaymentMethodMaxAggregateOutputType | null
  }

  type GetPaymentMethodGroupByPayload<T extends PaymentMethodGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentMethodGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentMethodGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentMethodGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentMethodGroupByOutputType[P]>
        }
      >
    >


  export type PaymentMethodSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    isEnabled?: boolean
    displayName?: boolean
    reservations?: boolean | PaymentMethod$reservationsArgs<ExtArgs>
    _count?: boolean | PaymentMethodCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["paymentMethod"]>

  export type PaymentMethodSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    isEnabled?: boolean
    displayName?: boolean
  }, ExtArgs["result"]["paymentMethod"]>

  export type PaymentMethodSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    isEnabled?: boolean
    displayName?: boolean
  }, ExtArgs["result"]["paymentMethod"]>

  export type PaymentMethodSelectScalar = {
    id?: boolean
    isEnabled?: boolean
    displayName?: boolean
  }

  export type PaymentMethodOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "isEnabled" | "displayName", ExtArgs["result"]["paymentMethod"]>
  export type PaymentMethodInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    reservations?: boolean | PaymentMethod$reservationsArgs<ExtArgs>
    _count?: boolean | PaymentMethodCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PaymentMethodIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type PaymentMethodIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $PaymentMethodPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PaymentMethod"
    objects: {
      reservations: Prisma.$ReservationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      isEnabled: boolean
      displayName: string
    }, ExtArgs["result"]["paymentMethod"]>
    composites: {}
  }

  type PaymentMethodGetPayload<S extends boolean | null | undefined | PaymentMethodDefaultArgs> = $Result.GetResult<Prisma.$PaymentMethodPayload, S>

  type PaymentMethodCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PaymentMethodFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PaymentMethodCountAggregateInputType | true
    }

  export interface PaymentMethodDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PaymentMethod'], meta: { name: 'PaymentMethod' } }
    /**
     * Find zero or one PaymentMethod that matches the filter.
     * @param {PaymentMethodFindUniqueArgs} args - Arguments to find a PaymentMethod
     * @example
     * // Get one PaymentMethod
     * const paymentMethod = await prisma.paymentMethod.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaymentMethodFindUniqueArgs>(args: SelectSubset<T, PaymentMethodFindUniqueArgs<ExtArgs>>): Prisma__PaymentMethodClient<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PaymentMethod that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PaymentMethodFindUniqueOrThrowArgs} args - Arguments to find a PaymentMethod
     * @example
     * // Get one PaymentMethod
     * const paymentMethod = await prisma.paymentMethod.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaymentMethodFindUniqueOrThrowArgs>(args: SelectSubset<T, PaymentMethodFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PaymentMethodClient<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PaymentMethod that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentMethodFindFirstArgs} args - Arguments to find a PaymentMethod
     * @example
     * // Get one PaymentMethod
     * const paymentMethod = await prisma.paymentMethod.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaymentMethodFindFirstArgs>(args?: SelectSubset<T, PaymentMethodFindFirstArgs<ExtArgs>>): Prisma__PaymentMethodClient<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PaymentMethod that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentMethodFindFirstOrThrowArgs} args - Arguments to find a PaymentMethod
     * @example
     * // Get one PaymentMethod
     * const paymentMethod = await prisma.paymentMethod.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaymentMethodFindFirstOrThrowArgs>(args?: SelectSubset<T, PaymentMethodFindFirstOrThrowArgs<ExtArgs>>): Prisma__PaymentMethodClient<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PaymentMethods that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentMethodFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PaymentMethods
     * const paymentMethods = await prisma.paymentMethod.findMany()
     * 
     * // Get first 10 PaymentMethods
     * const paymentMethods = await prisma.paymentMethod.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentMethodWithIdOnly = await prisma.paymentMethod.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PaymentMethodFindManyArgs>(args?: SelectSubset<T, PaymentMethodFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PaymentMethod.
     * @param {PaymentMethodCreateArgs} args - Arguments to create a PaymentMethod.
     * @example
     * // Create one PaymentMethod
     * const PaymentMethod = await prisma.paymentMethod.create({
     *   data: {
     *     // ... data to create a PaymentMethod
     *   }
     * })
     * 
     */
    create<T extends PaymentMethodCreateArgs>(args: SelectSubset<T, PaymentMethodCreateArgs<ExtArgs>>): Prisma__PaymentMethodClient<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PaymentMethods.
     * @param {PaymentMethodCreateManyArgs} args - Arguments to create many PaymentMethods.
     * @example
     * // Create many PaymentMethods
     * const paymentMethod = await prisma.paymentMethod.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PaymentMethodCreateManyArgs>(args?: SelectSubset<T, PaymentMethodCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PaymentMethods and returns the data saved in the database.
     * @param {PaymentMethodCreateManyAndReturnArgs} args - Arguments to create many PaymentMethods.
     * @example
     * // Create many PaymentMethods
     * const paymentMethod = await prisma.paymentMethod.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PaymentMethods and only return the `id`
     * const paymentMethodWithIdOnly = await prisma.paymentMethod.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PaymentMethodCreateManyAndReturnArgs>(args?: SelectSubset<T, PaymentMethodCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PaymentMethod.
     * @param {PaymentMethodDeleteArgs} args - Arguments to delete one PaymentMethod.
     * @example
     * // Delete one PaymentMethod
     * const PaymentMethod = await prisma.paymentMethod.delete({
     *   where: {
     *     // ... filter to delete one PaymentMethod
     *   }
     * })
     * 
     */
    delete<T extends PaymentMethodDeleteArgs>(args: SelectSubset<T, PaymentMethodDeleteArgs<ExtArgs>>): Prisma__PaymentMethodClient<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PaymentMethod.
     * @param {PaymentMethodUpdateArgs} args - Arguments to update one PaymentMethod.
     * @example
     * // Update one PaymentMethod
     * const paymentMethod = await prisma.paymentMethod.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PaymentMethodUpdateArgs>(args: SelectSubset<T, PaymentMethodUpdateArgs<ExtArgs>>): Prisma__PaymentMethodClient<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PaymentMethods.
     * @param {PaymentMethodDeleteManyArgs} args - Arguments to filter PaymentMethods to delete.
     * @example
     * // Delete a few PaymentMethods
     * const { count } = await prisma.paymentMethod.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PaymentMethodDeleteManyArgs>(args?: SelectSubset<T, PaymentMethodDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PaymentMethods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentMethodUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PaymentMethods
     * const paymentMethod = await prisma.paymentMethod.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PaymentMethodUpdateManyArgs>(args: SelectSubset<T, PaymentMethodUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PaymentMethods and returns the data updated in the database.
     * @param {PaymentMethodUpdateManyAndReturnArgs} args - Arguments to update many PaymentMethods.
     * @example
     * // Update many PaymentMethods
     * const paymentMethod = await prisma.paymentMethod.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PaymentMethods and only return the `id`
     * const paymentMethodWithIdOnly = await prisma.paymentMethod.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PaymentMethodUpdateManyAndReturnArgs>(args: SelectSubset<T, PaymentMethodUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PaymentMethod.
     * @param {PaymentMethodUpsertArgs} args - Arguments to update or create a PaymentMethod.
     * @example
     * // Update or create a PaymentMethod
     * const paymentMethod = await prisma.paymentMethod.upsert({
     *   create: {
     *     // ... data to create a PaymentMethod
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PaymentMethod we want to update
     *   }
     * })
     */
    upsert<T extends PaymentMethodUpsertArgs>(args: SelectSubset<T, PaymentMethodUpsertArgs<ExtArgs>>): Prisma__PaymentMethodClient<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PaymentMethods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentMethodCountArgs} args - Arguments to filter PaymentMethods to count.
     * @example
     * // Count the number of PaymentMethods
     * const count = await prisma.paymentMethod.count({
     *   where: {
     *     // ... the filter for the PaymentMethods we want to count
     *   }
     * })
    **/
    count<T extends PaymentMethodCountArgs>(
      args?: Subset<T, PaymentMethodCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentMethodCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PaymentMethod.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentMethodAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentMethodAggregateArgs>(args: Subset<T, PaymentMethodAggregateArgs>): Prisma.PrismaPromise<GetPaymentMethodAggregateType<T>>

    /**
     * Group by PaymentMethod.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentMethodGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentMethodGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentMethodGroupByArgs['orderBy'] }
        : { orderBy?: PaymentMethodGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentMethodGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentMethodGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PaymentMethod model
   */
  readonly fields: PaymentMethodFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PaymentMethod.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaymentMethodClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    reservations<T extends PaymentMethod$reservationsArgs<ExtArgs> = {}>(args?: Subset<T, PaymentMethod$reservationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReservationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PaymentMethod model
   */
  interface PaymentMethodFieldRefs {
    readonly id: FieldRef<"PaymentMethod", 'Int'>
    readonly isEnabled: FieldRef<"PaymentMethod", 'Boolean'>
    readonly displayName: FieldRef<"PaymentMethod", 'String'>
  }
    

  // Custom InputTypes
  /**
   * PaymentMethod findUnique
   */
  export type PaymentMethodFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMethod
     */
    omit?: PaymentMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMethodInclude<ExtArgs> | null
    /**
     * Filter, which PaymentMethod to fetch.
     */
    where: PaymentMethodWhereUniqueInput
  }

  /**
   * PaymentMethod findUniqueOrThrow
   */
  export type PaymentMethodFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMethod
     */
    omit?: PaymentMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMethodInclude<ExtArgs> | null
    /**
     * Filter, which PaymentMethod to fetch.
     */
    where: PaymentMethodWhereUniqueInput
  }

  /**
   * PaymentMethod findFirst
   */
  export type PaymentMethodFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMethod
     */
    omit?: PaymentMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMethodInclude<ExtArgs> | null
    /**
     * Filter, which PaymentMethod to fetch.
     */
    where?: PaymentMethodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentMethods to fetch.
     */
    orderBy?: PaymentMethodOrderByWithRelationInput | PaymentMethodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PaymentMethods.
     */
    cursor?: PaymentMethodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentMethods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentMethods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PaymentMethods.
     */
    distinct?: PaymentMethodScalarFieldEnum | PaymentMethodScalarFieldEnum[]
  }

  /**
   * PaymentMethod findFirstOrThrow
   */
  export type PaymentMethodFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMethod
     */
    omit?: PaymentMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMethodInclude<ExtArgs> | null
    /**
     * Filter, which PaymentMethod to fetch.
     */
    where?: PaymentMethodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentMethods to fetch.
     */
    orderBy?: PaymentMethodOrderByWithRelationInput | PaymentMethodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PaymentMethods.
     */
    cursor?: PaymentMethodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentMethods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentMethods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PaymentMethods.
     */
    distinct?: PaymentMethodScalarFieldEnum | PaymentMethodScalarFieldEnum[]
  }

  /**
   * PaymentMethod findMany
   */
  export type PaymentMethodFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMethod
     */
    omit?: PaymentMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMethodInclude<ExtArgs> | null
    /**
     * Filter, which PaymentMethods to fetch.
     */
    where?: PaymentMethodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentMethods to fetch.
     */
    orderBy?: PaymentMethodOrderByWithRelationInput | PaymentMethodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PaymentMethods.
     */
    cursor?: PaymentMethodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentMethods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentMethods.
     */
    skip?: number
    distinct?: PaymentMethodScalarFieldEnum | PaymentMethodScalarFieldEnum[]
  }

  /**
   * PaymentMethod create
   */
  export type PaymentMethodCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMethod
     */
    omit?: PaymentMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMethodInclude<ExtArgs> | null
    /**
     * The data needed to create a PaymentMethod.
     */
    data: XOR<PaymentMethodCreateInput, PaymentMethodUncheckedCreateInput>
  }

  /**
   * PaymentMethod createMany
   */
  export type PaymentMethodCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PaymentMethods.
     */
    data: PaymentMethodCreateManyInput | PaymentMethodCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PaymentMethod createManyAndReturn
   */
  export type PaymentMethodCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMethod
     */
    omit?: PaymentMethodOmit<ExtArgs> | null
    /**
     * The data used to create many PaymentMethods.
     */
    data: PaymentMethodCreateManyInput | PaymentMethodCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PaymentMethod update
   */
  export type PaymentMethodUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMethod
     */
    omit?: PaymentMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMethodInclude<ExtArgs> | null
    /**
     * The data needed to update a PaymentMethod.
     */
    data: XOR<PaymentMethodUpdateInput, PaymentMethodUncheckedUpdateInput>
    /**
     * Choose, which PaymentMethod to update.
     */
    where: PaymentMethodWhereUniqueInput
  }

  /**
   * PaymentMethod updateMany
   */
  export type PaymentMethodUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PaymentMethods.
     */
    data: XOR<PaymentMethodUpdateManyMutationInput, PaymentMethodUncheckedUpdateManyInput>
    /**
     * Filter which PaymentMethods to update
     */
    where?: PaymentMethodWhereInput
    /**
     * Limit how many PaymentMethods to update.
     */
    limit?: number
  }

  /**
   * PaymentMethod updateManyAndReturn
   */
  export type PaymentMethodUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMethod
     */
    omit?: PaymentMethodOmit<ExtArgs> | null
    /**
     * The data used to update PaymentMethods.
     */
    data: XOR<PaymentMethodUpdateManyMutationInput, PaymentMethodUncheckedUpdateManyInput>
    /**
     * Filter which PaymentMethods to update
     */
    where?: PaymentMethodWhereInput
    /**
     * Limit how many PaymentMethods to update.
     */
    limit?: number
  }

  /**
   * PaymentMethod upsert
   */
  export type PaymentMethodUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMethod
     */
    omit?: PaymentMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMethodInclude<ExtArgs> | null
    /**
     * The filter to search for the PaymentMethod to update in case it exists.
     */
    where: PaymentMethodWhereUniqueInput
    /**
     * In case the PaymentMethod found by the `where` argument doesn't exist, create a new PaymentMethod with this data.
     */
    create: XOR<PaymentMethodCreateInput, PaymentMethodUncheckedCreateInput>
    /**
     * In case the PaymentMethod was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentMethodUpdateInput, PaymentMethodUncheckedUpdateInput>
  }

  /**
   * PaymentMethod delete
   */
  export type PaymentMethodDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMethod
     */
    omit?: PaymentMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMethodInclude<ExtArgs> | null
    /**
     * Filter which PaymentMethod to delete.
     */
    where: PaymentMethodWhereUniqueInput
  }

  /**
   * PaymentMethod deleteMany
   */
  export type PaymentMethodDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PaymentMethods to delete
     */
    where?: PaymentMethodWhereInput
    /**
     * Limit how many PaymentMethods to delete.
     */
    limit?: number
  }

  /**
   * PaymentMethod.reservations
   */
  export type PaymentMethod$reservationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reservation
     */
    select?: ReservationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reservation
     */
    omit?: ReservationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationInclude<ExtArgs> | null
    where?: ReservationWhereInput
    orderBy?: ReservationOrderByWithRelationInput | ReservationOrderByWithRelationInput[]
    cursor?: ReservationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReservationScalarFieldEnum | ReservationScalarFieldEnum[]
  }

  /**
   * PaymentMethod without action
   */
  export type PaymentMethodDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMethod
     */
    omit?: PaymentMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMethodInclude<ExtArgs> | null
  }


  /**
   * Model Bed
   */

  export type AggregateBed = {
    _count: BedCountAggregateOutputType | null
    _avg: BedAvgAggregateOutputType | null
    _sum: BedSumAggregateOutputType | null
    _min: BedMinAggregateOutputType | null
    _max: BedMaxAggregateOutputType | null
  }

  export type BedAvgAggregateOutputType = {
    id: number | null
    bedNumber: number | null
    roomId: number | null
    bedStatusId: number | null
  }

  export type BedSumAggregateOutputType = {
    id: number | null
    bedNumber: number | null
    roomId: number | null
    bedStatusId: number | null
  }

  export type BedMinAggregateOutputType = {
    id: number | null
    displayName: string | null
    bedNumber: number | null
    isEnabled: boolean | null
    roomId: number | null
    bedStatusId: number | null
  }

  export type BedMaxAggregateOutputType = {
    id: number | null
    displayName: string | null
    bedNumber: number | null
    isEnabled: boolean | null
    roomId: number | null
    bedStatusId: number | null
  }

  export type BedCountAggregateOutputType = {
    id: number
    displayName: number
    bedNumber: number
    isEnabled: number
    roomId: number
    bedStatusId: number
    _all: number
  }


  export type BedAvgAggregateInputType = {
    id?: true
    bedNumber?: true
    roomId?: true
    bedStatusId?: true
  }

  export type BedSumAggregateInputType = {
    id?: true
    bedNumber?: true
    roomId?: true
    bedStatusId?: true
  }

  export type BedMinAggregateInputType = {
    id?: true
    displayName?: true
    bedNumber?: true
    isEnabled?: true
    roomId?: true
    bedStatusId?: true
  }

  export type BedMaxAggregateInputType = {
    id?: true
    displayName?: true
    bedNumber?: true
    isEnabled?: true
    roomId?: true
    bedStatusId?: true
  }

  export type BedCountAggregateInputType = {
    id?: true
    displayName?: true
    bedNumber?: true
    isEnabled?: true
    roomId?: true
    bedStatusId?: true
    _all?: true
  }

  export type BedAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Bed to aggregate.
     */
    where?: BedWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Beds to fetch.
     */
    orderBy?: BedOrderByWithRelationInput | BedOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BedWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Beds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Beds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Beds
    **/
    _count?: true | BedCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BedAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BedSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BedMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BedMaxAggregateInputType
  }

  export type GetBedAggregateType<T extends BedAggregateArgs> = {
        [P in keyof T & keyof AggregateBed]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBed[P]>
      : GetScalarType<T[P], AggregateBed[P]>
  }




  export type BedGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BedWhereInput
    orderBy?: BedOrderByWithAggregationInput | BedOrderByWithAggregationInput[]
    by: BedScalarFieldEnum[] | BedScalarFieldEnum
    having?: BedScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BedCountAggregateInputType | true
    _avg?: BedAvgAggregateInputType
    _sum?: BedSumAggregateInputType
    _min?: BedMinAggregateInputType
    _max?: BedMaxAggregateInputType
  }

  export type BedGroupByOutputType = {
    id: number
    displayName: string
    bedNumber: number
    isEnabled: boolean
    roomId: number | null
    bedStatusId: number | null
    _count: BedCountAggregateOutputType | null
    _avg: BedAvgAggregateOutputType | null
    _sum: BedSumAggregateOutputType | null
    _min: BedMinAggregateOutputType | null
    _max: BedMaxAggregateOutputType | null
  }

  type GetBedGroupByPayload<T extends BedGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BedGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BedGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BedGroupByOutputType[P]>
            : GetScalarType<T[P], BedGroupByOutputType[P]>
        }
      >
    >


  export type BedSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    displayName?: boolean
    bedNumber?: boolean
    isEnabled?: boolean
    roomId?: boolean
    bedStatusId?: boolean
    room?: boolean | Bed$roomArgs<ExtArgs>
    bedStatus?: boolean | Bed$bedStatusArgs<ExtArgs>
  }, ExtArgs["result"]["bed"]>

  export type BedSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    displayName?: boolean
    bedNumber?: boolean
    isEnabled?: boolean
    roomId?: boolean
    bedStatusId?: boolean
    room?: boolean | Bed$roomArgs<ExtArgs>
    bedStatus?: boolean | Bed$bedStatusArgs<ExtArgs>
  }, ExtArgs["result"]["bed"]>

  export type BedSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    displayName?: boolean
    bedNumber?: boolean
    isEnabled?: boolean
    roomId?: boolean
    bedStatusId?: boolean
    room?: boolean | Bed$roomArgs<ExtArgs>
    bedStatus?: boolean | Bed$bedStatusArgs<ExtArgs>
  }, ExtArgs["result"]["bed"]>

  export type BedSelectScalar = {
    id?: boolean
    displayName?: boolean
    bedNumber?: boolean
    isEnabled?: boolean
    roomId?: boolean
    bedStatusId?: boolean
  }

  export type BedOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "displayName" | "bedNumber" | "isEnabled" | "roomId" | "bedStatusId", ExtArgs["result"]["bed"]>
  export type BedInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    room?: boolean | Bed$roomArgs<ExtArgs>
    bedStatus?: boolean | Bed$bedStatusArgs<ExtArgs>
  }
  export type BedIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    room?: boolean | Bed$roomArgs<ExtArgs>
    bedStatus?: boolean | Bed$bedStatusArgs<ExtArgs>
  }
  export type BedIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    room?: boolean | Bed$roomArgs<ExtArgs>
    bedStatus?: boolean | Bed$bedStatusArgs<ExtArgs>
  }

  export type $BedPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Bed"
    objects: {
      room: Prisma.$RoomPayload<ExtArgs> | null
      bedStatus: Prisma.$BedStatusPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      displayName: string
      bedNumber: number
      isEnabled: boolean
      roomId: number | null
      bedStatusId: number | null
    }, ExtArgs["result"]["bed"]>
    composites: {}
  }

  type BedGetPayload<S extends boolean | null | undefined | BedDefaultArgs> = $Result.GetResult<Prisma.$BedPayload, S>

  type BedCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BedFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BedCountAggregateInputType | true
    }

  export interface BedDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Bed'], meta: { name: 'Bed' } }
    /**
     * Find zero or one Bed that matches the filter.
     * @param {BedFindUniqueArgs} args - Arguments to find a Bed
     * @example
     * // Get one Bed
     * const bed = await prisma.bed.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BedFindUniqueArgs>(args: SelectSubset<T, BedFindUniqueArgs<ExtArgs>>): Prisma__BedClient<$Result.GetResult<Prisma.$BedPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Bed that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BedFindUniqueOrThrowArgs} args - Arguments to find a Bed
     * @example
     * // Get one Bed
     * const bed = await prisma.bed.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BedFindUniqueOrThrowArgs>(args: SelectSubset<T, BedFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BedClient<$Result.GetResult<Prisma.$BedPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Bed that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BedFindFirstArgs} args - Arguments to find a Bed
     * @example
     * // Get one Bed
     * const bed = await prisma.bed.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BedFindFirstArgs>(args?: SelectSubset<T, BedFindFirstArgs<ExtArgs>>): Prisma__BedClient<$Result.GetResult<Prisma.$BedPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Bed that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BedFindFirstOrThrowArgs} args - Arguments to find a Bed
     * @example
     * // Get one Bed
     * const bed = await prisma.bed.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BedFindFirstOrThrowArgs>(args?: SelectSubset<T, BedFindFirstOrThrowArgs<ExtArgs>>): Prisma__BedClient<$Result.GetResult<Prisma.$BedPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Beds that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BedFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Beds
     * const beds = await prisma.bed.findMany()
     * 
     * // Get first 10 Beds
     * const beds = await prisma.bed.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bedWithIdOnly = await prisma.bed.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BedFindManyArgs>(args?: SelectSubset<T, BedFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BedPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Bed.
     * @param {BedCreateArgs} args - Arguments to create a Bed.
     * @example
     * // Create one Bed
     * const Bed = await prisma.bed.create({
     *   data: {
     *     // ... data to create a Bed
     *   }
     * })
     * 
     */
    create<T extends BedCreateArgs>(args: SelectSubset<T, BedCreateArgs<ExtArgs>>): Prisma__BedClient<$Result.GetResult<Prisma.$BedPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Beds.
     * @param {BedCreateManyArgs} args - Arguments to create many Beds.
     * @example
     * // Create many Beds
     * const bed = await prisma.bed.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BedCreateManyArgs>(args?: SelectSubset<T, BedCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Beds and returns the data saved in the database.
     * @param {BedCreateManyAndReturnArgs} args - Arguments to create many Beds.
     * @example
     * // Create many Beds
     * const bed = await prisma.bed.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Beds and only return the `id`
     * const bedWithIdOnly = await prisma.bed.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BedCreateManyAndReturnArgs>(args?: SelectSubset<T, BedCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BedPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Bed.
     * @param {BedDeleteArgs} args - Arguments to delete one Bed.
     * @example
     * // Delete one Bed
     * const Bed = await prisma.bed.delete({
     *   where: {
     *     // ... filter to delete one Bed
     *   }
     * })
     * 
     */
    delete<T extends BedDeleteArgs>(args: SelectSubset<T, BedDeleteArgs<ExtArgs>>): Prisma__BedClient<$Result.GetResult<Prisma.$BedPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Bed.
     * @param {BedUpdateArgs} args - Arguments to update one Bed.
     * @example
     * // Update one Bed
     * const bed = await prisma.bed.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BedUpdateArgs>(args: SelectSubset<T, BedUpdateArgs<ExtArgs>>): Prisma__BedClient<$Result.GetResult<Prisma.$BedPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Beds.
     * @param {BedDeleteManyArgs} args - Arguments to filter Beds to delete.
     * @example
     * // Delete a few Beds
     * const { count } = await prisma.bed.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BedDeleteManyArgs>(args?: SelectSubset<T, BedDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Beds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BedUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Beds
     * const bed = await prisma.bed.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BedUpdateManyArgs>(args: SelectSubset<T, BedUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Beds and returns the data updated in the database.
     * @param {BedUpdateManyAndReturnArgs} args - Arguments to update many Beds.
     * @example
     * // Update many Beds
     * const bed = await prisma.bed.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Beds and only return the `id`
     * const bedWithIdOnly = await prisma.bed.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BedUpdateManyAndReturnArgs>(args: SelectSubset<T, BedUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BedPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Bed.
     * @param {BedUpsertArgs} args - Arguments to update or create a Bed.
     * @example
     * // Update or create a Bed
     * const bed = await prisma.bed.upsert({
     *   create: {
     *     // ... data to create a Bed
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Bed we want to update
     *   }
     * })
     */
    upsert<T extends BedUpsertArgs>(args: SelectSubset<T, BedUpsertArgs<ExtArgs>>): Prisma__BedClient<$Result.GetResult<Prisma.$BedPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Beds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BedCountArgs} args - Arguments to filter Beds to count.
     * @example
     * // Count the number of Beds
     * const count = await prisma.bed.count({
     *   where: {
     *     // ... the filter for the Beds we want to count
     *   }
     * })
    **/
    count<T extends BedCountArgs>(
      args?: Subset<T, BedCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BedCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Bed.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BedAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BedAggregateArgs>(args: Subset<T, BedAggregateArgs>): Prisma.PrismaPromise<GetBedAggregateType<T>>

    /**
     * Group by Bed.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BedGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BedGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BedGroupByArgs['orderBy'] }
        : { orderBy?: BedGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BedGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBedGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Bed model
   */
  readonly fields: BedFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Bed.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BedClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    room<T extends Bed$roomArgs<ExtArgs> = {}>(args?: Subset<T, Bed$roomArgs<ExtArgs>>): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    bedStatus<T extends Bed$bedStatusArgs<ExtArgs> = {}>(args?: Subset<T, Bed$bedStatusArgs<ExtArgs>>): Prisma__BedStatusClient<$Result.GetResult<Prisma.$BedStatusPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Bed model
   */
  interface BedFieldRefs {
    readonly id: FieldRef<"Bed", 'Int'>
    readonly displayName: FieldRef<"Bed", 'String'>
    readonly bedNumber: FieldRef<"Bed", 'Int'>
    readonly isEnabled: FieldRef<"Bed", 'Boolean'>
    readonly roomId: FieldRef<"Bed", 'Int'>
    readonly bedStatusId: FieldRef<"Bed", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Bed findUnique
   */
  export type BedFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bed
     */
    select?: BedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bed
     */
    omit?: BedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BedInclude<ExtArgs> | null
    /**
     * Filter, which Bed to fetch.
     */
    where: BedWhereUniqueInput
  }

  /**
   * Bed findUniqueOrThrow
   */
  export type BedFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bed
     */
    select?: BedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bed
     */
    omit?: BedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BedInclude<ExtArgs> | null
    /**
     * Filter, which Bed to fetch.
     */
    where: BedWhereUniqueInput
  }

  /**
   * Bed findFirst
   */
  export type BedFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bed
     */
    select?: BedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bed
     */
    omit?: BedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BedInclude<ExtArgs> | null
    /**
     * Filter, which Bed to fetch.
     */
    where?: BedWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Beds to fetch.
     */
    orderBy?: BedOrderByWithRelationInput | BedOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Beds.
     */
    cursor?: BedWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Beds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Beds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Beds.
     */
    distinct?: BedScalarFieldEnum | BedScalarFieldEnum[]
  }

  /**
   * Bed findFirstOrThrow
   */
  export type BedFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bed
     */
    select?: BedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bed
     */
    omit?: BedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BedInclude<ExtArgs> | null
    /**
     * Filter, which Bed to fetch.
     */
    where?: BedWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Beds to fetch.
     */
    orderBy?: BedOrderByWithRelationInput | BedOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Beds.
     */
    cursor?: BedWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Beds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Beds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Beds.
     */
    distinct?: BedScalarFieldEnum | BedScalarFieldEnum[]
  }

  /**
   * Bed findMany
   */
  export type BedFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bed
     */
    select?: BedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bed
     */
    omit?: BedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BedInclude<ExtArgs> | null
    /**
     * Filter, which Beds to fetch.
     */
    where?: BedWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Beds to fetch.
     */
    orderBy?: BedOrderByWithRelationInput | BedOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Beds.
     */
    cursor?: BedWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Beds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Beds.
     */
    skip?: number
    distinct?: BedScalarFieldEnum | BedScalarFieldEnum[]
  }

  /**
   * Bed create
   */
  export type BedCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bed
     */
    select?: BedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bed
     */
    omit?: BedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BedInclude<ExtArgs> | null
    /**
     * The data needed to create a Bed.
     */
    data: XOR<BedCreateInput, BedUncheckedCreateInput>
  }

  /**
   * Bed createMany
   */
  export type BedCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Beds.
     */
    data: BedCreateManyInput | BedCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Bed createManyAndReturn
   */
  export type BedCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bed
     */
    select?: BedSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Bed
     */
    omit?: BedOmit<ExtArgs> | null
    /**
     * The data used to create many Beds.
     */
    data: BedCreateManyInput | BedCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BedIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Bed update
   */
  export type BedUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bed
     */
    select?: BedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bed
     */
    omit?: BedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BedInclude<ExtArgs> | null
    /**
     * The data needed to update a Bed.
     */
    data: XOR<BedUpdateInput, BedUncheckedUpdateInput>
    /**
     * Choose, which Bed to update.
     */
    where: BedWhereUniqueInput
  }

  /**
   * Bed updateMany
   */
  export type BedUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Beds.
     */
    data: XOR<BedUpdateManyMutationInput, BedUncheckedUpdateManyInput>
    /**
     * Filter which Beds to update
     */
    where?: BedWhereInput
    /**
     * Limit how many Beds to update.
     */
    limit?: number
  }

  /**
   * Bed updateManyAndReturn
   */
  export type BedUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bed
     */
    select?: BedSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Bed
     */
    omit?: BedOmit<ExtArgs> | null
    /**
     * The data used to update Beds.
     */
    data: XOR<BedUpdateManyMutationInput, BedUncheckedUpdateManyInput>
    /**
     * Filter which Beds to update
     */
    where?: BedWhereInput
    /**
     * Limit how many Beds to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BedIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Bed upsert
   */
  export type BedUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bed
     */
    select?: BedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bed
     */
    omit?: BedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BedInclude<ExtArgs> | null
    /**
     * The filter to search for the Bed to update in case it exists.
     */
    where: BedWhereUniqueInput
    /**
     * In case the Bed found by the `where` argument doesn't exist, create a new Bed with this data.
     */
    create: XOR<BedCreateInput, BedUncheckedCreateInput>
    /**
     * In case the Bed was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BedUpdateInput, BedUncheckedUpdateInput>
  }

  /**
   * Bed delete
   */
  export type BedDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bed
     */
    select?: BedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bed
     */
    omit?: BedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BedInclude<ExtArgs> | null
    /**
     * Filter which Bed to delete.
     */
    where: BedWhereUniqueInput
  }

  /**
   * Bed deleteMany
   */
  export type BedDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Beds to delete
     */
    where?: BedWhereInput
    /**
     * Limit how many Beds to delete.
     */
    limit?: number
  }

  /**
   * Bed.room
   */
  export type Bed$roomArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Room
     */
    omit?: RoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInclude<ExtArgs> | null
    where?: RoomWhereInput
  }

  /**
   * Bed.bedStatus
   */
  export type Bed$bedStatusArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BedStatus
     */
    select?: BedStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BedStatus
     */
    omit?: BedStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BedStatusInclude<ExtArgs> | null
    where?: BedStatusWhereInput
  }

  /**
   * Bed without action
   */
  export type BedDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bed
     */
    select?: BedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bed
     */
    omit?: BedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BedInclude<ExtArgs> | null
  }


  /**
   * Model Room
   */

  export type AggregateRoom = {
    _count: RoomCountAggregateOutputType | null
    _avg: RoomAvgAggregateOutputType | null
    _sum: RoomSumAggregateOutputType | null
    _min: RoomMinAggregateOutputType | null
    _max: RoomMaxAggregateOutputType | null
  }

  export type RoomAvgAggregateOutputType = {
    id: number | null
    unitId: number | null
    classId: number | null
  }

  export type RoomSumAggregateOutputType = {
    id: number | null
    unitId: number | null
    classId: number | null
  }

  export type RoomMinAggregateOutputType = {
    id: number | null
    roomName: string | null
    isEnabled: boolean | null
    unitId: number | null
    classId: number | null
  }

  export type RoomMaxAggregateOutputType = {
    id: number | null
    roomName: string | null
    isEnabled: boolean | null
    unitId: number | null
    classId: number | null
  }

  export type RoomCountAggregateOutputType = {
    id: number
    roomName: number
    isEnabled: number
    unitId: number
    classId: number
    _all: number
  }


  export type RoomAvgAggregateInputType = {
    id?: true
    unitId?: true
    classId?: true
  }

  export type RoomSumAggregateInputType = {
    id?: true
    unitId?: true
    classId?: true
  }

  export type RoomMinAggregateInputType = {
    id?: true
    roomName?: true
    isEnabled?: true
    unitId?: true
    classId?: true
  }

  export type RoomMaxAggregateInputType = {
    id?: true
    roomName?: true
    isEnabled?: true
    unitId?: true
    classId?: true
  }

  export type RoomCountAggregateInputType = {
    id?: true
    roomName?: true
    isEnabled?: true
    unitId?: true
    classId?: true
    _all?: true
  }

  export type RoomAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Room to aggregate.
     */
    where?: RoomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rooms to fetch.
     */
    orderBy?: RoomOrderByWithRelationInput | RoomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RoomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rooms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Rooms
    **/
    _count?: true | RoomCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RoomAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RoomSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoomMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoomMaxAggregateInputType
  }

  export type GetRoomAggregateType<T extends RoomAggregateArgs> = {
        [P in keyof T & keyof AggregateRoom]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRoom[P]>
      : GetScalarType<T[P], AggregateRoom[P]>
  }




  export type RoomGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoomWhereInput
    orderBy?: RoomOrderByWithAggregationInput | RoomOrderByWithAggregationInput[]
    by: RoomScalarFieldEnum[] | RoomScalarFieldEnum
    having?: RoomScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoomCountAggregateInputType | true
    _avg?: RoomAvgAggregateInputType
    _sum?: RoomSumAggregateInputType
    _min?: RoomMinAggregateInputType
    _max?: RoomMaxAggregateInputType
  }

  export type RoomGroupByOutputType = {
    id: number
    roomName: string
    isEnabled: boolean
    unitId: number | null
    classId: number | null
    _count: RoomCountAggregateOutputType | null
    _avg: RoomAvgAggregateOutputType | null
    _sum: RoomSumAggregateOutputType | null
    _min: RoomMinAggregateOutputType | null
    _max: RoomMaxAggregateOutputType | null
  }

  type GetRoomGroupByPayload<T extends RoomGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RoomGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoomGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoomGroupByOutputType[P]>
            : GetScalarType<T[P], RoomGroupByOutputType[P]>
        }
      >
    >


  export type RoomSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    roomName?: boolean
    isEnabled?: boolean
    unitId?: boolean
    classId?: boolean
    unit?: boolean | Room$unitArgs<ExtArgs>
    class?: boolean | Room$classArgs<ExtArgs>
    beds?: boolean | Room$bedsArgs<ExtArgs>
    _count?: boolean | RoomCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["room"]>

  export type RoomSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    roomName?: boolean
    isEnabled?: boolean
    unitId?: boolean
    classId?: boolean
    unit?: boolean | Room$unitArgs<ExtArgs>
    class?: boolean | Room$classArgs<ExtArgs>
  }, ExtArgs["result"]["room"]>

  export type RoomSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    roomName?: boolean
    isEnabled?: boolean
    unitId?: boolean
    classId?: boolean
    unit?: boolean | Room$unitArgs<ExtArgs>
    class?: boolean | Room$classArgs<ExtArgs>
  }, ExtArgs["result"]["room"]>

  export type RoomSelectScalar = {
    id?: boolean
    roomName?: boolean
    isEnabled?: boolean
    unitId?: boolean
    classId?: boolean
  }

  export type RoomOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "roomName" | "isEnabled" | "unitId" | "classId", ExtArgs["result"]["room"]>
  export type RoomInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    unit?: boolean | Room$unitArgs<ExtArgs>
    class?: boolean | Room$classArgs<ExtArgs>
    beds?: boolean | Room$bedsArgs<ExtArgs>
    _count?: boolean | RoomCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RoomIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    unit?: boolean | Room$unitArgs<ExtArgs>
    class?: boolean | Room$classArgs<ExtArgs>
  }
  export type RoomIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    unit?: boolean | Room$unitArgs<ExtArgs>
    class?: boolean | Room$classArgs<ExtArgs>
  }

  export type $RoomPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Room"
    objects: {
      unit: Prisma.$UnitPayload<ExtArgs> | null
      class: Prisma.$ClassPayload<ExtArgs> | null
      beds: Prisma.$BedPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      roomName: string
      isEnabled: boolean
      unitId: number | null
      classId: number | null
    }, ExtArgs["result"]["room"]>
    composites: {}
  }

  type RoomGetPayload<S extends boolean | null | undefined | RoomDefaultArgs> = $Result.GetResult<Prisma.$RoomPayload, S>

  type RoomCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RoomFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RoomCountAggregateInputType | true
    }

  export interface RoomDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Room'], meta: { name: 'Room' } }
    /**
     * Find zero or one Room that matches the filter.
     * @param {RoomFindUniqueArgs} args - Arguments to find a Room
     * @example
     * // Get one Room
     * const room = await prisma.room.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RoomFindUniqueArgs>(args: SelectSubset<T, RoomFindUniqueArgs<ExtArgs>>): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Room that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RoomFindUniqueOrThrowArgs} args - Arguments to find a Room
     * @example
     * // Get one Room
     * const room = await prisma.room.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RoomFindUniqueOrThrowArgs>(args: SelectSubset<T, RoomFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Room that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomFindFirstArgs} args - Arguments to find a Room
     * @example
     * // Get one Room
     * const room = await prisma.room.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RoomFindFirstArgs>(args?: SelectSubset<T, RoomFindFirstArgs<ExtArgs>>): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Room that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomFindFirstOrThrowArgs} args - Arguments to find a Room
     * @example
     * // Get one Room
     * const room = await prisma.room.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RoomFindFirstOrThrowArgs>(args?: SelectSubset<T, RoomFindFirstOrThrowArgs<ExtArgs>>): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Rooms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Rooms
     * const rooms = await prisma.room.findMany()
     * 
     * // Get first 10 Rooms
     * const rooms = await prisma.room.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const roomWithIdOnly = await prisma.room.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RoomFindManyArgs>(args?: SelectSubset<T, RoomFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Room.
     * @param {RoomCreateArgs} args - Arguments to create a Room.
     * @example
     * // Create one Room
     * const Room = await prisma.room.create({
     *   data: {
     *     // ... data to create a Room
     *   }
     * })
     * 
     */
    create<T extends RoomCreateArgs>(args: SelectSubset<T, RoomCreateArgs<ExtArgs>>): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Rooms.
     * @param {RoomCreateManyArgs} args - Arguments to create many Rooms.
     * @example
     * // Create many Rooms
     * const room = await prisma.room.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RoomCreateManyArgs>(args?: SelectSubset<T, RoomCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Rooms and returns the data saved in the database.
     * @param {RoomCreateManyAndReturnArgs} args - Arguments to create many Rooms.
     * @example
     * // Create many Rooms
     * const room = await prisma.room.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Rooms and only return the `id`
     * const roomWithIdOnly = await prisma.room.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RoomCreateManyAndReturnArgs>(args?: SelectSubset<T, RoomCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Room.
     * @param {RoomDeleteArgs} args - Arguments to delete one Room.
     * @example
     * // Delete one Room
     * const Room = await prisma.room.delete({
     *   where: {
     *     // ... filter to delete one Room
     *   }
     * })
     * 
     */
    delete<T extends RoomDeleteArgs>(args: SelectSubset<T, RoomDeleteArgs<ExtArgs>>): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Room.
     * @param {RoomUpdateArgs} args - Arguments to update one Room.
     * @example
     * // Update one Room
     * const room = await prisma.room.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RoomUpdateArgs>(args: SelectSubset<T, RoomUpdateArgs<ExtArgs>>): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Rooms.
     * @param {RoomDeleteManyArgs} args - Arguments to filter Rooms to delete.
     * @example
     * // Delete a few Rooms
     * const { count } = await prisma.room.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RoomDeleteManyArgs>(args?: SelectSubset<T, RoomDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Rooms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Rooms
     * const room = await prisma.room.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RoomUpdateManyArgs>(args: SelectSubset<T, RoomUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Rooms and returns the data updated in the database.
     * @param {RoomUpdateManyAndReturnArgs} args - Arguments to update many Rooms.
     * @example
     * // Update many Rooms
     * const room = await prisma.room.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Rooms and only return the `id`
     * const roomWithIdOnly = await prisma.room.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RoomUpdateManyAndReturnArgs>(args: SelectSubset<T, RoomUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Room.
     * @param {RoomUpsertArgs} args - Arguments to update or create a Room.
     * @example
     * // Update or create a Room
     * const room = await prisma.room.upsert({
     *   create: {
     *     // ... data to create a Room
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Room we want to update
     *   }
     * })
     */
    upsert<T extends RoomUpsertArgs>(args: SelectSubset<T, RoomUpsertArgs<ExtArgs>>): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Rooms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomCountArgs} args - Arguments to filter Rooms to count.
     * @example
     * // Count the number of Rooms
     * const count = await prisma.room.count({
     *   where: {
     *     // ... the filter for the Rooms we want to count
     *   }
     * })
    **/
    count<T extends RoomCountArgs>(
      args?: Subset<T, RoomCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoomCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Room.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoomAggregateArgs>(args: Subset<T, RoomAggregateArgs>): Prisma.PrismaPromise<GetRoomAggregateType<T>>

    /**
     * Group by Room.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RoomGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoomGroupByArgs['orderBy'] }
        : { orderBy?: RoomGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RoomGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoomGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Room model
   */
  readonly fields: RoomFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Room.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RoomClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    unit<T extends Room$unitArgs<ExtArgs> = {}>(args?: Subset<T, Room$unitArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    class<T extends Room$classArgs<ExtArgs> = {}>(args?: Subset<T, Room$classArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    beds<T extends Room$bedsArgs<ExtArgs> = {}>(args?: Subset<T, Room$bedsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BedPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Room model
   */
  interface RoomFieldRefs {
    readonly id: FieldRef<"Room", 'Int'>
    readonly roomName: FieldRef<"Room", 'String'>
    readonly isEnabled: FieldRef<"Room", 'Boolean'>
    readonly unitId: FieldRef<"Room", 'Int'>
    readonly classId: FieldRef<"Room", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Room findUnique
   */
  export type RoomFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Room
     */
    omit?: RoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInclude<ExtArgs> | null
    /**
     * Filter, which Room to fetch.
     */
    where: RoomWhereUniqueInput
  }

  /**
   * Room findUniqueOrThrow
   */
  export type RoomFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Room
     */
    omit?: RoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInclude<ExtArgs> | null
    /**
     * Filter, which Room to fetch.
     */
    where: RoomWhereUniqueInput
  }

  /**
   * Room findFirst
   */
  export type RoomFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Room
     */
    omit?: RoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInclude<ExtArgs> | null
    /**
     * Filter, which Room to fetch.
     */
    where?: RoomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rooms to fetch.
     */
    orderBy?: RoomOrderByWithRelationInput | RoomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Rooms.
     */
    cursor?: RoomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rooms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Rooms.
     */
    distinct?: RoomScalarFieldEnum | RoomScalarFieldEnum[]
  }

  /**
   * Room findFirstOrThrow
   */
  export type RoomFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Room
     */
    omit?: RoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInclude<ExtArgs> | null
    /**
     * Filter, which Room to fetch.
     */
    where?: RoomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rooms to fetch.
     */
    orderBy?: RoomOrderByWithRelationInput | RoomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Rooms.
     */
    cursor?: RoomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rooms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Rooms.
     */
    distinct?: RoomScalarFieldEnum | RoomScalarFieldEnum[]
  }

  /**
   * Room findMany
   */
  export type RoomFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Room
     */
    omit?: RoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInclude<ExtArgs> | null
    /**
     * Filter, which Rooms to fetch.
     */
    where?: RoomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rooms to fetch.
     */
    orderBy?: RoomOrderByWithRelationInput | RoomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Rooms.
     */
    cursor?: RoomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rooms.
     */
    skip?: number
    distinct?: RoomScalarFieldEnum | RoomScalarFieldEnum[]
  }

  /**
   * Room create
   */
  export type RoomCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Room
     */
    omit?: RoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInclude<ExtArgs> | null
    /**
     * The data needed to create a Room.
     */
    data: XOR<RoomCreateInput, RoomUncheckedCreateInput>
  }

  /**
   * Room createMany
   */
  export type RoomCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Rooms.
     */
    data: RoomCreateManyInput | RoomCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Room createManyAndReturn
   */
  export type RoomCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Room
     */
    omit?: RoomOmit<ExtArgs> | null
    /**
     * The data used to create many Rooms.
     */
    data: RoomCreateManyInput | RoomCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Room update
   */
  export type RoomUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Room
     */
    omit?: RoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInclude<ExtArgs> | null
    /**
     * The data needed to update a Room.
     */
    data: XOR<RoomUpdateInput, RoomUncheckedUpdateInput>
    /**
     * Choose, which Room to update.
     */
    where: RoomWhereUniqueInput
  }

  /**
   * Room updateMany
   */
  export type RoomUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Rooms.
     */
    data: XOR<RoomUpdateManyMutationInput, RoomUncheckedUpdateManyInput>
    /**
     * Filter which Rooms to update
     */
    where?: RoomWhereInput
    /**
     * Limit how many Rooms to update.
     */
    limit?: number
  }

  /**
   * Room updateManyAndReturn
   */
  export type RoomUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Room
     */
    omit?: RoomOmit<ExtArgs> | null
    /**
     * The data used to update Rooms.
     */
    data: XOR<RoomUpdateManyMutationInput, RoomUncheckedUpdateManyInput>
    /**
     * Filter which Rooms to update
     */
    where?: RoomWhereInput
    /**
     * Limit how many Rooms to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Room upsert
   */
  export type RoomUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Room
     */
    omit?: RoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInclude<ExtArgs> | null
    /**
     * The filter to search for the Room to update in case it exists.
     */
    where: RoomWhereUniqueInput
    /**
     * In case the Room found by the `where` argument doesn't exist, create a new Room with this data.
     */
    create: XOR<RoomCreateInput, RoomUncheckedCreateInput>
    /**
     * In case the Room was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RoomUpdateInput, RoomUncheckedUpdateInput>
  }

  /**
   * Room delete
   */
  export type RoomDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Room
     */
    omit?: RoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInclude<ExtArgs> | null
    /**
     * Filter which Room to delete.
     */
    where: RoomWhereUniqueInput
  }

  /**
   * Room deleteMany
   */
  export type RoomDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Rooms to delete
     */
    where?: RoomWhereInput
    /**
     * Limit how many Rooms to delete.
     */
    limit?: number
  }

  /**
   * Room.unit
   */
  export type Room$unitArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    where?: UnitWhereInput
  }

  /**
   * Room.class
   */
  export type Room$classArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    where?: ClassWhereInput
  }

  /**
   * Room.beds
   */
  export type Room$bedsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bed
     */
    select?: BedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bed
     */
    omit?: BedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BedInclude<ExtArgs> | null
    where?: BedWhereInput
    orderBy?: BedOrderByWithRelationInput | BedOrderByWithRelationInput[]
    cursor?: BedWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BedScalarFieldEnum | BedScalarFieldEnum[]
  }

  /**
   * Room without action
   */
  export type RoomDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Room
     */
    omit?: RoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInclude<ExtArgs> | null
  }


  /**
   * Model Unit
   */

  export type AggregateUnit = {
    _count: UnitCountAggregateOutputType | null
    _avg: UnitAvgAggregateOutputType | null
    _sum: UnitSumAggregateOutputType | null
    _min: UnitMinAggregateOutputType | null
    _max: UnitMaxAggregateOutputType | null
  }

  export type UnitAvgAggregateOutputType = {
    id: number | null
    departmentId: number | null
  }

  export type UnitSumAggregateOutputType = {
    id: number | null
    departmentId: number | null
  }

  export type UnitMinAggregateOutputType = {
    id: number | null
    unitName: string | null
    isEnabled: boolean | null
    departmentId: number | null
  }

  export type UnitMaxAggregateOutputType = {
    id: number | null
    unitName: string | null
    isEnabled: boolean | null
    departmentId: number | null
  }

  export type UnitCountAggregateOutputType = {
    id: number
    unitName: number
    isEnabled: number
    departmentId: number
    _all: number
  }


  export type UnitAvgAggregateInputType = {
    id?: true
    departmentId?: true
  }

  export type UnitSumAggregateInputType = {
    id?: true
    departmentId?: true
  }

  export type UnitMinAggregateInputType = {
    id?: true
    unitName?: true
    isEnabled?: true
    departmentId?: true
  }

  export type UnitMaxAggregateInputType = {
    id?: true
    unitName?: true
    isEnabled?: true
    departmentId?: true
  }

  export type UnitCountAggregateInputType = {
    id?: true
    unitName?: true
    isEnabled?: true
    departmentId?: true
    _all?: true
  }

  export type UnitAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Unit to aggregate.
     */
    where?: UnitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Units to fetch.
     */
    orderBy?: UnitOrderByWithRelationInput | UnitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UnitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Units from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Units.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Units
    **/
    _count?: true | UnitCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UnitAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UnitSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UnitMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UnitMaxAggregateInputType
  }

  export type GetUnitAggregateType<T extends UnitAggregateArgs> = {
        [P in keyof T & keyof AggregateUnit]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUnit[P]>
      : GetScalarType<T[P], AggregateUnit[P]>
  }




  export type UnitGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UnitWhereInput
    orderBy?: UnitOrderByWithAggregationInput | UnitOrderByWithAggregationInput[]
    by: UnitScalarFieldEnum[] | UnitScalarFieldEnum
    having?: UnitScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UnitCountAggregateInputType | true
    _avg?: UnitAvgAggregateInputType
    _sum?: UnitSumAggregateInputType
    _min?: UnitMinAggregateInputType
    _max?: UnitMaxAggregateInputType
  }

  export type UnitGroupByOutputType = {
    id: number
    unitName: string
    isEnabled: boolean
    departmentId: number | null
    _count: UnitCountAggregateOutputType | null
    _avg: UnitAvgAggregateOutputType | null
    _sum: UnitSumAggregateOutputType | null
    _min: UnitMinAggregateOutputType | null
    _max: UnitMaxAggregateOutputType | null
  }

  type GetUnitGroupByPayload<T extends UnitGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UnitGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UnitGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UnitGroupByOutputType[P]>
            : GetScalarType<T[P], UnitGroupByOutputType[P]>
        }
      >
    >


  export type UnitSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    unitName?: boolean
    isEnabled?: boolean
    departmentId?: boolean
    rooms?: boolean | Unit$roomsArgs<ExtArgs>
    department?: boolean | Unit$departmentArgs<ExtArgs>
    stockDetails?: boolean | Unit$stockDetailsArgs<ExtArgs>
    doctorSchedules?: boolean | Unit$doctorSchedulesArgs<ExtArgs>
    reservations?: boolean | Unit$reservationsArgs<ExtArgs>
    _count?: boolean | UnitCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["unit"]>

  export type UnitSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    unitName?: boolean
    isEnabled?: boolean
    departmentId?: boolean
    department?: boolean | Unit$departmentArgs<ExtArgs>
  }, ExtArgs["result"]["unit"]>

  export type UnitSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    unitName?: boolean
    isEnabled?: boolean
    departmentId?: boolean
    department?: boolean | Unit$departmentArgs<ExtArgs>
  }, ExtArgs["result"]["unit"]>

  export type UnitSelectScalar = {
    id?: boolean
    unitName?: boolean
    isEnabled?: boolean
    departmentId?: boolean
  }

  export type UnitOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "unitName" | "isEnabled" | "departmentId", ExtArgs["result"]["unit"]>
  export type UnitInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rooms?: boolean | Unit$roomsArgs<ExtArgs>
    department?: boolean | Unit$departmentArgs<ExtArgs>
    stockDetails?: boolean | Unit$stockDetailsArgs<ExtArgs>
    doctorSchedules?: boolean | Unit$doctorSchedulesArgs<ExtArgs>
    reservations?: boolean | Unit$reservationsArgs<ExtArgs>
    _count?: boolean | UnitCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UnitIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    department?: boolean | Unit$departmentArgs<ExtArgs>
  }
  export type UnitIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    department?: boolean | Unit$departmentArgs<ExtArgs>
  }

  export type $UnitPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Unit"
    objects: {
      rooms: Prisma.$RoomPayload<ExtArgs>[]
      department: Prisma.$DepartmentPayload<ExtArgs> | null
      stockDetails: Prisma.$StockDetailPayload<ExtArgs>[]
      doctorSchedules: Prisma.$DoctorSchedulePayload<ExtArgs>[]
      reservations: Prisma.$ReservationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      unitName: string
      isEnabled: boolean
      departmentId: number | null
    }, ExtArgs["result"]["unit"]>
    composites: {}
  }

  type UnitGetPayload<S extends boolean | null | undefined | UnitDefaultArgs> = $Result.GetResult<Prisma.$UnitPayload, S>

  type UnitCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UnitFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UnitCountAggregateInputType | true
    }

  export interface UnitDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Unit'], meta: { name: 'Unit' } }
    /**
     * Find zero or one Unit that matches the filter.
     * @param {UnitFindUniqueArgs} args - Arguments to find a Unit
     * @example
     * // Get one Unit
     * const unit = await prisma.unit.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UnitFindUniqueArgs>(args: SelectSubset<T, UnitFindUniqueArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Unit that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UnitFindUniqueOrThrowArgs} args - Arguments to find a Unit
     * @example
     * // Get one Unit
     * const unit = await prisma.unit.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UnitFindUniqueOrThrowArgs>(args: SelectSubset<T, UnitFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Unit that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitFindFirstArgs} args - Arguments to find a Unit
     * @example
     * // Get one Unit
     * const unit = await prisma.unit.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UnitFindFirstArgs>(args?: SelectSubset<T, UnitFindFirstArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Unit that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitFindFirstOrThrowArgs} args - Arguments to find a Unit
     * @example
     * // Get one Unit
     * const unit = await prisma.unit.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UnitFindFirstOrThrowArgs>(args?: SelectSubset<T, UnitFindFirstOrThrowArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Units that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Units
     * const units = await prisma.unit.findMany()
     * 
     * // Get first 10 Units
     * const units = await prisma.unit.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const unitWithIdOnly = await prisma.unit.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UnitFindManyArgs>(args?: SelectSubset<T, UnitFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Unit.
     * @param {UnitCreateArgs} args - Arguments to create a Unit.
     * @example
     * // Create one Unit
     * const Unit = await prisma.unit.create({
     *   data: {
     *     // ... data to create a Unit
     *   }
     * })
     * 
     */
    create<T extends UnitCreateArgs>(args: SelectSubset<T, UnitCreateArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Units.
     * @param {UnitCreateManyArgs} args - Arguments to create many Units.
     * @example
     * // Create many Units
     * const unit = await prisma.unit.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UnitCreateManyArgs>(args?: SelectSubset<T, UnitCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Units and returns the data saved in the database.
     * @param {UnitCreateManyAndReturnArgs} args - Arguments to create many Units.
     * @example
     * // Create many Units
     * const unit = await prisma.unit.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Units and only return the `id`
     * const unitWithIdOnly = await prisma.unit.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UnitCreateManyAndReturnArgs>(args?: SelectSubset<T, UnitCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Unit.
     * @param {UnitDeleteArgs} args - Arguments to delete one Unit.
     * @example
     * // Delete one Unit
     * const Unit = await prisma.unit.delete({
     *   where: {
     *     // ... filter to delete one Unit
     *   }
     * })
     * 
     */
    delete<T extends UnitDeleteArgs>(args: SelectSubset<T, UnitDeleteArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Unit.
     * @param {UnitUpdateArgs} args - Arguments to update one Unit.
     * @example
     * // Update one Unit
     * const unit = await prisma.unit.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UnitUpdateArgs>(args: SelectSubset<T, UnitUpdateArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Units.
     * @param {UnitDeleteManyArgs} args - Arguments to filter Units to delete.
     * @example
     * // Delete a few Units
     * const { count } = await prisma.unit.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UnitDeleteManyArgs>(args?: SelectSubset<T, UnitDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Units.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Units
     * const unit = await prisma.unit.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UnitUpdateManyArgs>(args: SelectSubset<T, UnitUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Units and returns the data updated in the database.
     * @param {UnitUpdateManyAndReturnArgs} args - Arguments to update many Units.
     * @example
     * // Update many Units
     * const unit = await prisma.unit.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Units and only return the `id`
     * const unitWithIdOnly = await prisma.unit.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UnitUpdateManyAndReturnArgs>(args: SelectSubset<T, UnitUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Unit.
     * @param {UnitUpsertArgs} args - Arguments to update or create a Unit.
     * @example
     * // Update or create a Unit
     * const unit = await prisma.unit.upsert({
     *   create: {
     *     // ... data to create a Unit
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Unit we want to update
     *   }
     * })
     */
    upsert<T extends UnitUpsertArgs>(args: SelectSubset<T, UnitUpsertArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Units.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitCountArgs} args - Arguments to filter Units to count.
     * @example
     * // Count the number of Units
     * const count = await prisma.unit.count({
     *   where: {
     *     // ... the filter for the Units we want to count
     *   }
     * })
    **/
    count<T extends UnitCountArgs>(
      args?: Subset<T, UnitCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UnitCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Unit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UnitAggregateArgs>(args: Subset<T, UnitAggregateArgs>): Prisma.PrismaPromise<GetUnitAggregateType<T>>

    /**
     * Group by Unit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UnitGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UnitGroupByArgs['orderBy'] }
        : { orderBy?: UnitGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UnitGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUnitGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Unit model
   */
  readonly fields: UnitFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Unit.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UnitClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    rooms<T extends Unit$roomsArgs<ExtArgs> = {}>(args?: Subset<T, Unit$roomsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    department<T extends Unit$departmentArgs<ExtArgs> = {}>(args?: Subset<T, Unit$departmentArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    stockDetails<T extends Unit$stockDetailsArgs<ExtArgs> = {}>(args?: Subset<T, Unit$stockDetailsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockDetailPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    doctorSchedules<T extends Unit$doctorSchedulesArgs<ExtArgs> = {}>(args?: Subset<T, Unit$doctorSchedulesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DoctorSchedulePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    reservations<T extends Unit$reservationsArgs<ExtArgs> = {}>(args?: Subset<T, Unit$reservationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReservationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Unit model
   */
  interface UnitFieldRefs {
    readonly id: FieldRef<"Unit", 'Int'>
    readonly unitName: FieldRef<"Unit", 'String'>
    readonly isEnabled: FieldRef<"Unit", 'Boolean'>
    readonly departmentId: FieldRef<"Unit", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Unit findUnique
   */
  export type UnitFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * Filter, which Unit to fetch.
     */
    where: UnitWhereUniqueInput
  }

  /**
   * Unit findUniqueOrThrow
   */
  export type UnitFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * Filter, which Unit to fetch.
     */
    where: UnitWhereUniqueInput
  }

  /**
   * Unit findFirst
   */
  export type UnitFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * Filter, which Unit to fetch.
     */
    where?: UnitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Units to fetch.
     */
    orderBy?: UnitOrderByWithRelationInput | UnitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Units.
     */
    cursor?: UnitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Units from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Units.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Units.
     */
    distinct?: UnitScalarFieldEnum | UnitScalarFieldEnum[]
  }

  /**
   * Unit findFirstOrThrow
   */
  export type UnitFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * Filter, which Unit to fetch.
     */
    where?: UnitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Units to fetch.
     */
    orderBy?: UnitOrderByWithRelationInput | UnitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Units.
     */
    cursor?: UnitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Units from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Units.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Units.
     */
    distinct?: UnitScalarFieldEnum | UnitScalarFieldEnum[]
  }

  /**
   * Unit findMany
   */
  export type UnitFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * Filter, which Units to fetch.
     */
    where?: UnitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Units to fetch.
     */
    orderBy?: UnitOrderByWithRelationInput | UnitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Units.
     */
    cursor?: UnitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Units from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Units.
     */
    skip?: number
    distinct?: UnitScalarFieldEnum | UnitScalarFieldEnum[]
  }

  /**
   * Unit create
   */
  export type UnitCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * The data needed to create a Unit.
     */
    data: XOR<UnitCreateInput, UnitUncheckedCreateInput>
  }

  /**
   * Unit createMany
   */
  export type UnitCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Units.
     */
    data: UnitCreateManyInput | UnitCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Unit createManyAndReturn
   */
  export type UnitCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * The data used to create many Units.
     */
    data: UnitCreateManyInput | UnitCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Unit update
   */
  export type UnitUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * The data needed to update a Unit.
     */
    data: XOR<UnitUpdateInput, UnitUncheckedUpdateInput>
    /**
     * Choose, which Unit to update.
     */
    where: UnitWhereUniqueInput
  }

  /**
   * Unit updateMany
   */
  export type UnitUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Units.
     */
    data: XOR<UnitUpdateManyMutationInput, UnitUncheckedUpdateManyInput>
    /**
     * Filter which Units to update
     */
    where?: UnitWhereInput
    /**
     * Limit how many Units to update.
     */
    limit?: number
  }

  /**
   * Unit updateManyAndReturn
   */
  export type UnitUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * The data used to update Units.
     */
    data: XOR<UnitUpdateManyMutationInput, UnitUncheckedUpdateManyInput>
    /**
     * Filter which Units to update
     */
    where?: UnitWhereInput
    /**
     * Limit how many Units to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Unit upsert
   */
  export type UnitUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * The filter to search for the Unit to update in case it exists.
     */
    where: UnitWhereUniqueInput
    /**
     * In case the Unit found by the `where` argument doesn't exist, create a new Unit with this data.
     */
    create: XOR<UnitCreateInput, UnitUncheckedCreateInput>
    /**
     * In case the Unit was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UnitUpdateInput, UnitUncheckedUpdateInput>
  }

  /**
   * Unit delete
   */
  export type UnitDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * Filter which Unit to delete.
     */
    where: UnitWhereUniqueInput
  }

  /**
   * Unit deleteMany
   */
  export type UnitDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Units to delete
     */
    where?: UnitWhereInput
    /**
     * Limit how many Units to delete.
     */
    limit?: number
  }

  /**
   * Unit.rooms
   */
  export type Unit$roomsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Room
     */
    omit?: RoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInclude<ExtArgs> | null
    where?: RoomWhereInput
    orderBy?: RoomOrderByWithRelationInput | RoomOrderByWithRelationInput[]
    cursor?: RoomWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RoomScalarFieldEnum | RoomScalarFieldEnum[]
  }

  /**
   * Unit.department
   */
  export type Unit$departmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    where?: DepartmentWhereInput
  }

  /**
   * Unit.stockDetails
   */
  export type Unit$stockDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockDetail
     */
    select?: StockDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockDetail
     */
    omit?: StockDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockDetailInclude<ExtArgs> | null
    where?: StockDetailWhereInput
    orderBy?: StockDetailOrderByWithRelationInput | StockDetailOrderByWithRelationInput[]
    cursor?: StockDetailWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StockDetailScalarFieldEnum | StockDetailScalarFieldEnum[]
  }

  /**
   * Unit.doctorSchedules
   */
  export type Unit$doctorSchedulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoctorSchedule
     */
    select?: DoctorScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DoctorSchedule
     */
    omit?: DoctorScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorScheduleInclude<ExtArgs> | null
    where?: DoctorScheduleWhereInput
    orderBy?: DoctorScheduleOrderByWithRelationInput | DoctorScheduleOrderByWithRelationInput[]
    cursor?: DoctorScheduleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DoctorScheduleScalarFieldEnum | DoctorScheduleScalarFieldEnum[]
  }

  /**
   * Unit.reservations
   */
  export type Unit$reservationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reservation
     */
    select?: ReservationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reservation
     */
    omit?: ReservationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationInclude<ExtArgs> | null
    where?: ReservationWhereInput
    orderBy?: ReservationOrderByWithRelationInput | ReservationOrderByWithRelationInput[]
    cursor?: ReservationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReservationScalarFieldEnum | ReservationScalarFieldEnum[]
  }

  /**
   * Unit without action
   */
  export type UnitDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
  }


  /**
   * Model BedStatus
   */

  export type AggregateBedStatus = {
    _count: BedStatusCountAggregateOutputType | null
    _avg: BedStatusAvgAggregateOutputType | null
    _sum: BedStatusSumAggregateOutputType | null
    _min: BedStatusMinAggregateOutputType | null
    _max: BedStatusMaxAggregateOutputType | null
  }

  export type BedStatusAvgAggregateOutputType = {
    id: number | null
  }

  export type BedStatusSumAggregateOutputType = {
    id: number | null
  }

  export type BedStatusMinAggregateOutputType = {
    id: number | null
    status: string | null
    isEnabled: boolean | null
  }

  export type BedStatusMaxAggregateOutputType = {
    id: number | null
    status: string | null
    isEnabled: boolean | null
  }

  export type BedStatusCountAggregateOutputType = {
    id: number
    status: number
    isEnabled: number
    _all: number
  }


  export type BedStatusAvgAggregateInputType = {
    id?: true
  }

  export type BedStatusSumAggregateInputType = {
    id?: true
  }

  export type BedStatusMinAggregateInputType = {
    id?: true
    status?: true
    isEnabled?: true
  }

  export type BedStatusMaxAggregateInputType = {
    id?: true
    status?: true
    isEnabled?: true
  }

  export type BedStatusCountAggregateInputType = {
    id?: true
    status?: true
    isEnabled?: true
    _all?: true
  }

  export type BedStatusAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BedStatus to aggregate.
     */
    where?: BedStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BedStatuses to fetch.
     */
    orderBy?: BedStatusOrderByWithRelationInput | BedStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BedStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BedStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BedStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BedStatuses
    **/
    _count?: true | BedStatusCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BedStatusAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BedStatusSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BedStatusMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BedStatusMaxAggregateInputType
  }

  export type GetBedStatusAggregateType<T extends BedStatusAggregateArgs> = {
        [P in keyof T & keyof AggregateBedStatus]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBedStatus[P]>
      : GetScalarType<T[P], AggregateBedStatus[P]>
  }




  export type BedStatusGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BedStatusWhereInput
    orderBy?: BedStatusOrderByWithAggregationInput | BedStatusOrderByWithAggregationInput[]
    by: BedStatusScalarFieldEnum[] | BedStatusScalarFieldEnum
    having?: BedStatusScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BedStatusCountAggregateInputType | true
    _avg?: BedStatusAvgAggregateInputType
    _sum?: BedStatusSumAggregateInputType
    _min?: BedStatusMinAggregateInputType
    _max?: BedStatusMaxAggregateInputType
  }

  export type BedStatusGroupByOutputType = {
    id: number
    status: string
    isEnabled: boolean
    _count: BedStatusCountAggregateOutputType | null
    _avg: BedStatusAvgAggregateOutputType | null
    _sum: BedStatusSumAggregateOutputType | null
    _min: BedStatusMinAggregateOutputType | null
    _max: BedStatusMaxAggregateOutputType | null
  }

  type GetBedStatusGroupByPayload<T extends BedStatusGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BedStatusGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BedStatusGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BedStatusGroupByOutputType[P]>
            : GetScalarType<T[P], BedStatusGroupByOutputType[P]>
        }
      >
    >


  export type BedStatusSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    status?: boolean
    isEnabled?: boolean
    beds?: boolean | BedStatus$bedsArgs<ExtArgs>
    _count?: boolean | BedStatusCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bedStatus"]>

  export type BedStatusSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    status?: boolean
    isEnabled?: boolean
  }, ExtArgs["result"]["bedStatus"]>

  export type BedStatusSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    status?: boolean
    isEnabled?: boolean
  }, ExtArgs["result"]["bedStatus"]>

  export type BedStatusSelectScalar = {
    id?: boolean
    status?: boolean
    isEnabled?: boolean
  }

  export type BedStatusOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "status" | "isEnabled", ExtArgs["result"]["bedStatus"]>
  export type BedStatusInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    beds?: boolean | BedStatus$bedsArgs<ExtArgs>
    _count?: boolean | BedStatusCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BedStatusIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type BedStatusIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $BedStatusPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BedStatus"
    objects: {
      beds: Prisma.$BedPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      status: string
      isEnabled: boolean
    }, ExtArgs["result"]["bedStatus"]>
    composites: {}
  }

  type BedStatusGetPayload<S extends boolean | null | undefined | BedStatusDefaultArgs> = $Result.GetResult<Prisma.$BedStatusPayload, S>

  type BedStatusCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BedStatusFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BedStatusCountAggregateInputType | true
    }

  export interface BedStatusDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BedStatus'], meta: { name: 'BedStatus' } }
    /**
     * Find zero or one BedStatus that matches the filter.
     * @param {BedStatusFindUniqueArgs} args - Arguments to find a BedStatus
     * @example
     * // Get one BedStatus
     * const bedStatus = await prisma.bedStatus.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BedStatusFindUniqueArgs>(args: SelectSubset<T, BedStatusFindUniqueArgs<ExtArgs>>): Prisma__BedStatusClient<$Result.GetResult<Prisma.$BedStatusPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BedStatus that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BedStatusFindUniqueOrThrowArgs} args - Arguments to find a BedStatus
     * @example
     * // Get one BedStatus
     * const bedStatus = await prisma.bedStatus.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BedStatusFindUniqueOrThrowArgs>(args: SelectSubset<T, BedStatusFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BedStatusClient<$Result.GetResult<Prisma.$BedStatusPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BedStatus that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BedStatusFindFirstArgs} args - Arguments to find a BedStatus
     * @example
     * // Get one BedStatus
     * const bedStatus = await prisma.bedStatus.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BedStatusFindFirstArgs>(args?: SelectSubset<T, BedStatusFindFirstArgs<ExtArgs>>): Prisma__BedStatusClient<$Result.GetResult<Prisma.$BedStatusPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BedStatus that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BedStatusFindFirstOrThrowArgs} args - Arguments to find a BedStatus
     * @example
     * // Get one BedStatus
     * const bedStatus = await prisma.bedStatus.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BedStatusFindFirstOrThrowArgs>(args?: SelectSubset<T, BedStatusFindFirstOrThrowArgs<ExtArgs>>): Prisma__BedStatusClient<$Result.GetResult<Prisma.$BedStatusPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BedStatuses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BedStatusFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BedStatuses
     * const bedStatuses = await prisma.bedStatus.findMany()
     * 
     * // Get first 10 BedStatuses
     * const bedStatuses = await prisma.bedStatus.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bedStatusWithIdOnly = await prisma.bedStatus.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BedStatusFindManyArgs>(args?: SelectSubset<T, BedStatusFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BedStatusPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BedStatus.
     * @param {BedStatusCreateArgs} args - Arguments to create a BedStatus.
     * @example
     * // Create one BedStatus
     * const BedStatus = await prisma.bedStatus.create({
     *   data: {
     *     // ... data to create a BedStatus
     *   }
     * })
     * 
     */
    create<T extends BedStatusCreateArgs>(args: SelectSubset<T, BedStatusCreateArgs<ExtArgs>>): Prisma__BedStatusClient<$Result.GetResult<Prisma.$BedStatusPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BedStatuses.
     * @param {BedStatusCreateManyArgs} args - Arguments to create many BedStatuses.
     * @example
     * // Create many BedStatuses
     * const bedStatus = await prisma.bedStatus.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BedStatusCreateManyArgs>(args?: SelectSubset<T, BedStatusCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BedStatuses and returns the data saved in the database.
     * @param {BedStatusCreateManyAndReturnArgs} args - Arguments to create many BedStatuses.
     * @example
     * // Create many BedStatuses
     * const bedStatus = await prisma.bedStatus.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BedStatuses and only return the `id`
     * const bedStatusWithIdOnly = await prisma.bedStatus.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BedStatusCreateManyAndReturnArgs>(args?: SelectSubset<T, BedStatusCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BedStatusPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BedStatus.
     * @param {BedStatusDeleteArgs} args - Arguments to delete one BedStatus.
     * @example
     * // Delete one BedStatus
     * const BedStatus = await prisma.bedStatus.delete({
     *   where: {
     *     // ... filter to delete one BedStatus
     *   }
     * })
     * 
     */
    delete<T extends BedStatusDeleteArgs>(args: SelectSubset<T, BedStatusDeleteArgs<ExtArgs>>): Prisma__BedStatusClient<$Result.GetResult<Prisma.$BedStatusPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BedStatus.
     * @param {BedStatusUpdateArgs} args - Arguments to update one BedStatus.
     * @example
     * // Update one BedStatus
     * const bedStatus = await prisma.bedStatus.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BedStatusUpdateArgs>(args: SelectSubset<T, BedStatusUpdateArgs<ExtArgs>>): Prisma__BedStatusClient<$Result.GetResult<Prisma.$BedStatusPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BedStatuses.
     * @param {BedStatusDeleteManyArgs} args - Arguments to filter BedStatuses to delete.
     * @example
     * // Delete a few BedStatuses
     * const { count } = await prisma.bedStatus.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BedStatusDeleteManyArgs>(args?: SelectSubset<T, BedStatusDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BedStatuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BedStatusUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BedStatuses
     * const bedStatus = await prisma.bedStatus.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BedStatusUpdateManyArgs>(args: SelectSubset<T, BedStatusUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BedStatuses and returns the data updated in the database.
     * @param {BedStatusUpdateManyAndReturnArgs} args - Arguments to update many BedStatuses.
     * @example
     * // Update many BedStatuses
     * const bedStatus = await prisma.bedStatus.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BedStatuses and only return the `id`
     * const bedStatusWithIdOnly = await prisma.bedStatus.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BedStatusUpdateManyAndReturnArgs>(args: SelectSubset<T, BedStatusUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BedStatusPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BedStatus.
     * @param {BedStatusUpsertArgs} args - Arguments to update or create a BedStatus.
     * @example
     * // Update or create a BedStatus
     * const bedStatus = await prisma.bedStatus.upsert({
     *   create: {
     *     // ... data to create a BedStatus
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BedStatus we want to update
     *   }
     * })
     */
    upsert<T extends BedStatusUpsertArgs>(args: SelectSubset<T, BedStatusUpsertArgs<ExtArgs>>): Prisma__BedStatusClient<$Result.GetResult<Prisma.$BedStatusPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BedStatuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BedStatusCountArgs} args - Arguments to filter BedStatuses to count.
     * @example
     * // Count the number of BedStatuses
     * const count = await prisma.bedStatus.count({
     *   where: {
     *     // ... the filter for the BedStatuses we want to count
     *   }
     * })
    **/
    count<T extends BedStatusCountArgs>(
      args?: Subset<T, BedStatusCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BedStatusCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BedStatus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BedStatusAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BedStatusAggregateArgs>(args: Subset<T, BedStatusAggregateArgs>): Prisma.PrismaPromise<GetBedStatusAggregateType<T>>

    /**
     * Group by BedStatus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BedStatusGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BedStatusGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BedStatusGroupByArgs['orderBy'] }
        : { orderBy?: BedStatusGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BedStatusGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBedStatusGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BedStatus model
   */
  readonly fields: BedStatusFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BedStatus.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BedStatusClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    beds<T extends BedStatus$bedsArgs<ExtArgs> = {}>(args?: Subset<T, BedStatus$bedsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BedPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BedStatus model
   */
  interface BedStatusFieldRefs {
    readonly id: FieldRef<"BedStatus", 'Int'>
    readonly status: FieldRef<"BedStatus", 'String'>
    readonly isEnabled: FieldRef<"BedStatus", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * BedStatus findUnique
   */
  export type BedStatusFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BedStatus
     */
    select?: BedStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BedStatus
     */
    omit?: BedStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BedStatusInclude<ExtArgs> | null
    /**
     * Filter, which BedStatus to fetch.
     */
    where: BedStatusWhereUniqueInput
  }

  /**
   * BedStatus findUniqueOrThrow
   */
  export type BedStatusFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BedStatus
     */
    select?: BedStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BedStatus
     */
    omit?: BedStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BedStatusInclude<ExtArgs> | null
    /**
     * Filter, which BedStatus to fetch.
     */
    where: BedStatusWhereUniqueInput
  }

  /**
   * BedStatus findFirst
   */
  export type BedStatusFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BedStatus
     */
    select?: BedStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BedStatus
     */
    omit?: BedStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BedStatusInclude<ExtArgs> | null
    /**
     * Filter, which BedStatus to fetch.
     */
    where?: BedStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BedStatuses to fetch.
     */
    orderBy?: BedStatusOrderByWithRelationInput | BedStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BedStatuses.
     */
    cursor?: BedStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BedStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BedStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BedStatuses.
     */
    distinct?: BedStatusScalarFieldEnum | BedStatusScalarFieldEnum[]
  }

  /**
   * BedStatus findFirstOrThrow
   */
  export type BedStatusFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BedStatus
     */
    select?: BedStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BedStatus
     */
    omit?: BedStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BedStatusInclude<ExtArgs> | null
    /**
     * Filter, which BedStatus to fetch.
     */
    where?: BedStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BedStatuses to fetch.
     */
    orderBy?: BedStatusOrderByWithRelationInput | BedStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BedStatuses.
     */
    cursor?: BedStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BedStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BedStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BedStatuses.
     */
    distinct?: BedStatusScalarFieldEnum | BedStatusScalarFieldEnum[]
  }

  /**
   * BedStatus findMany
   */
  export type BedStatusFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BedStatus
     */
    select?: BedStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BedStatus
     */
    omit?: BedStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BedStatusInclude<ExtArgs> | null
    /**
     * Filter, which BedStatuses to fetch.
     */
    where?: BedStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BedStatuses to fetch.
     */
    orderBy?: BedStatusOrderByWithRelationInput | BedStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BedStatuses.
     */
    cursor?: BedStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BedStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BedStatuses.
     */
    skip?: number
    distinct?: BedStatusScalarFieldEnum | BedStatusScalarFieldEnum[]
  }

  /**
   * BedStatus create
   */
  export type BedStatusCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BedStatus
     */
    select?: BedStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BedStatus
     */
    omit?: BedStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BedStatusInclude<ExtArgs> | null
    /**
     * The data needed to create a BedStatus.
     */
    data: XOR<BedStatusCreateInput, BedStatusUncheckedCreateInput>
  }

  /**
   * BedStatus createMany
   */
  export type BedStatusCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BedStatuses.
     */
    data: BedStatusCreateManyInput | BedStatusCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BedStatus createManyAndReturn
   */
  export type BedStatusCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BedStatus
     */
    select?: BedStatusSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BedStatus
     */
    omit?: BedStatusOmit<ExtArgs> | null
    /**
     * The data used to create many BedStatuses.
     */
    data: BedStatusCreateManyInput | BedStatusCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BedStatus update
   */
  export type BedStatusUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BedStatus
     */
    select?: BedStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BedStatus
     */
    omit?: BedStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BedStatusInclude<ExtArgs> | null
    /**
     * The data needed to update a BedStatus.
     */
    data: XOR<BedStatusUpdateInput, BedStatusUncheckedUpdateInput>
    /**
     * Choose, which BedStatus to update.
     */
    where: BedStatusWhereUniqueInput
  }

  /**
   * BedStatus updateMany
   */
  export type BedStatusUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BedStatuses.
     */
    data: XOR<BedStatusUpdateManyMutationInput, BedStatusUncheckedUpdateManyInput>
    /**
     * Filter which BedStatuses to update
     */
    where?: BedStatusWhereInput
    /**
     * Limit how many BedStatuses to update.
     */
    limit?: number
  }

  /**
   * BedStatus updateManyAndReturn
   */
  export type BedStatusUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BedStatus
     */
    select?: BedStatusSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BedStatus
     */
    omit?: BedStatusOmit<ExtArgs> | null
    /**
     * The data used to update BedStatuses.
     */
    data: XOR<BedStatusUpdateManyMutationInput, BedStatusUncheckedUpdateManyInput>
    /**
     * Filter which BedStatuses to update
     */
    where?: BedStatusWhereInput
    /**
     * Limit how many BedStatuses to update.
     */
    limit?: number
  }

  /**
   * BedStatus upsert
   */
  export type BedStatusUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BedStatus
     */
    select?: BedStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BedStatus
     */
    omit?: BedStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BedStatusInclude<ExtArgs> | null
    /**
     * The filter to search for the BedStatus to update in case it exists.
     */
    where: BedStatusWhereUniqueInput
    /**
     * In case the BedStatus found by the `where` argument doesn't exist, create a new BedStatus with this data.
     */
    create: XOR<BedStatusCreateInput, BedStatusUncheckedCreateInput>
    /**
     * In case the BedStatus was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BedStatusUpdateInput, BedStatusUncheckedUpdateInput>
  }

  /**
   * BedStatus delete
   */
  export type BedStatusDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BedStatus
     */
    select?: BedStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BedStatus
     */
    omit?: BedStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BedStatusInclude<ExtArgs> | null
    /**
     * Filter which BedStatus to delete.
     */
    where: BedStatusWhereUniqueInput
  }

  /**
   * BedStatus deleteMany
   */
  export type BedStatusDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BedStatuses to delete
     */
    where?: BedStatusWhereInput
    /**
     * Limit how many BedStatuses to delete.
     */
    limit?: number
  }

  /**
   * BedStatus.beds
   */
  export type BedStatus$bedsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bed
     */
    select?: BedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bed
     */
    omit?: BedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BedInclude<ExtArgs> | null
    where?: BedWhereInput
    orderBy?: BedOrderByWithRelationInput | BedOrderByWithRelationInput[]
    cursor?: BedWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BedScalarFieldEnum | BedScalarFieldEnum[]
  }

  /**
   * BedStatus without action
   */
  export type BedStatusDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BedStatus
     */
    select?: BedStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BedStatus
     */
    omit?: BedStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BedStatusInclude<ExtArgs> | null
  }


  /**
   * Model Class
   */

  export type AggregateClass = {
    _count: ClassCountAggregateOutputType | null
    _avg: ClassAvgAggregateOutputType | null
    _sum: ClassSumAggregateOutputType | null
    _min: ClassMinAggregateOutputType | null
    _max: ClassMaxAggregateOutputType | null
  }

  export type ClassAvgAggregateOutputType = {
    id: number | null
  }

  export type ClassSumAggregateOutputType = {
    id: number | null
  }

  export type ClassMinAggregateOutputType = {
    id: number | null
    className: string | null
    isEnabled: boolean | null
  }

  export type ClassMaxAggregateOutputType = {
    id: number | null
    className: string | null
    isEnabled: boolean | null
  }

  export type ClassCountAggregateOutputType = {
    id: number
    className: number
    isEnabled: number
    _all: number
  }


  export type ClassAvgAggregateInputType = {
    id?: true
  }

  export type ClassSumAggregateInputType = {
    id?: true
  }

  export type ClassMinAggregateInputType = {
    id?: true
    className?: true
    isEnabled?: true
  }

  export type ClassMaxAggregateInputType = {
    id?: true
    className?: true
    isEnabled?: true
  }

  export type ClassCountAggregateInputType = {
    id?: true
    className?: true
    isEnabled?: true
    _all?: true
  }

  export type ClassAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Class to aggregate.
     */
    where?: ClassWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Classes to fetch.
     */
    orderBy?: ClassOrderByWithRelationInput | ClassOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClassWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Classes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Classes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Classes
    **/
    _count?: true | ClassCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ClassAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ClassSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClassMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClassMaxAggregateInputType
  }

  export type GetClassAggregateType<T extends ClassAggregateArgs> = {
        [P in keyof T & keyof AggregateClass]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClass[P]>
      : GetScalarType<T[P], AggregateClass[P]>
  }




  export type ClassGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClassWhereInput
    orderBy?: ClassOrderByWithAggregationInput | ClassOrderByWithAggregationInput[]
    by: ClassScalarFieldEnum[] | ClassScalarFieldEnum
    having?: ClassScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClassCountAggregateInputType | true
    _avg?: ClassAvgAggregateInputType
    _sum?: ClassSumAggregateInputType
    _min?: ClassMinAggregateInputType
    _max?: ClassMaxAggregateInputType
  }

  export type ClassGroupByOutputType = {
    id: number
    className: string
    isEnabled: boolean
    _count: ClassCountAggregateOutputType | null
    _avg: ClassAvgAggregateOutputType | null
    _sum: ClassSumAggregateOutputType | null
    _min: ClassMinAggregateOutputType | null
    _max: ClassMaxAggregateOutputType | null
  }

  type GetClassGroupByPayload<T extends ClassGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClassGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClassGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClassGroupByOutputType[P]>
            : GetScalarType<T[P], ClassGroupByOutputType[P]>
        }
      >
    >


  export type ClassSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    className?: boolean
    isEnabled?: boolean
    rooms?: boolean | Class$roomsArgs<ExtArgs>
    _count?: boolean | ClassCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["class"]>

  export type ClassSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    className?: boolean
    isEnabled?: boolean
  }, ExtArgs["result"]["class"]>

  export type ClassSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    className?: boolean
    isEnabled?: boolean
  }, ExtArgs["result"]["class"]>

  export type ClassSelectScalar = {
    id?: boolean
    className?: boolean
    isEnabled?: boolean
  }

  export type ClassOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "className" | "isEnabled", ExtArgs["result"]["class"]>
  export type ClassInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rooms?: boolean | Class$roomsArgs<ExtArgs>
    _count?: boolean | ClassCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ClassIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ClassIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ClassPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Class"
    objects: {
      rooms: Prisma.$RoomPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      className: string
      isEnabled: boolean
    }, ExtArgs["result"]["class"]>
    composites: {}
  }

  type ClassGetPayload<S extends boolean | null | undefined | ClassDefaultArgs> = $Result.GetResult<Prisma.$ClassPayload, S>

  type ClassCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ClassFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ClassCountAggregateInputType | true
    }

  export interface ClassDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Class'], meta: { name: 'Class' } }
    /**
     * Find zero or one Class that matches the filter.
     * @param {ClassFindUniqueArgs} args - Arguments to find a Class
     * @example
     * // Get one Class
     * const class = await prisma.class.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClassFindUniqueArgs>(args: SelectSubset<T, ClassFindUniqueArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Class that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ClassFindUniqueOrThrowArgs} args - Arguments to find a Class
     * @example
     * // Get one Class
     * const class = await prisma.class.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClassFindUniqueOrThrowArgs>(args: SelectSubset<T, ClassFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Class that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassFindFirstArgs} args - Arguments to find a Class
     * @example
     * // Get one Class
     * const class = await prisma.class.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClassFindFirstArgs>(args?: SelectSubset<T, ClassFindFirstArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Class that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassFindFirstOrThrowArgs} args - Arguments to find a Class
     * @example
     * // Get one Class
     * const class = await prisma.class.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClassFindFirstOrThrowArgs>(args?: SelectSubset<T, ClassFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Classes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Classes
     * const classes = await prisma.class.findMany()
     * 
     * // Get first 10 Classes
     * const classes = await prisma.class.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const classWithIdOnly = await prisma.class.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ClassFindManyArgs>(args?: SelectSubset<T, ClassFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Class.
     * @param {ClassCreateArgs} args - Arguments to create a Class.
     * @example
     * // Create one Class
     * const Class = await prisma.class.create({
     *   data: {
     *     // ... data to create a Class
     *   }
     * })
     * 
     */
    create<T extends ClassCreateArgs>(args: SelectSubset<T, ClassCreateArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Classes.
     * @param {ClassCreateManyArgs} args - Arguments to create many Classes.
     * @example
     * // Create many Classes
     * const class = await prisma.class.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClassCreateManyArgs>(args?: SelectSubset<T, ClassCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Classes and returns the data saved in the database.
     * @param {ClassCreateManyAndReturnArgs} args - Arguments to create many Classes.
     * @example
     * // Create many Classes
     * const class = await prisma.class.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Classes and only return the `id`
     * const classWithIdOnly = await prisma.class.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ClassCreateManyAndReturnArgs>(args?: SelectSubset<T, ClassCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Class.
     * @param {ClassDeleteArgs} args - Arguments to delete one Class.
     * @example
     * // Delete one Class
     * const Class = await prisma.class.delete({
     *   where: {
     *     // ... filter to delete one Class
     *   }
     * })
     * 
     */
    delete<T extends ClassDeleteArgs>(args: SelectSubset<T, ClassDeleteArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Class.
     * @param {ClassUpdateArgs} args - Arguments to update one Class.
     * @example
     * // Update one Class
     * const class = await prisma.class.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClassUpdateArgs>(args: SelectSubset<T, ClassUpdateArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Classes.
     * @param {ClassDeleteManyArgs} args - Arguments to filter Classes to delete.
     * @example
     * // Delete a few Classes
     * const { count } = await prisma.class.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClassDeleteManyArgs>(args?: SelectSubset<T, ClassDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Classes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Classes
     * const class = await prisma.class.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClassUpdateManyArgs>(args: SelectSubset<T, ClassUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Classes and returns the data updated in the database.
     * @param {ClassUpdateManyAndReturnArgs} args - Arguments to update many Classes.
     * @example
     * // Update many Classes
     * const class = await prisma.class.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Classes and only return the `id`
     * const classWithIdOnly = await prisma.class.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ClassUpdateManyAndReturnArgs>(args: SelectSubset<T, ClassUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Class.
     * @param {ClassUpsertArgs} args - Arguments to update or create a Class.
     * @example
     * // Update or create a Class
     * const class = await prisma.class.upsert({
     *   create: {
     *     // ... data to create a Class
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Class we want to update
     *   }
     * })
     */
    upsert<T extends ClassUpsertArgs>(args: SelectSubset<T, ClassUpsertArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Classes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassCountArgs} args - Arguments to filter Classes to count.
     * @example
     * // Count the number of Classes
     * const count = await prisma.class.count({
     *   where: {
     *     // ... the filter for the Classes we want to count
     *   }
     * })
    **/
    count<T extends ClassCountArgs>(
      args?: Subset<T, ClassCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClassCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Class.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClassAggregateArgs>(args: Subset<T, ClassAggregateArgs>): Prisma.PrismaPromise<GetClassAggregateType<T>>

    /**
     * Group by Class.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClassGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClassGroupByArgs['orderBy'] }
        : { orderBy?: ClassGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClassGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClassGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Class model
   */
  readonly fields: ClassFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Class.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClassClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    rooms<T extends Class$roomsArgs<ExtArgs> = {}>(args?: Subset<T, Class$roomsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Class model
   */
  interface ClassFieldRefs {
    readonly id: FieldRef<"Class", 'Int'>
    readonly className: FieldRef<"Class", 'String'>
    readonly isEnabled: FieldRef<"Class", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Class findUnique
   */
  export type ClassFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    /**
     * Filter, which Class to fetch.
     */
    where: ClassWhereUniqueInput
  }

  /**
   * Class findUniqueOrThrow
   */
  export type ClassFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    /**
     * Filter, which Class to fetch.
     */
    where: ClassWhereUniqueInput
  }

  /**
   * Class findFirst
   */
  export type ClassFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    /**
     * Filter, which Class to fetch.
     */
    where?: ClassWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Classes to fetch.
     */
    orderBy?: ClassOrderByWithRelationInput | ClassOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Classes.
     */
    cursor?: ClassWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Classes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Classes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Classes.
     */
    distinct?: ClassScalarFieldEnum | ClassScalarFieldEnum[]
  }

  /**
   * Class findFirstOrThrow
   */
  export type ClassFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    /**
     * Filter, which Class to fetch.
     */
    where?: ClassWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Classes to fetch.
     */
    orderBy?: ClassOrderByWithRelationInput | ClassOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Classes.
     */
    cursor?: ClassWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Classes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Classes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Classes.
     */
    distinct?: ClassScalarFieldEnum | ClassScalarFieldEnum[]
  }

  /**
   * Class findMany
   */
  export type ClassFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    /**
     * Filter, which Classes to fetch.
     */
    where?: ClassWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Classes to fetch.
     */
    orderBy?: ClassOrderByWithRelationInput | ClassOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Classes.
     */
    cursor?: ClassWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Classes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Classes.
     */
    skip?: number
    distinct?: ClassScalarFieldEnum | ClassScalarFieldEnum[]
  }

  /**
   * Class create
   */
  export type ClassCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    /**
     * The data needed to create a Class.
     */
    data: XOR<ClassCreateInput, ClassUncheckedCreateInput>
  }

  /**
   * Class createMany
   */
  export type ClassCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Classes.
     */
    data: ClassCreateManyInput | ClassCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Class createManyAndReturn
   */
  export type ClassCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * The data used to create many Classes.
     */
    data: ClassCreateManyInput | ClassCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Class update
   */
  export type ClassUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    /**
     * The data needed to update a Class.
     */
    data: XOR<ClassUpdateInput, ClassUncheckedUpdateInput>
    /**
     * Choose, which Class to update.
     */
    where: ClassWhereUniqueInput
  }

  /**
   * Class updateMany
   */
  export type ClassUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Classes.
     */
    data: XOR<ClassUpdateManyMutationInput, ClassUncheckedUpdateManyInput>
    /**
     * Filter which Classes to update
     */
    where?: ClassWhereInput
    /**
     * Limit how many Classes to update.
     */
    limit?: number
  }

  /**
   * Class updateManyAndReturn
   */
  export type ClassUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * The data used to update Classes.
     */
    data: XOR<ClassUpdateManyMutationInput, ClassUncheckedUpdateManyInput>
    /**
     * Filter which Classes to update
     */
    where?: ClassWhereInput
    /**
     * Limit how many Classes to update.
     */
    limit?: number
  }

  /**
   * Class upsert
   */
  export type ClassUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    /**
     * The filter to search for the Class to update in case it exists.
     */
    where: ClassWhereUniqueInput
    /**
     * In case the Class found by the `where` argument doesn't exist, create a new Class with this data.
     */
    create: XOR<ClassCreateInput, ClassUncheckedCreateInput>
    /**
     * In case the Class was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClassUpdateInput, ClassUncheckedUpdateInput>
  }

  /**
   * Class delete
   */
  export type ClassDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    /**
     * Filter which Class to delete.
     */
    where: ClassWhereUniqueInput
  }

  /**
   * Class deleteMany
   */
  export type ClassDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Classes to delete
     */
    where?: ClassWhereInput
    /**
     * Limit how many Classes to delete.
     */
    limit?: number
  }

  /**
   * Class.rooms
   */
  export type Class$roomsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Room
     */
    omit?: RoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInclude<ExtArgs> | null
    where?: RoomWhereInput
    orderBy?: RoomOrderByWithRelationInput | RoomOrderByWithRelationInput[]
    cursor?: RoomWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RoomScalarFieldEnum | RoomScalarFieldEnum[]
  }

  /**
   * Class without action
   */
  export type ClassDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
  }


  /**
   * Model Department
   */

  export type AggregateDepartment = {
    _count: DepartmentCountAggregateOutputType | null
    _avg: DepartmentAvgAggregateOutputType | null
    _sum: DepartmentSumAggregateOutputType | null
    _min: DepartmentMinAggregateOutputType | null
    _max: DepartmentMaxAggregateOutputType | null
  }

  export type DepartmentAvgAggregateOutputType = {
    id: number | null
  }

  export type DepartmentSumAggregateOutputType = {
    id: number | null
  }

  export type DepartmentMinAggregateOutputType = {
    id: number | null
    departmentName: string | null
    isEnabled: boolean | null
  }

  export type DepartmentMaxAggregateOutputType = {
    id: number | null
    departmentName: string | null
    isEnabled: boolean | null
  }

  export type DepartmentCountAggregateOutputType = {
    id: number
    departmentName: number
    isEnabled: number
    _all: number
  }


  export type DepartmentAvgAggregateInputType = {
    id?: true
  }

  export type DepartmentSumAggregateInputType = {
    id?: true
  }

  export type DepartmentMinAggregateInputType = {
    id?: true
    departmentName?: true
    isEnabled?: true
  }

  export type DepartmentMaxAggregateInputType = {
    id?: true
    departmentName?: true
    isEnabled?: true
  }

  export type DepartmentCountAggregateInputType = {
    id?: true
    departmentName?: true
    isEnabled?: true
    _all?: true
  }

  export type DepartmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Department to aggregate.
     */
    where?: DepartmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Departments to fetch.
     */
    orderBy?: DepartmentOrderByWithRelationInput | DepartmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DepartmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Departments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Departments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Departments
    **/
    _count?: true | DepartmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DepartmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DepartmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DepartmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DepartmentMaxAggregateInputType
  }

  export type GetDepartmentAggregateType<T extends DepartmentAggregateArgs> = {
        [P in keyof T & keyof AggregateDepartment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDepartment[P]>
      : GetScalarType<T[P], AggregateDepartment[P]>
  }




  export type DepartmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DepartmentWhereInput
    orderBy?: DepartmentOrderByWithAggregationInput | DepartmentOrderByWithAggregationInput[]
    by: DepartmentScalarFieldEnum[] | DepartmentScalarFieldEnum
    having?: DepartmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DepartmentCountAggregateInputType | true
    _avg?: DepartmentAvgAggregateInputType
    _sum?: DepartmentSumAggregateInputType
    _min?: DepartmentMinAggregateInputType
    _max?: DepartmentMaxAggregateInputType
  }

  export type DepartmentGroupByOutputType = {
    id: number
    departmentName: string
    isEnabled: boolean
    _count: DepartmentCountAggregateOutputType | null
    _avg: DepartmentAvgAggregateOutputType | null
    _sum: DepartmentSumAggregateOutputType | null
    _min: DepartmentMinAggregateOutputType | null
    _max: DepartmentMaxAggregateOutputType | null
  }

  type GetDepartmentGroupByPayload<T extends DepartmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DepartmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DepartmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DepartmentGroupByOutputType[P]>
            : GetScalarType<T[P], DepartmentGroupByOutputType[P]>
        }
      >
    >


  export type DepartmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    departmentName?: boolean
    isEnabled?: boolean
    units?: boolean | Department$unitsArgs<ExtArgs>
    _count?: boolean | DepartmentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["department"]>

  export type DepartmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    departmentName?: boolean
    isEnabled?: boolean
  }, ExtArgs["result"]["department"]>

  export type DepartmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    departmentName?: boolean
    isEnabled?: boolean
  }, ExtArgs["result"]["department"]>

  export type DepartmentSelectScalar = {
    id?: boolean
    departmentName?: boolean
    isEnabled?: boolean
  }

  export type DepartmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "departmentName" | "isEnabled", ExtArgs["result"]["department"]>
  export type DepartmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    units?: boolean | Department$unitsArgs<ExtArgs>
    _count?: boolean | DepartmentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DepartmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type DepartmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $DepartmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Department"
    objects: {
      units: Prisma.$UnitPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      departmentName: string
      isEnabled: boolean
    }, ExtArgs["result"]["department"]>
    composites: {}
  }

  type DepartmentGetPayload<S extends boolean | null | undefined | DepartmentDefaultArgs> = $Result.GetResult<Prisma.$DepartmentPayload, S>

  type DepartmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DepartmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DepartmentCountAggregateInputType | true
    }

  export interface DepartmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Department'], meta: { name: 'Department' } }
    /**
     * Find zero or one Department that matches the filter.
     * @param {DepartmentFindUniqueArgs} args - Arguments to find a Department
     * @example
     * // Get one Department
     * const department = await prisma.department.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DepartmentFindUniqueArgs>(args: SelectSubset<T, DepartmentFindUniqueArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Department that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DepartmentFindUniqueOrThrowArgs} args - Arguments to find a Department
     * @example
     * // Get one Department
     * const department = await prisma.department.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DepartmentFindUniqueOrThrowArgs>(args: SelectSubset<T, DepartmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Department that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentFindFirstArgs} args - Arguments to find a Department
     * @example
     * // Get one Department
     * const department = await prisma.department.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DepartmentFindFirstArgs>(args?: SelectSubset<T, DepartmentFindFirstArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Department that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentFindFirstOrThrowArgs} args - Arguments to find a Department
     * @example
     * // Get one Department
     * const department = await prisma.department.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DepartmentFindFirstOrThrowArgs>(args?: SelectSubset<T, DepartmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Departments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Departments
     * const departments = await prisma.department.findMany()
     * 
     * // Get first 10 Departments
     * const departments = await prisma.department.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const departmentWithIdOnly = await prisma.department.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DepartmentFindManyArgs>(args?: SelectSubset<T, DepartmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Department.
     * @param {DepartmentCreateArgs} args - Arguments to create a Department.
     * @example
     * // Create one Department
     * const Department = await prisma.department.create({
     *   data: {
     *     // ... data to create a Department
     *   }
     * })
     * 
     */
    create<T extends DepartmentCreateArgs>(args: SelectSubset<T, DepartmentCreateArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Departments.
     * @param {DepartmentCreateManyArgs} args - Arguments to create many Departments.
     * @example
     * // Create many Departments
     * const department = await prisma.department.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DepartmentCreateManyArgs>(args?: SelectSubset<T, DepartmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Departments and returns the data saved in the database.
     * @param {DepartmentCreateManyAndReturnArgs} args - Arguments to create many Departments.
     * @example
     * // Create many Departments
     * const department = await prisma.department.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Departments and only return the `id`
     * const departmentWithIdOnly = await prisma.department.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DepartmentCreateManyAndReturnArgs>(args?: SelectSubset<T, DepartmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Department.
     * @param {DepartmentDeleteArgs} args - Arguments to delete one Department.
     * @example
     * // Delete one Department
     * const Department = await prisma.department.delete({
     *   where: {
     *     // ... filter to delete one Department
     *   }
     * })
     * 
     */
    delete<T extends DepartmentDeleteArgs>(args: SelectSubset<T, DepartmentDeleteArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Department.
     * @param {DepartmentUpdateArgs} args - Arguments to update one Department.
     * @example
     * // Update one Department
     * const department = await prisma.department.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DepartmentUpdateArgs>(args: SelectSubset<T, DepartmentUpdateArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Departments.
     * @param {DepartmentDeleteManyArgs} args - Arguments to filter Departments to delete.
     * @example
     * // Delete a few Departments
     * const { count } = await prisma.department.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DepartmentDeleteManyArgs>(args?: SelectSubset<T, DepartmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Departments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Departments
     * const department = await prisma.department.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DepartmentUpdateManyArgs>(args: SelectSubset<T, DepartmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Departments and returns the data updated in the database.
     * @param {DepartmentUpdateManyAndReturnArgs} args - Arguments to update many Departments.
     * @example
     * // Update many Departments
     * const department = await prisma.department.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Departments and only return the `id`
     * const departmentWithIdOnly = await prisma.department.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DepartmentUpdateManyAndReturnArgs>(args: SelectSubset<T, DepartmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Department.
     * @param {DepartmentUpsertArgs} args - Arguments to update or create a Department.
     * @example
     * // Update or create a Department
     * const department = await prisma.department.upsert({
     *   create: {
     *     // ... data to create a Department
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Department we want to update
     *   }
     * })
     */
    upsert<T extends DepartmentUpsertArgs>(args: SelectSubset<T, DepartmentUpsertArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Departments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentCountArgs} args - Arguments to filter Departments to count.
     * @example
     * // Count the number of Departments
     * const count = await prisma.department.count({
     *   where: {
     *     // ... the filter for the Departments we want to count
     *   }
     * })
    **/
    count<T extends DepartmentCountArgs>(
      args?: Subset<T, DepartmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DepartmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Department.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DepartmentAggregateArgs>(args: Subset<T, DepartmentAggregateArgs>): Prisma.PrismaPromise<GetDepartmentAggregateType<T>>

    /**
     * Group by Department.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DepartmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DepartmentGroupByArgs['orderBy'] }
        : { orderBy?: DepartmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DepartmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDepartmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Department model
   */
  readonly fields: DepartmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Department.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DepartmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    units<T extends Department$unitsArgs<ExtArgs> = {}>(args?: Subset<T, Department$unitsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Department model
   */
  interface DepartmentFieldRefs {
    readonly id: FieldRef<"Department", 'Int'>
    readonly departmentName: FieldRef<"Department", 'String'>
    readonly isEnabled: FieldRef<"Department", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Department findUnique
   */
  export type DepartmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter, which Department to fetch.
     */
    where: DepartmentWhereUniqueInput
  }

  /**
   * Department findUniqueOrThrow
   */
  export type DepartmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter, which Department to fetch.
     */
    where: DepartmentWhereUniqueInput
  }

  /**
   * Department findFirst
   */
  export type DepartmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter, which Department to fetch.
     */
    where?: DepartmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Departments to fetch.
     */
    orderBy?: DepartmentOrderByWithRelationInput | DepartmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Departments.
     */
    cursor?: DepartmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Departments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Departments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Departments.
     */
    distinct?: DepartmentScalarFieldEnum | DepartmentScalarFieldEnum[]
  }

  /**
   * Department findFirstOrThrow
   */
  export type DepartmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter, which Department to fetch.
     */
    where?: DepartmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Departments to fetch.
     */
    orderBy?: DepartmentOrderByWithRelationInput | DepartmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Departments.
     */
    cursor?: DepartmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Departments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Departments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Departments.
     */
    distinct?: DepartmentScalarFieldEnum | DepartmentScalarFieldEnum[]
  }

  /**
   * Department findMany
   */
  export type DepartmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter, which Departments to fetch.
     */
    where?: DepartmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Departments to fetch.
     */
    orderBy?: DepartmentOrderByWithRelationInput | DepartmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Departments.
     */
    cursor?: DepartmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Departments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Departments.
     */
    skip?: number
    distinct?: DepartmentScalarFieldEnum | DepartmentScalarFieldEnum[]
  }

  /**
   * Department create
   */
  export type DepartmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * The data needed to create a Department.
     */
    data: XOR<DepartmentCreateInput, DepartmentUncheckedCreateInput>
  }

  /**
   * Department createMany
   */
  export type DepartmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Departments.
     */
    data: DepartmentCreateManyInput | DepartmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Department createManyAndReturn
   */
  export type DepartmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * The data used to create many Departments.
     */
    data: DepartmentCreateManyInput | DepartmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Department update
   */
  export type DepartmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * The data needed to update a Department.
     */
    data: XOR<DepartmentUpdateInput, DepartmentUncheckedUpdateInput>
    /**
     * Choose, which Department to update.
     */
    where: DepartmentWhereUniqueInput
  }

  /**
   * Department updateMany
   */
  export type DepartmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Departments.
     */
    data: XOR<DepartmentUpdateManyMutationInput, DepartmentUncheckedUpdateManyInput>
    /**
     * Filter which Departments to update
     */
    where?: DepartmentWhereInput
    /**
     * Limit how many Departments to update.
     */
    limit?: number
  }

  /**
   * Department updateManyAndReturn
   */
  export type DepartmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * The data used to update Departments.
     */
    data: XOR<DepartmentUpdateManyMutationInput, DepartmentUncheckedUpdateManyInput>
    /**
     * Filter which Departments to update
     */
    where?: DepartmentWhereInput
    /**
     * Limit how many Departments to update.
     */
    limit?: number
  }

  /**
   * Department upsert
   */
  export type DepartmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * The filter to search for the Department to update in case it exists.
     */
    where: DepartmentWhereUniqueInput
    /**
     * In case the Department found by the `where` argument doesn't exist, create a new Department with this data.
     */
    create: XOR<DepartmentCreateInput, DepartmentUncheckedCreateInput>
    /**
     * In case the Department was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DepartmentUpdateInput, DepartmentUncheckedUpdateInput>
  }

  /**
   * Department delete
   */
  export type DepartmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter which Department to delete.
     */
    where: DepartmentWhereUniqueInput
  }

  /**
   * Department deleteMany
   */
  export type DepartmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Departments to delete
     */
    where?: DepartmentWhereInput
    /**
     * Limit how many Departments to delete.
     */
    limit?: number
  }

  /**
   * Department.units
   */
  export type Department$unitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    where?: UnitWhereInput
    orderBy?: UnitOrderByWithRelationInput | UnitOrderByWithRelationInput[]
    cursor?: UnitWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UnitScalarFieldEnum | UnitScalarFieldEnum[]
  }

  /**
   * Department without action
   */
  export type DepartmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
  }


  /**
   * Model Product
   */

  export type AggregateProduct = {
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  export type ProductAvgAggregateOutputType = {
    id: number | null
  }

  export type ProductSumAggregateOutputType = {
    id: number | null
  }

  export type ProductMinAggregateOutputType = {
    id: number | null
    productName: string | null
    isEnabled: boolean | null
  }

  export type ProductMaxAggregateOutputType = {
    id: number | null
    productName: string | null
    isEnabled: boolean | null
  }

  export type ProductCountAggregateOutputType = {
    id: number
    productName: number
    isEnabled: number
    _all: number
  }


  export type ProductAvgAggregateInputType = {
    id?: true
  }

  export type ProductSumAggregateInputType = {
    id?: true
  }

  export type ProductMinAggregateInputType = {
    id?: true
    productName?: true
    isEnabled?: true
  }

  export type ProductMaxAggregateInputType = {
    id?: true
    productName?: true
    isEnabled?: true
  }

  export type ProductCountAggregateInputType = {
    id?: true
    productName?: true
    isEnabled?: true
    _all?: true
  }

  export type ProductAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Product to aggregate.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Products
    **/
    _count?: true | ProductCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductMaxAggregateInputType
  }

  export type GetProductAggregateType<T extends ProductAggregateArgs> = {
        [P in keyof T & keyof AggregateProduct]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProduct[P]>
      : GetScalarType<T[P], AggregateProduct[P]>
  }




  export type ProductGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithAggregationInput | ProductOrderByWithAggregationInput[]
    by: ProductScalarFieldEnum[] | ProductScalarFieldEnum
    having?: ProductScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductCountAggregateInputType | true
    _avg?: ProductAvgAggregateInputType
    _sum?: ProductSumAggregateInputType
    _min?: ProductMinAggregateInputType
    _max?: ProductMaxAggregateInputType
  }

  export type ProductGroupByOutputType = {
    id: number
    productName: string
    isEnabled: boolean
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  type GetProductGroupByPayload<T extends ProductGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductGroupByOutputType[P]>
            : GetScalarType<T[P], ProductGroupByOutputType[P]>
        }
      >
    >


  export type ProductSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productName?: boolean
    isEnabled?: boolean
    stockDetails?: boolean | Product$stockDetailsArgs<ExtArgs>
    _count?: boolean | ProductCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["product"]>

  export type ProductSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productName?: boolean
    isEnabled?: boolean
  }, ExtArgs["result"]["product"]>

  export type ProductSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productName?: boolean
    isEnabled?: boolean
  }, ExtArgs["result"]["product"]>

  export type ProductSelectScalar = {
    id?: boolean
    productName?: boolean
    isEnabled?: boolean
  }

  export type ProductOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "productName" | "isEnabled", ExtArgs["result"]["product"]>
  export type ProductInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    stockDetails?: boolean | Product$stockDetailsArgs<ExtArgs>
    _count?: boolean | ProductCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProductIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ProductIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ProductPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Product"
    objects: {
      stockDetails: Prisma.$StockDetailPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      productName: string
      isEnabled: boolean
    }, ExtArgs["result"]["product"]>
    composites: {}
  }

  type ProductGetPayload<S extends boolean | null | undefined | ProductDefaultArgs> = $Result.GetResult<Prisma.$ProductPayload, S>

  type ProductCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProductFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductCountAggregateInputType | true
    }

  export interface ProductDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Product'], meta: { name: 'Product' } }
    /**
     * Find zero or one Product that matches the filter.
     * @param {ProductFindUniqueArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductFindUniqueArgs>(args: SelectSubset<T, ProductFindUniqueArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Product that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductFindUniqueOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Product that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductFindFirstArgs>(args?: SelectSubset<T, ProductFindFirstArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Product that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Products that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Products
     * const products = await prisma.product.findMany()
     * 
     * // Get first 10 Products
     * const products = await prisma.product.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productWithIdOnly = await prisma.product.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductFindManyArgs>(args?: SelectSubset<T, ProductFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Product.
     * @param {ProductCreateArgs} args - Arguments to create a Product.
     * @example
     * // Create one Product
     * const Product = await prisma.product.create({
     *   data: {
     *     // ... data to create a Product
     *   }
     * })
     * 
     */
    create<T extends ProductCreateArgs>(args: SelectSubset<T, ProductCreateArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Products.
     * @param {ProductCreateManyArgs} args - Arguments to create many Products.
     * @example
     * // Create many Products
     * const product = await prisma.product.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductCreateManyArgs>(args?: SelectSubset<T, ProductCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Products and returns the data saved in the database.
     * @param {ProductCreateManyAndReturnArgs} args - Arguments to create many Products.
     * @example
     * // Create many Products
     * const product = await prisma.product.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Products and only return the `id`
     * const productWithIdOnly = await prisma.product.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Product.
     * @param {ProductDeleteArgs} args - Arguments to delete one Product.
     * @example
     * // Delete one Product
     * const Product = await prisma.product.delete({
     *   where: {
     *     // ... filter to delete one Product
     *   }
     * })
     * 
     */
    delete<T extends ProductDeleteArgs>(args: SelectSubset<T, ProductDeleteArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Product.
     * @param {ProductUpdateArgs} args - Arguments to update one Product.
     * @example
     * // Update one Product
     * const product = await prisma.product.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductUpdateArgs>(args: SelectSubset<T, ProductUpdateArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Products.
     * @param {ProductDeleteManyArgs} args - Arguments to filter Products to delete.
     * @example
     * // Delete a few Products
     * const { count } = await prisma.product.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductDeleteManyArgs>(args?: SelectSubset<T, ProductDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Products
     * const product = await prisma.product.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductUpdateManyArgs>(args: SelectSubset<T, ProductUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products and returns the data updated in the database.
     * @param {ProductUpdateManyAndReturnArgs} args - Arguments to update many Products.
     * @example
     * // Update many Products
     * const product = await prisma.product.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Products and only return the `id`
     * const productWithIdOnly = await prisma.product.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProductUpdateManyAndReturnArgs>(args: SelectSubset<T, ProductUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Product.
     * @param {ProductUpsertArgs} args - Arguments to update or create a Product.
     * @example
     * // Update or create a Product
     * const product = await prisma.product.upsert({
     *   create: {
     *     // ... data to create a Product
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Product we want to update
     *   }
     * })
     */
    upsert<T extends ProductUpsertArgs>(args: SelectSubset<T, ProductUpsertArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCountArgs} args - Arguments to filter Products to count.
     * @example
     * // Count the number of Products
     * const count = await prisma.product.count({
     *   where: {
     *     // ... the filter for the Products we want to count
     *   }
     * })
    **/
    count<T extends ProductCountArgs>(
      args?: Subset<T, ProductCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductAggregateArgs>(args: Subset<T, ProductAggregateArgs>): Prisma.PrismaPromise<GetProductAggregateType<T>>

    /**
     * Group by Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductGroupByArgs['orderBy'] }
        : { orderBy?: ProductGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Product model
   */
  readonly fields: ProductFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Product.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    stockDetails<T extends Product$stockDetailsArgs<ExtArgs> = {}>(args?: Subset<T, Product$stockDetailsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockDetailPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Product model
   */
  interface ProductFieldRefs {
    readonly id: FieldRef<"Product", 'Int'>
    readonly productName: FieldRef<"Product", 'String'>
    readonly isEnabled: FieldRef<"Product", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Product findUnique
   */
  export type ProductFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product findUniqueOrThrow
   */
  export type ProductFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product findFirst
   */
  export type ProductFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product findFirstOrThrow
   */
  export type ProductFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product findMany
   */
  export type ProductFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Products to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product create
   */
  export type ProductCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The data needed to create a Product.
     */
    data: XOR<ProductCreateInput, ProductUncheckedCreateInput>
  }

  /**
   * Product createMany
   */
  export type ProductCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Products.
     */
    data: ProductCreateManyInput | ProductCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Product createManyAndReturn
   */
  export type ProductCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * The data used to create many Products.
     */
    data: ProductCreateManyInput | ProductCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Product update
   */
  export type ProductUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The data needed to update a Product.
     */
    data: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
    /**
     * Choose, which Product to update.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product updateMany
   */
  export type ProductUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Products.
     */
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyInput>
    /**
     * Filter which Products to update
     */
    where?: ProductWhereInput
    /**
     * Limit how many Products to update.
     */
    limit?: number
  }

  /**
   * Product updateManyAndReturn
   */
  export type ProductUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * The data used to update Products.
     */
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyInput>
    /**
     * Filter which Products to update
     */
    where?: ProductWhereInput
    /**
     * Limit how many Products to update.
     */
    limit?: number
  }

  /**
   * Product upsert
   */
  export type ProductUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The filter to search for the Product to update in case it exists.
     */
    where: ProductWhereUniqueInput
    /**
     * In case the Product found by the `where` argument doesn't exist, create a new Product with this data.
     */
    create: XOR<ProductCreateInput, ProductUncheckedCreateInput>
    /**
     * In case the Product was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
  }

  /**
   * Product delete
   */
  export type ProductDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter which Product to delete.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product deleteMany
   */
  export type ProductDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Products to delete
     */
    where?: ProductWhereInput
    /**
     * Limit how many Products to delete.
     */
    limit?: number
  }

  /**
   * Product.stockDetails
   */
  export type Product$stockDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockDetail
     */
    select?: StockDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockDetail
     */
    omit?: StockDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockDetailInclude<ExtArgs> | null
    where?: StockDetailWhereInput
    orderBy?: StockDetailOrderByWithRelationInput | StockDetailOrderByWithRelationInput[]
    cursor?: StockDetailWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StockDetailScalarFieldEnum | StockDetailScalarFieldEnum[]
  }

  /**
   * Product without action
   */
  export type ProductDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
  }


  /**
   * Model ServiceReceipt
   */

  export type AggregateServiceReceipt = {
    _count: ServiceReceiptCountAggregateOutputType | null
    _min: ServiceReceiptMinAggregateOutputType | null
    _max: ServiceReceiptMaxAggregateOutputType | null
  }

  export type ServiceReceiptMinAggregateOutputType = {
    id: string | null
    receiptAt: Date | null
  }

  export type ServiceReceiptMaxAggregateOutputType = {
    id: string | null
    receiptAt: Date | null
  }

  export type ServiceReceiptCountAggregateOutputType = {
    id: number
    receiptAt: number
    _all: number
  }


  export type ServiceReceiptMinAggregateInputType = {
    id?: true
    receiptAt?: true
  }

  export type ServiceReceiptMaxAggregateInputType = {
    id?: true
    receiptAt?: true
  }

  export type ServiceReceiptCountAggregateInputType = {
    id?: true
    receiptAt?: true
    _all?: true
  }

  export type ServiceReceiptAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServiceReceipt to aggregate.
     */
    where?: ServiceReceiptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceReceipts to fetch.
     */
    orderBy?: ServiceReceiptOrderByWithRelationInput | ServiceReceiptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ServiceReceiptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceReceipts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceReceipts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ServiceReceipts
    **/
    _count?: true | ServiceReceiptCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServiceReceiptMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServiceReceiptMaxAggregateInputType
  }

  export type GetServiceReceiptAggregateType<T extends ServiceReceiptAggregateArgs> = {
        [P in keyof T & keyof AggregateServiceReceipt]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateServiceReceipt[P]>
      : GetScalarType<T[P], AggregateServiceReceipt[P]>
  }




  export type ServiceReceiptGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceReceiptWhereInput
    orderBy?: ServiceReceiptOrderByWithAggregationInput | ServiceReceiptOrderByWithAggregationInput[]
    by: ServiceReceiptScalarFieldEnum[] | ServiceReceiptScalarFieldEnum
    having?: ServiceReceiptScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServiceReceiptCountAggregateInputType | true
    _min?: ServiceReceiptMinAggregateInputType
    _max?: ServiceReceiptMaxAggregateInputType
  }

  export type ServiceReceiptGroupByOutputType = {
    id: string
    receiptAt: Date
    _count: ServiceReceiptCountAggregateOutputType | null
    _min: ServiceReceiptMinAggregateOutputType | null
    _max: ServiceReceiptMaxAggregateOutputType | null
  }

  type GetServiceReceiptGroupByPayload<T extends ServiceReceiptGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ServiceReceiptGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServiceReceiptGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServiceReceiptGroupByOutputType[P]>
            : GetScalarType<T[P], ServiceReceiptGroupByOutputType[P]>
        }
      >
    >


  export type ServiceReceiptSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    receiptAt?: boolean
    stockDetails?: boolean | ServiceReceipt$stockDetailsArgs<ExtArgs>
    _count?: boolean | ServiceReceiptCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["serviceReceipt"]>

  export type ServiceReceiptSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    receiptAt?: boolean
  }, ExtArgs["result"]["serviceReceipt"]>

  export type ServiceReceiptSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    receiptAt?: boolean
  }, ExtArgs["result"]["serviceReceipt"]>

  export type ServiceReceiptSelectScalar = {
    id?: boolean
    receiptAt?: boolean
  }

  export type ServiceReceiptOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "receiptAt", ExtArgs["result"]["serviceReceipt"]>
  export type ServiceReceiptInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    stockDetails?: boolean | ServiceReceipt$stockDetailsArgs<ExtArgs>
    _count?: boolean | ServiceReceiptCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ServiceReceiptIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ServiceReceiptIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ServiceReceiptPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ServiceReceipt"
    objects: {
      stockDetails: Prisma.$StockDetailPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      receiptAt: Date
    }, ExtArgs["result"]["serviceReceipt"]>
    composites: {}
  }

  type ServiceReceiptGetPayload<S extends boolean | null | undefined | ServiceReceiptDefaultArgs> = $Result.GetResult<Prisma.$ServiceReceiptPayload, S>

  type ServiceReceiptCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ServiceReceiptFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ServiceReceiptCountAggregateInputType | true
    }

  export interface ServiceReceiptDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ServiceReceipt'], meta: { name: 'ServiceReceipt' } }
    /**
     * Find zero or one ServiceReceipt that matches the filter.
     * @param {ServiceReceiptFindUniqueArgs} args - Arguments to find a ServiceReceipt
     * @example
     * // Get one ServiceReceipt
     * const serviceReceipt = await prisma.serviceReceipt.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ServiceReceiptFindUniqueArgs>(args: SelectSubset<T, ServiceReceiptFindUniqueArgs<ExtArgs>>): Prisma__ServiceReceiptClient<$Result.GetResult<Prisma.$ServiceReceiptPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ServiceReceipt that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ServiceReceiptFindUniqueOrThrowArgs} args - Arguments to find a ServiceReceipt
     * @example
     * // Get one ServiceReceipt
     * const serviceReceipt = await prisma.serviceReceipt.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ServiceReceiptFindUniqueOrThrowArgs>(args: SelectSubset<T, ServiceReceiptFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ServiceReceiptClient<$Result.GetResult<Prisma.$ServiceReceiptPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ServiceReceipt that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceReceiptFindFirstArgs} args - Arguments to find a ServiceReceipt
     * @example
     * // Get one ServiceReceipt
     * const serviceReceipt = await prisma.serviceReceipt.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ServiceReceiptFindFirstArgs>(args?: SelectSubset<T, ServiceReceiptFindFirstArgs<ExtArgs>>): Prisma__ServiceReceiptClient<$Result.GetResult<Prisma.$ServiceReceiptPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ServiceReceipt that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceReceiptFindFirstOrThrowArgs} args - Arguments to find a ServiceReceipt
     * @example
     * // Get one ServiceReceipt
     * const serviceReceipt = await prisma.serviceReceipt.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ServiceReceiptFindFirstOrThrowArgs>(args?: SelectSubset<T, ServiceReceiptFindFirstOrThrowArgs<ExtArgs>>): Prisma__ServiceReceiptClient<$Result.GetResult<Prisma.$ServiceReceiptPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ServiceReceipts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceReceiptFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ServiceReceipts
     * const serviceReceipts = await prisma.serviceReceipt.findMany()
     * 
     * // Get first 10 ServiceReceipts
     * const serviceReceipts = await prisma.serviceReceipt.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const serviceReceiptWithIdOnly = await prisma.serviceReceipt.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ServiceReceiptFindManyArgs>(args?: SelectSubset<T, ServiceReceiptFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceReceiptPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ServiceReceipt.
     * @param {ServiceReceiptCreateArgs} args - Arguments to create a ServiceReceipt.
     * @example
     * // Create one ServiceReceipt
     * const ServiceReceipt = await prisma.serviceReceipt.create({
     *   data: {
     *     // ... data to create a ServiceReceipt
     *   }
     * })
     * 
     */
    create<T extends ServiceReceiptCreateArgs>(args: SelectSubset<T, ServiceReceiptCreateArgs<ExtArgs>>): Prisma__ServiceReceiptClient<$Result.GetResult<Prisma.$ServiceReceiptPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ServiceReceipts.
     * @param {ServiceReceiptCreateManyArgs} args - Arguments to create many ServiceReceipts.
     * @example
     * // Create many ServiceReceipts
     * const serviceReceipt = await prisma.serviceReceipt.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ServiceReceiptCreateManyArgs>(args?: SelectSubset<T, ServiceReceiptCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ServiceReceipts and returns the data saved in the database.
     * @param {ServiceReceiptCreateManyAndReturnArgs} args - Arguments to create many ServiceReceipts.
     * @example
     * // Create many ServiceReceipts
     * const serviceReceipt = await prisma.serviceReceipt.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ServiceReceipts and only return the `id`
     * const serviceReceiptWithIdOnly = await prisma.serviceReceipt.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ServiceReceiptCreateManyAndReturnArgs>(args?: SelectSubset<T, ServiceReceiptCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceReceiptPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ServiceReceipt.
     * @param {ServiceReceiptDeleteArgs} args - Arguments to delete one ServiceReceipt.
     * @example
     * // Delete one ServiceReceipt
     * const ServiceReceipt = await prisma.serviceReceipt.delete({
     *   where: {
     *     // ... filter to delete one ServiceReceipt
     *   }
     * })
     * 
     */
    delete<T extends ServiceReceiptDeleteArgs>(args: SelectSubset<T, ServiceReceiptDeleteArgs<ExtArgs>>): Prisma__ServiceReceiptClient<$Result.GetResult<Prisma.$ServiceReceiptPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ServiceReceipt.
     * @param {ServiceReceiptUpdateArgs} args - Arguments to update one ServiceReceipt.
     * @example
     * // Update one ServiceReceipt
     * const serviceReceipt = await prisma.serviceReceipt.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ServiceReceiptUpdateArgs>(args: SelectSubset<T, ServiceReceiptUpdateArgs<ExtArgs>>): Prisma__ServiceReceiptClient<$Result.GetResult<Prisma.$ServiceReceiptPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ServiceReceipts.
     * @param {ServiceReceiptDeleteManyArgs} args - Arguments to filter ServiceReceipts to delete.
     * @example
     * // Delete a few ServiceReceipts
     * const { count } = await prisma.serviceReceipt.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ServiceReceiptDeleteManyArgs>(args?: SelectSubset<T, ServiceReceiptDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ServiceReceipts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceReceiptUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ServiceReceipts
     * const serviceReceipt = await prisma.serviceReceipt.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ServiceReceiptUpdateManyArgs>(args: SelectSubset<T, ServiceReceiptUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ServiceReceipts and returns the data updated in the database.
     * @param {ServiceReceiptUpdateManyAndReturnArgs} args - Arguments to update many ServiceReceipts.
     * @example
     * // Update many ServiceReceipts
     * const serviceReceipt = await prisma.serviceReceipt.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ServiceReceipts and only return the `id`
     * const serviceReceiptWithIdOnly = await prisma.serviceReceipt.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ServiceReceiptUpdateManyAndReturnArgs>(args: SelectSubset<T, ServiceReceiptUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceReceiptPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ServiceReceipt.
     * @param {ServiceReceiptUpsertArgs} args - Arguments to update or create a ServiceReceipt.
     * @example
     * // Update or create a ServiceReceipt
     * const serviceReceipt = await prisma.serviceReceipt.upsert({
     *   create: {
     *     // ... data to create a ServiceReceipt
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ServiceReceipt we want to update
     *   }
     * })
     */
    upsert<T extends ServiceReceiptUpsertArgs>(args: SelectSubset<T, ServiceReceiptUpsertArgs<ExtArgs>>): Prisma__ServiceReceiptClient<$Result.GetResult<Prisma.$ServiceReceiptPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ServiceReceipts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceReceiptCountArgs} args - Arguments to filter ServiceReceipts to count.
     * @example
     * // Count the number of ServiceReceipts
     * const count = await prisma.serviceReceipt.count({
     *   where: {
     *     // ... the filter for the ServiceReceipts we want to count
     *   }
     * })
    **/
    count<T extends ServiceReceiptCountArgs>(
      args?: Subset<T, ServiceReceiptCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServiceReceiptCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ServiceReceipt.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceReceiptAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServiceReceiptAggregateArgs>(args: Subset<T, ServiceReceiptAggregateArgs>): Prisma.PrismaPromise<GetServiceReceiptAggregateType<T>>

    /**
     * Group by ServiceReceipt.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceReceiptGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ServiceReceiptGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServiceReceiptGroupByArgs['orderBy'] }
        : { orderBy?: ServiceReceiptGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ServiceReceiptGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServiceReceiptGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ServiceReceipt model
   */
  readonly fields: ServiceReceiptFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ServiceReceipt.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ServiceReceiptClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    stockDetails<T extends ServiceReceipt$stockDetailsArgs<ExtArgs> = {}>(args?: Subset<T, ServiceReceipt$stockDetailsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockDetailPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ServiceReceipt model
   */
  interface ServiceReceiptFieldRefs {
    readonly id: FieldRef<"ServiceReceipt", 'String'>
    readonly receiptAt: FieldRef<"ServiceReceipt", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ServiceReceipt findUnique
   */
  export type ServiceReceiptFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceReceipt
     */
    select?: ServiceReceiptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceReceipt
     */
    omit?: ServiceReceiptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceReceiptInclude<ExtArgs> | null
    /**
     * Filter, which ServiceReceipt to fetch.
     */
    where: ServiceReceiptWhereUniqueInput
  }

  /**
   * ServiceReceipt findUniqueOrThrow
   */
  export type ServiceReceiptFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceReceipt
     */
    select?: ServiceReceiptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceReceipt
     */
    omit?: ServiceReceiptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceReceiptInclude<ExtArgs> | null
    /**
     * Filter, which ServiceReceipt to fetch.
     */
    where: ServiceReceiptWhereUniqueInput
  }

  /**
   * ServiceReceipt findFirst
   */
  export type ServiceReceiptFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceReceipt
     */
    select?: ServiceReceiptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceReceipt
     */
    omit?: ServiceReceiptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceReceiptInclude<ExtArgs> | null
    /**
     * Filter, which ServiceReceipt to fetch.
     */
    where?: ServiceReceiptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceReceipts to fetch.
     */
    orderBy?: ServiceReceiptOrderByWithRelationInput | ServiceReceiptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServiceReceipts.
     */
    cursor?: ServiceReceiptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceReceipts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceReceipts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServiceReceipts.
     */
    distinct?: ServiceReceiptScalarFieldEnum | ServiceReceiptScalarFieldEnum[]
  }

  /**
   * ServiceReceipt findFirstOrThrow
   */
  export type ServiceReceiptFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceReceipt
     */
    select?: ServiceReceiptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceReceipt
     */
    omit?: ServiceReceiptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceReceiptInclude<ExtArgs> | null
    /**
     * Filter, which ServiceReceipt to fetch.
     */
    where?: ServiceReceiptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceReceipts to fetch.
     */
    orderBy?: ServiceReceiptOrderByWithRelationInput | ServiceReceiptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServiceReceipts.
     */
    cursor?: ServiceReceiptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceReceipts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceReceipts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServiceReceipts.
     */
    distinct?: ServiceReceiptScalarFieldEnum | ServiceReceiptScalarFieldEnum[]
  }

  /**
   * ServiceReceipt findMany
   */
  export type ServiceReceiptFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceReceipt
     */
    select?: ServiceReceiptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceReceipt
     */
    omit?: ServiceReceiptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceReceiptInclude<ExtArgs> | null
    /**
     * Filter, which ServiceReceipts to fetch.
     */
    where?: ServiceReceiptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceReceipts to fetch.
     */
    orderBy?: ServiceReceiptOrderByWithRelationInput | ServiceReceiptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ServiceReceipts.
     */
    cursor?: ServiceReceiptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceReceipts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceReceipts.
     */
    skip?: number
    distinct?: ServiceReceiptScalarFieldEnum | ServiceReceiptScalarFieldEnum[]
  }

  /**
   * ServiceReceipt create
   */
  export type ServiceReceiptCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceReceipt
     */
    select?: ServiceReceiptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceReceipt
     */
    omit?: ServiceReceiptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceReceiptInclude<ExtArgs> | null
    /**
     * The data needed to create a ServiceReceipt.
     */
    data: XOR<ServiceReceiptCreateInput, ServiceReceiptUncheckedCreateInput>
  }

  /**
   * ServiceReceipt createMany
   */
  export type ServiceReceiptCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ServiceReceipts.
     */
    data: ServiceReceiptCreateManyInput | ServiceReceiptCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ServiceReceipt createManyAndReturn
   */
  export type ServiceReceiptCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceReceipt
     */
    select?: ServiceReceiptSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceReceipt
     */
    omit?: ServiceReceiptOmit<ExtArgs> | null
    /**
     * The data used to create many ServiceReceipts.
     */
    data: ServiceReceiptCreateManyInput | ServiceReceiptCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ServiceReceipt update
   */
  export type ServiceReceiptUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceReceipt
     */
    select?: ServiceReceiptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceReceipt
     */
    omit?: ServiceReceiptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceReceiptInclude<ExtArgs> | null
    /**
     * The data needed to update a ServiceReceipt.
     */
    data: XOR<ServiceReceiptUpdateInput, ServiceReceiptUncheckedUpdateInput>
    /**
     * Choose, which ServiceReceipt to update.
     */
    where: ServiceReceiptWhereUniqueInput
  }

  /**
   * ServiceReceipt updateMany
   */
  export type ServiceReceiptUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ServiceReceipts.
     */
    data: XOR<ServiceReceiptUpdateManyMutationInput, ServiceReceiptUncheckedUpdateManyInput>
    /**
     * Filter which ServiceReceipts to update
     */
    where?: ServiceReceiptWhereInput
    /**
     * Limit how many ServiceReceipts to update.
     */
    limit?: number
  }

  /**
   * ServiceReceipt updateManyAndReturn
   */
  export type ServiceReceiptUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceReceipt
     */
    select?: ServiceReceiptSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceReceipt
     */
    omit?: ServiceReceiptOmit<ExtArgs> | null
    /**
     * The data used to update ServiceReceipts.
     */
    data: XOR<ServiceReceiptUpdateManyMutationInput, ServiceReceiptUncheckedUpdateManyInput>
    /**
     * Filter which ServiceReceipts to update
     */
    where?: ServiceReceiptWhereInput
    /**
     * Limit how many ServiceReceipts to update.
     */
    limit?: number
  }

  /**
   * ServiceReceipt upsert
   */
  export type ServiceReceiptUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceReceipt
     */
    select?: ServiceReceiptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceReceipt
     */
    omit?: ServiceReceiptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceReceiptInclude<ExtArgs> | null
    /**
     * The filter to search for the ServiceReceipt to update in case it exists.
     */
    where: ServiceReceiptWhereUniqueInput
    /**
     * In case the ServiceReceipt found by the `where` argument doesn't exist, create a new ServiceReceipt with this data.
     */
    create: XOR<ServiceReceiptCreateInput, ServiceReceiptUncheckedCreateInput>
    /**
     * In case the ServiceReceipt was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ServiceReceiptUpdateInput, ServiceReceiptUncheckedUpdateInput>
  }

  /**
   * ServiceReceipt delete
   */
  export type ServiceReceiptDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceReceipt
     */
    select?: ServiceReceiptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceReceipt
     */
    omit?: ServiceReceiptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceReceiptInclude<ExtArgs> | null
    /**
     * Filter which ServiceReceipt to delete.
     */
    where: ServiceReceiptWhereUniqueInput
  }

  /**
   * ServiceReceipt deleteMany
   */
  export type ServiceReceiptDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServiceReceipts to delete
     */
    where?: ServiceReceiptWhereInput
    /**
     * Limit how many ServiceReceipts to delete.
     */
    limit?: number
  }

  /**
   * ServiceReceipt.stockDetails
   */
  export type ServiceReceipt$stockDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockDetail
     */
    select?: StockDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockDetail
     */
    omit?: StockDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockDetailInclude<ExtArgs> | null
    where?: StockDetailWhereInput
    orderBy?: StockDetailOrderByWithRelationInput | StockDetailOrderByWithRelationInput[]
    cursor?: StockDetailWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StockDetailScalarFieldEnum | StockDetailScalarFieldEnum[]
  }

  /**
   * ServiceReceipt without action
   */
  export type ServiceReceiptDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceReceipt
     */
    select?: ServiceReceiptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceReceipt
     */
    omit?: ServiceReceiptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceReceiptInclude<ExtArgs> | null
  }


  /**
   * Model StockDetail
   */

  export type AggregateStockDetail = {
    _count: StockDetailCountAggregateOutputType | null
    _avg: StockDetailAvgAggregateOutputType | null
    _sum: StockDetailSumAggregateOutputType | null
    _min: StockDetailMinAggregateOutputType | null
    _max: StockDetailMaxAggregateOutputType | null
  }

  export type StockDetailAvgAggregateOutputType = {
    productId: number | null
    unitId: number | null
    sourceProductId: number | null
    netPrice: number | null
    discountPrice: number | null
    quantity: number | null
  }

  export type StockDetailSumAggregateOutputType = {
    productId: number | null
    unitId: number | null
    sourceProductId: number | null
    netPrice: number | null
    discountPrice: number | null
    quantity: number | null
  }

  export type StockDetailMinAggregateOutputType = {
    id: string | null
    productId: number | null
    unitId: number | null
    receiptId: string | null
    sourceProductId: number | null
    netPrice: number | null
    discountPrice: number | null
    quantity: number | null
    isEnabled: boolean | null
    expiredAt: Date | null
  }

  export type StockDetailMaxAggregateOutputType = {
    id: string | null
    productId: number | null
    unitId: number | null
    receiptId: string | null
    sourceProductId: number | null
    netPrice: number | null
    discountPrice: number | null
    quantity: number | null
    isEnabled: boolean | null
    expiredAt: Date | null
  }

  export type StockDetailCountAggregateOutputType = {
    id: number
    productId: number
    unitId: number
    receiptId: number
    sourceProductId: number
    netPrice: number
    discountPrice: number
    quantity: number
    isEnabled: number
    expiredAt: number
    _all: number
  }


  export type StockDetailAvgAggregateInputType = {
    productId?: true
    unitId?: true
    sourceProductId?: true
    netPrice?: true
    discountPrice?: true
    quantity?: true
  }

  export type StockDetailSumAggregateInputType = {
    productId?: true
    unitId?: true
    sourceProductId?: true
    netPrice?: true
    discountPrice?: true
    quantity?: true
  }

  export type StockDetailMinAggregateInputType = {
    id?: true
    productId?: true
    unitId?: true
    receiptId?: true
    sourceProductId?: true
    netPrice?: true
    discountPrice?: true
    quantity?: true
    isEnabled?: true
    expiredAt?: true
  }

  export type StockDetailMaxAggregateInputType = {
    id?: true
    productId?: true
    unitId?: true
    receiptId?: true
    sourceProductId?: true
    netPrice?: true
    discountPrice?: true
    quantity?: true
    isEnabled?: true
    expiredAt?: true
  }

  export type StockDetailCountAggregateInputType = {
    id?: true
    productId?: true
    unitId?: true
    receiptId?: true
    sourceProductId?: true
    netPrice?: true
    discountPrice?: true
    quantity?: true
    isEnabled?: true
    expiredAt?: true
    _all?: true
  }

  export type StockDetailAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StockDetail to aggregate.
     */
    where?: StockDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockDetails to fetch.
     */
    orderBy?: StockDetailOrderByWithRelationInput | StockDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StockDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StockDetails
    **/
    _count?: true | StockDetailCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StockDetailAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StockDetailSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StockDetailMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StockDetailMaxAggregateInputType
  }

  export type GetStockDetailAggregateType<T extends StockDetailAggregateArgs> = {
        [P in keyof T & keyof AggregateStockDetail]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStockDetail[P]>
      : GetScalarType<T[P], AggregateStockDetail[P]>
  }




  export type StockDetailGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StockDetailWhereInput
    orderBy?: StockDetailOrderByWithAggregationInput | StockDetailOrderByWithAggregationInput[]
    by: StockDetailScalarFieldEnum[] | StockDetailScalarFieldEnum
    having?: StockDetailScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StockDetailCountAggregateInputType | true
    _avg?: StockDetailAvgAggregateInputType
    _sum?: StockDetailSumAggregateInputType
    _min?: StockDetailMinAggregateInputType
    _max?: StockDetailMaxAggregateInputType
  }

  export type StockDetailGroupByOutputType = {
    id: string
    productId: number
    unitId: number
    receiptId: string
    sourceProductId: number | null
    netPrice: number | null
    discountPrice: number | null
    quantity: number
    isEnabled: boolean
    expiredAt: Date | null
    _count: StockDetailCountAggregateOutputType | null
    _avg: StockDetailAvgAggregateOutputType | null
    _sum: StockDetailSumAggregateOutputType | null
    _min: StockDetailMinAggregateOutputType | null
    _max: StockDetailMaxAggregateOutputType | null
  }

  type GetStockDetailGroupByPayload<T extends StockDetailGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StockDetailGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StockDetailGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StockDetailGroupByOutputType[P]>
            : GetScalarType<T[P], StockDetailGroupByOutputType[P]>
        }
      >
    >


  export type StockDetailSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    unitId?: boolean
    receiptId?: boolean
    sourceProductId?: boolean
    netPrice?: boolean
    discountPrice?: boolean
    quantity?: boolean
    isEnabled?: boolean
    expiredAt?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
    unit?: boolean | UnitDefaultArgs<ExtArgs>
    receipt?: boolean | ServiceReceiptDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["stockDetail"]>

  export type StockDetailSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    unitId?: boolean
    receiptId?: boolean
    sourceProductId?: boolean
    netPrice?: boolean
    discountPrice?: boolean
    quantity?: boolean
    isEnabled?: boolean
    expiredAt?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
    unit?: boolean | UnitDefaultArgs<ExtArgs>
    receipt?: boolean | ServiceReceiptDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["stockDetail"]>

  export type StockDetailSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    unitId?: boolean
    receiptId?: boolean
    sourceProductId?: boolean
    netPrice?: boolean
    discountPrice?: boolean
    quantity?: boolean
    isEnabled?: boolean
    expiredAt?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
    unit?: boolean | UnitDefaultArgs<ExtArgs>
    receipt?: boolean | ServiceReceiptDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["stockDetail"]>

  export type StockDetailSelectScalar = {
    id?: boolean
    productId?: boolean
    unitId?: boolean
    receiptId?: boolean
    sourceProductId?: boolean
    netPrice?: boolean
    discountPrice?: boolean
    quantity?: boolean
    isEnabled?: boolean
    expiredAt?: boolean
  }

  export type StockDetailOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "productId" | "unitId" | "receiptId" | "sourceProductId" | "netPrice" | "discountPrice" | "quantity" | "isEnabled" | "expiredAt", ExtArgs["result"]["stockDetail"]>
  export type StockDetailInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
    unit?: boolean | UnitDefaultArgs<ExtArgs>
    receipt?: boolean | ServiceReceiptDefaultArgs<ExtArgs>
  }
  export type StockDetailIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
    unit?: boolean | UnitDefaultArgs<ExtArgs>
    receipt?: boolean | ServiceReceiptDefaultArgs<ExtArgs>
  }
  export type StockDetailIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
    unit?: boolean | UnitDefaultArgs<ExtArgs>
    receipt?: boolean | ServiceReceiptDefaultArgs<ExtArgs>
  }

  export type $StockDetailPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StockDetail"
    objects: {
      product: Prisma.$ProductPayload<ExtArgs>
      unit: Prisma.$UnitPayload<ExtArgs>
      receipt: Prisma.$ServiceReceiptPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      productId: number
      unitId: number
      receiptId: string
      sourceProductId: number | null
      netPrice: number | null
      discountPrice: number | null
      quantity: number
      isEnabled: boolean
      expiredAt: Date | null
    }, ExtArgs["result"]["stockDetail"]>
    composites: {}
  }

  type StockDetailGetPayload<S extends boolean | null | undefined | StockDetailDefaultArgs> = $Result.GetResult<Prisma.$StockDetailPayload, S>

  type StockDetailCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StockDetailFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StockDetailCountAggregateInputType | true
    }

  export interface StockDetailDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StockDetail'], meta: { name: 'StockDetail' } }
    /**
     * Find zero or one StockDetail that matches the filter.
     * @param {StockDetailFindUniqueArgs} args - Arguments to find a StockDetail
     * @example
     * // Get one StockDetail
     * const stockDetail = await prisma.stockDetail.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StockDetailFindUniqueArgs>(args: SelectSubset<T, StockDetailFindUniqueArgs<ExtArgs>>): Prisma__StockDetailClient<$Result.GetResult<Prisma.$StockDetailPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one StockDetail that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StockDetailFindUniqueOrThrowArgs} args - Arguments to find a StockDetail
     * @example
     * // Get one StockDetail
     * const stockDetail = await prisma.stockDetail.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StockDetailFindUniqueOrThrowArgs>(args: SelectSubset<T, StockDetailFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StockDetailClient<$Result.GetResult<Prisma.$StockDetailPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StockDetail that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockDetailFindFirstArgs} args - Arguments to find a StockDetail
     * @example
     * // Get one StockDetail
     * const stockDetail = await prisma.stockDetail.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StockDetailFindFirstArgs>(args?: SelectSubset<T, StockDetailFindFirstArgs<ExtArgs>>): Prisma__StockDetailClient<$Result.GetResult<Prisma.$StockDetailPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StockDetail that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockDetailFindFirstOrThrowArgs} args - Arguments to find a StockDetail
     * @example
     * // Get one StockDetail
     * const stockDetail = await prisma.stockDetail.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StockDetailFindFirstOrThrowArgs>(args?: SelectSubset<T, StockDetailFindFirstOrThrowArgs<ExtArgs>>): Prisma__StockDetailClient<$Result.GetResult<Prisma.$StockDetailPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more StockDetails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockDetailFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StockDetails
     * const stockDetails = await prisma.stockDetail.findMany()
     * 
     * // Get first 10 StockDetails
     * const stockDetails = await prisma.stockDetail.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const stockDetailWithIdOnly = await prisma.stockDetail.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StockDetailFindManyArgs>(args?: SelectSubset<T, StockDetailFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockDetailPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a StockDetail.
     * @param {StockDetailCreateArgs} args - Arguments to create a StockDetail.
     * @example
     * // Create one StockDetail
     * const StockDetail = await prisma.stockDetail.create({
     *   data: {
     *     // ... data to create a StockDetail
     *   }
     * })
     * 
     */
    create<T extends StockDetailCreateArgs>(args: SelectSubset<T, StockDetailCreateArgs<ExtArgs>>): Prisma__StockDetailClient<$Result.GetResult<Prisma.$StockDetailPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many StockDetails.
     * @param {StockDetailCreateManyArgs} args - Arguments to create many StockDetails.
     * @example
     * // Create many StockDetails
     * const stockDetail = await prisma.stockDetail.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StockDetailCreateManyArgs>(args?: SelectSubset<T, StockDetailCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StockDetails and returns the data saved in the database.
     * @param {StockDetailCreateManyAndReturnArgs} args - Arguments to create many StockDetails.
     * @example
     * // Create many StockDetails
     * const stockDetail = await prisma.stockDetail.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StockDetails and only return the `id`
     * const stockDetailWithIdOnly = await prisma.stockDetail.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StockDetailCreateManyAndReturnArgs>(args?: SelectSubset<T, StockDetailCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockDetailPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a StockDetail.
     * @param {StockDetailDeleteArgs} args - Arguments to delete one StockDetail.
     * @example
     * // Delete one StockDetail
     * const StockDetail = await prisma.stockDetail.delete({
     *   where: {
     *     // ... filter to delete one StockDetail
     *   }
     * })
     * 
     */
    delete<T extends StockDetailDeleteArgs>(args: SelectSubset<T, StockDetailDeleteArgs<ExtArgs>>): Prisma__StockDetailClient<$Result.GetResult<Prisma.$StockDetailPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one StockDetail.
     * @param {StockDetailUpdateArgs} args - Arguments to update one StockDetail.
     * @example
     * // Update one StockDetail
     * const stockDetail = await prisma.stockDetail.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StockDetailUpdateArgs>(args: SelectSubset<T, StockDetailUpdateArgs<ExtArgs>>): Prisma__StockDetailClient<$Result.GetResult<Prisma.$StockDetailPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more StockDetails.
     * @param {StockDetailDeleteManyArgs} args - Arguments to filter StockDetails to delete.
     * @example
     * // Delete a few StockDetails
     * const { count } = await prisma.stockDetail.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StockDetailDeleteManyArgs>(args?: SelectSubset<T, StockDetailDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StockDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockDetailUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StockDetails
     * const stockDetail = await prisma.stockDetail.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StockDetailUpdateManyArgs>(args: SelectSubset<T, StockDetailUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StockDetails and returns the data updated in the database.
     * @param {StockDetailUpdateManyAndReturnArgs} args - Arguments to update many StockDetails.
     * @example
     * // Update many StockDetails
     * const stockDetail = await prisma.stockDetail.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more StockDetails and only return the `id`
     * const stockDetailWithIdOnly = await prisma.stockDetail.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends StockDetailUpdateManyAndReturnArgs>(args: SelectSubset<T, StockDetailUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockDetailPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one StockDetail.
     * @param {StockDetailUpsertArgs} args - Arguments to update or create a StockDetail.
     * @example
     * // Update or create a StockDetail
     * const stockDetail = await prisma.stockDetail.upsert({
     *   create: {
     *     // ... data to create a StockDetail
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StockDetail we want to update
     *   }
     * })
     */
    upsert<T extends StockDetailUpsertArgs>(args: SelectSubset<T, StockDetailUpsertArgs<ExtArgs>>): Prisma__StockDetailClient<$Result.GetResult<Prisma.$StockDetailPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of StockDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockDetailCountArgs} args - Arguments to filter StockDetails to count.
     * @example
     * // Count the number of StockDetails
     * const count = await prisma.stockDetail.count({
     *   where: {
     *     // ... the filter for the StockDetails we want to count
     *   }
     * })
    **/
    count<T extends StockDetailCountArgs>(
      args?: Subset<T, StockDetailCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StockDetailCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StockDetail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockDetailAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StockDetailAggregateArgs>(args: Subset<T, StockDetailAggregateArgs>): Prisma.PrismaPromise<GetStockDetailAggregateType<T>>

    /**
     * Group by StockDetail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockDetailGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StockDetailGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StockDetailGroupByArgs['orderBy'] }
        : { orderBy?: StockDetailGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StockDetailGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStockDetailGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StockDetail model
   */
  readonly fields: StockDetailFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StockDetail.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StockDetailClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    unit<T extends UnitDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UnitDefaultArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    receipt<T extends ServiceReceiptDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ServiceReceiptDefaultArgs<ExtArgs>>): Prisma__ServiceReceiptClient<$Result.GetResult<Prisma.$ServiceReceiptPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StockDetail model
   */
  interface StockDetailFieldRefs {
    readonly id: FieldRef<"StockDetail", 'String'>
    readonly productId: FieldRef<"StockDetail", 'Int'>
    readonly unitId: FieldRef<"StockDetail", 'Int'>
    readonly receiptId: FieldRef<"StockDetail", 'String'>
    readonly sourceProductId: FieldRef<"StockDetail", 'Int'>
    readonly netPrice: FieldRef<"StockDetail", 'Float'>
    readonly discountPrice: FieldRef<"StockDetail", 'Float'>
    readonly quantity: FieldRef<"StockDetail", 'Float'>
    readonly isEnabled: FieldRef<"StockDetail", 'Boolean'>
    readonly expiredAt: FieldRef<"StockDetail", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * StockDetail findUnique
   */
  export type StockDetailFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockDetail
     */
    select?: StockDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockDetail
     */
    omit?: StockDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockDetailInclude<ExtArgs> | null
    /**
     * Filter, which StockDetail to fetch.
     */
    where: StockDetailWhereUniqueInput
  }

  /**
   * StockDetail findUniqueOrThrow
   */
  export type StockDetailFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockDetail
     */
    select?: StockDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockDetail
     */
    omit?: StockDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockDetailInclude<ExtArgs> | null
    /**
     * Filter, which StockDetail to fetch.
     */
    where: StockDetailWhereUniqueInput
  }

  /**
   * StockDetail findFirst
   */
  export type StockDetailFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockDetail
     */
    select?: StockDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockDetail
     */
    omit?: StockDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockDetailInclude<ExtArgs> | null
    /**
     * Filter, which StockDetail to fetch.
     */
    where?: StockDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockDetails to fetch.
     */
    orderBy?: StockDetailOrderByWithRelationInput | StockDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StockDetails.
     */
    cursor?: StockDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StockDetails.
     */
    distinct?: StockDetailScalarFieldEnum | StockDetailScalarFieldEnum[]
  }

  /**
   * StockDetail findFirstOrThrow
   */
  export type StockDetailFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockDetail
     */
    select?: StockDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockDetail
     */
    omit?: StockDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockDetailInclude<ExtArgs> | null
    /**
     * Filter, which StockDetail to fetch.
     */
    where?: StockDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockDetails to fetch.
     */
    orderBy?: StockDetailOrderByWithRelationInput | StockDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StockDetails.
     */
    cursor?: StockDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StockDetails.
     */
    distinct?: StockDetailScalarFieldEnum | StockDetailScalarFieldEnum[]
  }

  /**
   * StockDetail findMany
   */
  export type StockDetailFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockDetail
     */
    select?: StockDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockDetail
     */
    omit?: StockDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockDetailInclude<ExtArgs> | null
    /**
     * Filter, which StockDetails to fetch.
     */
    where?: StockDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockDetails to fetch.
     */
    orderBy?: StockDetailOrderByWithRelationInput | StockDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StockDetails.
     */
    cursor?: StockDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockDetails.
     */
    skip?: number
    distinct?: StockDetailScalarFieldEnum | StockDetailScalarFieldEnum[]
  }

  /**
   * StockDetail create
   */
  export type StockDetailCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockDetail
     */
    select?: StockDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockDetail
     */
    omit?: StockDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockDetailInclude<ExtArgs> | null
    /**
     * The data needed to create a StockDetail.
     */
    data: XOR<StockDetailCreateInput, StockDetailUncheckedCreateInput>
  }

  /**
   * StockDetail createMany
   */
  export type StockDetailCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StockDetails.
     */
    data: StockDetailCreateManyInput | StockDetailCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StockDetail createManyAndReturn
   */
  export type StockDetailCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockDetail
     */
    select?: StockDetailSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StockDetail
     */
    omit?: StockDetailOmit<ExtArgs> | null
    /**
     * The data used to create many StockDetails.
     */
    data: StockDetailCreateManyInput | StockDetailCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockDetailIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * StockDetail update
   */
  export type StockDetailUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockDetail
     */
    select?: StockDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockDetail
     */
    omit?: StockDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockDetailInclude<ExtArgs> | null
    /**
     * The data needed to update a StockDetail.
     */
    data: XOR<StockDetailUpdateInput, StockDetailUncheckedUpdateInput>
    /**
     * Choose, which StockDetail to update.
     */
    where: StockDetailWhereUniqueInput
  }

  /**
   * StockDetail updateMany
   */
  export type StockDetailUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StockDetails.
     */
    data: XOR<StockDetailUpdateManyMutationInput, StockDetailUncheckedUpdateManyInput>
    /**
     * Filter which StockDetails to update
     */
    where?: StockDetailWhereInput
    /**
     * Limit how many StockDetails to update.
     */
    limit?: number
  }

  /**
   * StockDetail updateManyAndReturn
   */
  export type StockDetailUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockDetail
     */
    select?: StockDetailSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StockDetail
     */
    omit?: StockDetailOmit<ExtArgs> | null
    /**
     * The data used to update StockDetails.
     */
    data: XOR<StockDetailUpdateManyMutationInput, StockDetailUncheckedUpdateManyInput>
    /**
     * Filter which StockDetails to update
     */
    where?: StockDetailWhereInput
    /**
     * Limit how many StockDetails to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockDetailIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * StockDetail upsert
   */
  export type StockDetailUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockDetail
     */
    select?: StockDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockDetail
     */
    omit?: StockDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockDetailInclude<ExtArgs> | null
    /**
     * The filter to search for the StockDetail to update in case it exists.
     */
    where: StockDetailWhereUniqueInput
    /**
     * In case the StockDetail found by the `where` argument doesn't exist, create a new StockDetail with this data.
     */
    create: XOR<StockDetailCreateInput, StockDetailUncheckedCreateInput>
    /**
     * In case the StockDetail was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StockDetailUpdateInput, StockDetailUncheckedUpdateInput>
  }

  /**
   * StockDetail delete
   */
  export type StockDetailDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockDetail
     */
    select?: StockDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockDetail
     */
    omit?: StockDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockDetailInclude<ExtArgs> | null
    /**
     * Filter which StockDetail to delete.
     */
    where: StockDetailWhereUniqueInput
  }

  /**
   * StockDetail deleteMany
   */
  export type StockDetailDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StockDetails to delete
     */
    where?: StockDetailWhereInput
    /**
     * Limit how many StockDetails to delete.
     */
    limit?: number
  }

  /**
   * StockDetail without action
   */
  export type StockDetailDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockDetail
     */
    select?: StockDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockDetail
     */
    omit?: StockDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockDetailInclude<ExtArgs> | null
  }


  /**
   * Model DoctorSchedule
   */

  export type AggregateDoctorSchedule = {
    _count: DoctorScheduleCountAggregateOutputType | null
    _avg: DoctorScheduleAvgAggregateOutputType | null
    _sum: DoctorScheduleSumAggregateOutputType | null
    _min: DoctorScheduleMinAggregateOutputType | null
    _max: DoctorScheduleMaxAggregateOutputType | null
  }

  export type DoctorScheduleAvgAggregateOutputType = {
    id: number | null
    unitId: number | null
    doctorId: number | null
    quota: number | null
  }

  export type DoctorScheduleSumAggregateOutputType = {
    id: number | null
    unitId: number | null
    doctorId: number | null
    quota: number | null
  }

  export type DoctorScheduleMinAggregateOutputType = {
    id: number | null
    unitId: number | null
    doctorId: number | null
    startTime: Date | null
    endTime: Date | null
    note: string | null
    days: string | null
    quota: number | null
    isEnabled: boolean | null
  }

  export type DoctorScheduleMaxAggregateOutputType = {
    id: number | null
    unitId: number | null
    doctorId: number | null
    startTime: Date | null
    endTime: Date | null
    note: string | null
    days: string | null
    quota: number | null
    isEnabled: boolean | null
  }

  export type DoctorScheduleCountAggregateOutputType = {
    id: number
    unitId: number
    doctorId: number
    startTime: number
    endTime: number
    note: number
    days: number
    quota: number
    isEnabled: number
    _all: number
  }


  export type DoctorScheduleAvgAggregateInputType = {
    id?: true
    unitId?: true
    doctorId?: true
    quota?: true
  }

  export type DoctorScheduleSumAggregateInputType = {
    id?: true
    unitId?: true
    doctorId?: true
    quota?: true
  }

  export type DoctorScheduleMinAggregateInputType = {
    id?: true
    unitId?: true
    doctorId?: true
    startTime?: true
    endTime?: true
    note?: true
    days?: true
    quota?: true
    isEnabled?: true
  }

  export type DoctorScheduleMaxAggregateInputType = {
    id?: true
    unitId?: true
    doctorId?: true
    startTime?: true
    endTime?: true
    note?: true
    days?: true
    quota?: true
    isEnabled?: true
  }

  export type DoctorScheduleCountAggregateInputType = {
    id?: true
    unitId?: true
    doctorId?: true
    startTime?: true
    endTime?: true
    note?: true
    days?: true
    quota?: true
    isEnabled?: true
    _all?: true
  }

  export type DoctorScheduleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DoctorSchedule to aggregate.
     */
    where?: DoctorScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DoctorSchedules to fetch.
     */
    orderBy?: DoctorScheduleOrderByWithRelationInput | DoctorScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DoctorScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DoctorSchedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DoctorSchedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DoctorSchedules
    **/
    _count?: true | DoctorScheduleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DoctorScheduleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DoctorScheduleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DoctorScheduleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DoctorScheduleMaxAggregateInputType
  }

  export type GetDoctorScheduleAggregateType<T extends DoctorScheduleAggregateArgs> = {
        [P in keyof T & keyof AggregateDoctorSchedule]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDoctorSchedule[P]>
      : GetScalarType<T[P], AggregateDoctorSchedule[P]>
  }




  export type DoctorScheduleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DoctorScheduleWhereInput
    orderBy?: DoctorScheduleOrderByWithAggregationInput | DoctorScheduleOrderByWithAggregationInput[]
    by: DoctorScheduleScalarFieldEnum[] | DoctorScheduleScalarFieldEnum
    having?: DoctorScheduleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DoctorScheduleCountAggregateInputType | true
    _avg?: DoctorScheduleAvgAggregateInputType
    _sum?: DoctorScheduleSumAggregateInputType
    _min?: DoctorScheduleMinAggregateInputType
    _max?: DoctorScheduleMaxAggregateInputType
  }

  export type DoctorScheduleGroupByOutputType = {
    id: number
    unitId: number
    doctorId: number
    startTime: Date
    endTime: Date
    note: string | null
    days: string
    quota: number
    isEnabled: boolean
    _count: DoctorScheduleCountAggregateOutputType | null
    _avg: DoctorScheduleAvgAggregateOutputType | null
    _sum: DoctorScheduleSumAggregateOutputType | null
    _min: DoctorScheduleMinAggregateOutputType | null
    _max: DoctorScheduleMaxAggregateOutputType | null
  }

  type GetDoctorScheduleGroupByPayload<T extends DoctorScheduleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DoctorScheduleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DoctorScheduleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DoctorScheduleGroupByOutputType[P]>
            : GetScalarType<T[P], DoctorScheduleGroupByOutputType[P]>
        }
      >
    >


  export type DoctorScheduleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    unitId?: boolean
    doctorId?: boolean
    startTime?: boolean
    endTime?: boolean
    note?: boolean
    days?: boolean
    quota?: boolean
    isEnabled?: boolean
    unit?: boolean | UnitDefaultArgs<ExtArgs>
    doctor?: boolean | EmployeeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["doctorSchedule"]>

  export type DoctorScheduleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    unitId?: boolean
    doctorId?: boolean
    startTime?: boolean
    endTime?: boolean
    note?: boolean
    days?: boolean
    quota?: boolean
    isEnabled?: boolean
    unit?: boolean | UnitDefaultArgs<ExtArgs>
    doctor?: boolean | EmployeeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["doctorSchedule"]>

  export type DoctorScheduleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    unitId?: boolean
    doctorId?: boolean
    startTime?: boolean
    endTime?: boolean
    note?: boolean
    days?: boolean
    quota?: boolean
    isEnabled?: boolean
    unit?: boolean | UnitDefaultArgs<ExtArgs>
    doctor?: boolean | EmployeeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["doctorSchedule"]>

  export type DoctorScheduleSelectScalar = {
    id?: boolean
    unitId?: boolean
    doctorId?: boolean
    startTime?: boolean
    endTime?: boolean
    note?: boolean
    days?: boolean
    quota?: boolean
    isEnabled?: boolean
  }

  export type DoctorScheduleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "unitId" | "doctorId" | "startTime" | "endTime" | "note" | "days" | "quota" | "isEnabled", ExtArgs["result"]["doctorSchedule"]>
  export type DoctorScheduleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    unit?: boolean | UnitDefaultArgs<ExtArgs>
    doctor?: boolean | EmployeeDefaultArgs<ExtArgs>
  }
  export type DoctorScheduleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    unit?: boolean | UnitDefaultArgs<ExtArgs>
    doctor?: boolean | EmployeeDefaultArgs<ExtArgs>
  }
  export type DoctorScheduleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    unit?: boolean | UnitDefaultArgs<ExtArgs>
    doctor?: boolean | EmployeeDefaultArgs<ExtArgs>
  }

  export type $DoctorSchedulePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DoctorSchedule"
    objects: {
      unit: Prisma.$UnitPayload<ExtArgs>
      doctor: Prisma.$EmployeePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      unitId: number
      doctorId: number
      startTime: Date
      endTime: Date
      note: string | null
      days: string
      quota: number
      isEnabled: boolean
    }, ExtArgs["result"]["doctorSchedule"]>
    composites: {}
  }

  type DoctorScheduleGetPayload<S extends boolean | null | undefined | DoctorScheduleDefaultArgs> = $Result.GetResult<Prisma.$DoctorSchedulePayload, S>

  type DoctorScheduleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DoctorScheduleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DoctorScheduleCountAggregateInputType | true
    }

  export interface DoctorScheduleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DoctorSchedule'], meta: { name: 'DoctorSchedule' } }
    /**
     * Find zero or one DoctorSchedule that matches the filter.
     * @param {DoctorScheduleFindUniqueArgs} args - Arguments to find a DoctorSchedule
     * @example
     * // Get one DoctorSchedule
     * const doctorSchedule = await prisma.doctorSchedule.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DoctorScheduleFindUniqueArgs>(args: SelectSubset<T, DoctorScheduleFindUniqueArgs<ExtArgs>>): Prisma__DoctorScheduleClient<$Result.GetResult<Prisma.$DoctorSchedulePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DoctorSchedule that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DoctorScheduleFindUniqueOrThrowArgs} args - Arguments to find a DoctorSchedule
     * @example
     * // Get one DoctorSchedule
     * const doctorSchedule = await prisma.doctorSchedule.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DoctorScheduleFindUniqueOrThrowArgs>(args: SelectSubset<T, DoctorScheduleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DoctorScheduleClient<$Result.GetResult<Prisma.$DoctorSchedulePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DoctorSchedule that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoctorScheduleFindFirstArgs} args - Arguments to find a DoctorSchedule
     * @example
     * // Get one DoctorSchedule
     * const doctorSchedule = await prisma.doctorSchedule.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DoctorScheduleFindFirstArgs>(args?: SelectSubset<T, DoctorScheduleFindFirstArgs<ExtArgs>>): Prisma__DoctorScheduleClient<$Result.GetResult<Prisma.$DoctorSchedulePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DoctorSchedule that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoctorScheduleFindFirstOrThrowArgs} args - Arguments to find a DoctorSchedule
     * @example
     * // Get one DoctorSchedule
     * const doctorSchedule = await prisma.doctorSchedule.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DoctorScheduleFindFirstOrThrowArgs>(args?: SelectSubset<T, DoctorScheduleFindFirstOrThrowArgs<ExtArgs>>): Prisma__DoctorScheduleClient<$Result.GetResult<Prisma.$DoctorSchedulePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DoctorSchedules that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoctorScheduleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DoctorSchedules
     * const doctorSchedules = await prisma.doctorSchedule.findMany()
     * 
     * // Get first 10 DoctorSchedules
     * const doctorSchedules = await prisma.doctorSchedule.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const doctorScheduleWithIdOnly = await prisma.doctorSchedule.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DoctorScheduleFindManyArgs>(args?: SelectSubset<T, DoctorScheduleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DoctorSchedulePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DoctorSchedule.
     * @param {DoctorScheduleCreateArgs} args - Arguments to create a DoctorSchedule.
     * @example
     * // Create one DoctorSchedule
     * const DoctorSchedule = await prisma.doctorSchedule.create({
     *   data: {
     *     // ... data to create a DoctorSchedule
     *   }
     * })
     * 
     */
    create<T extends DoctorScheduleCreateArgs>(args: SelectSubset<T, DoctorScheduleCreateArgs<ExtArgs>>): Prisma__DoctorScheduleClient<$Result.GetResult<Prisma.$DoctorSchedulePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DoctorSchedules.
     * @param {DoctorScheduleCreateManyArgs} args - Arguments to create many DoctorSchedules.
     * @example
     * // Create many DoctorSchedules
     * const doctorSchedule = await prisma.doctorSchedule.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DoctorScheduleCreateManyArgs>(args?: SelectSubset<T, DoctorScheduleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DoctorSchedules and returns the data saved in the database.
     * @param {DoctorScheduleCreateManyAndReturnArgs} args - Arguments to create many DoctorSchedules.
     * @example
     * // Create many DoctorSchedules
     * const doctorSchedule = await prisma.doctorSchedule.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DoctorSchedules and only return the `id`
     * const doctorScheduleWithIdOnly = await prisma.doctorSchedule.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DoctorScheduleCreateManyAndReturnArgs>(args?: SelectSubset<T, DoctorScheduleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DoctorSchedulePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DoctorSchedule.
     * @param {DoctorScheduleDeleteArgs} args - Arguments to delete one DoctorSchedule.
     * @example
     * // Delete one DoctorSchedule
     * const DoctorSchedule = await prisma.doctorSchedule.delete({
     *   where: {
     *     // ... filter to delete one DoctorSchedule
     *   }
     * })
     * 
     */
    delete<T extends DoctorScheduleDeleteArgs>(args: SelectSubset<T, DoctorScheduleDeleteArgs<ExtArgs>>): Prisma__DoctorScheduleClient<$Result.GetResult<Prisma.$DoctorSchedulePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DoctorSchedule.
     * @param {DoctorScheduleUpdateArgs} args - Arguments to update one DoctorSchedule.
     * @example
     * // Update one DoctorSchedule
     * const doctorSchedule = await prisma.doctorSchedule.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DoctorScheduleUpdateArgs>(args: SelectSubset<T, DoctorScheduleUpdateArgs<ExtArgs>>): Prisma__DoctorScheduleClient<$Result.GetResult<Prisma.$DoctorSchedulePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DoctorSchedules.
     * @param {DoctorScheduleDeleteManyArgs} args - Arguments to filter DoctorSchedules to delete.
     * @example
     * // Delete a few DoctorSchedules
     * const { count } = await prisma.doctorSchedule.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DoctorScheduleDeleteManyArgs>(args?: SelectSubset<T, DoctorScheduleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DoctorSchedules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoctorScheduleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DoctorSchedules
     * const doctorSchedule = await prisma.doctorSchedule.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DoctorScheduleUpdateManyArgs>(args: SelectSubset<T, DoctorScheduleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DoctorSchedules and returns the data updated in the database.
     * @param {DoctorScheduleUpdateManyAndReturnArgs} args - Arguments to update many DoctorSchedules.
     * @example
     * // Update many DoctorSchedules
     * const doctorSchedule = await prisma.doctorSchedule.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DoctorSchedules and only return the `id`
     * const doctorScheduleWithIdOnly = await prisma.doctorSchedule.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DoctorScheduleUpdateManyAndReturnArgs>(args: SelectSubset<T, DoctorScheduleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DoctorSchedulePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DoctorSchedule.
     * @param {DoctorScheduleUpsertArgs} args - Arguments to update or create a DoctorSchedule.
     * @example
     * // Update or create a DoctorSchedule
     * const doctorSchedule = await prisma.doctorSchedule.upsert({
     *   create: {
     *     // ... data to create a DoctorSchedule
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DoctorSchedule we want to update
     *   }
     * })
     */
    upsert<T extends DoctorScheduleUpsertArgs>(args: SelectSubset<T, DoctorScheduleUpsertArgs<ExtArgs>>): Prisma__DoctorScheduleClient<$Result.GetResult<Prisma.$DoctorSchedulePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DoctorSchedules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoctorScheduleCountArgs} args - Arguments to filter DoctorSchedules to count.
     * @example
     * // Count the number of DoctorSchedules
     * const count = await prisma.doctorSchedule.count({
     *   where: {
     *     // ... the filter for the DoctorSchedules we want to count
     *   }
     * })
    **/
    count<T extends DoctorScheduleCountArgs>(
      args?: Subset<T, DoctorScheduleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DoctorScheduleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DoctorSchedule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoctorScheduleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DoctorScheduleAggregateArgs>(args: Subset<T, DoctorScheduleAggregateArgs>): Prisma.PrismaPromise<GetDoctorScheduleAggregateType<T>>

    /**
     * Group by DoctorSchedule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoctorScheduleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DoctorScheduleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DoctorScheduleGroupByArgs['orderBy'] }
        : { orderBy?: DoctorScheduleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DoctorScheduleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDoctorScheduleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DoctorSchedule model
   */
  readonly fields: DoctorScheduleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DoctorSchedule.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DoctorScheduleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    unit<T extends UnitDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UnitDefaultArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    doctor<T extends EmployeeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmployeeDefaultArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DoctorSchedule model
   */
  interface DoctorScheduleFieldRefs {
    readonly id: FieldRef<"DoctorSchedule", 'Int'>
    readonly unitId: FieldRef<"DoctorSchedule", 'Int'>
    readonly doctorId: FieldRef<"DoctorSchedule", 'Int'>
    readonly startTime: FieldRef<"DoctorSchedule", 'DateTime'>
    readonly endTime: FieldRef<"DoctorSchedule", 'DateTime'>
    readonly note: FieldRef<"DoctorSchedule", 'String'>
    readonly days: FieldRef<"DoctorSchedule", 'String'>
    readonly quota: FieldRef<"DoctorSchedule", 'Int'>
    readonly isEnabled: FieldRef<"DoctorSchedule", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * DoctorSchedule findUnique
   */
  export type DoctorScheduleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoctorSchedule
     */
    select?: DoctorScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DoctorSchedule
     */
    omit?: DoctorScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorScheduleInclude<ExtArgs> | null
    /**
     * Filter, which DoctorSchedule to fetch.
     */
    where: DoctorScheduleWhereUniqueInput
  }

  /**
   * DoctorSchedule findUniqueOrThrow
   */
  export type DoctorScheduleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoctorSchedule
     */
    select?: DoctorScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DoctorSchedule
     */
    omit?: DoctorScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorScheduleInclude<ExtArgs> | null
    /**
     * Filter, which DoctorSchedule to fetch.
     */
    where: DoctorScheduleWhereUniqueInput
  }

  /**
   * DoctorSchedule findFirst
   */
  export type DoctorScheduleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoctorSchedule
     */
    select?: DoctorScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DoctorSchedule
     */
    omit?: DoctorScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorScheduleInclude<ExtArgs> | null
    /**
     * Filter, which DoctorSchedule to fetch.
     */
    where?: DoctorScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DoctorSchedules to fetch.
     */
    orderBy?: DoctorScheduleOrderByWithRelationInput | DoctorScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DoctorSchedules.
     */
    cursor?: DoctorScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DoctorSchedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DoctorSchedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DoctorSchedules.
     */
    distinct?: DoctorScheduleScalarFieldEnum | DoctorScheduleScalarFieldEnum[]
  }

  /**
   * DoctorSchedule findFirstOrThrow
   */
  export type DoctorScheduleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoctorSchedule
     */
    select?: DoctorScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DoctorSchedule
     */
    omit?: DoctorScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorScheduleInclude<ExtArgs> | null
    /**
     * Filter, which DoctorSchedule to fetch.
     */
    where?: DoctorScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DoctorSchedules to fetch.
     */
    orderBy?: DoctorScheduleOrderByWithRelationInput | DoctorScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DoctorSchedules.
     */
    cursor?: DoctorScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DoctorSchedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DoctorSchedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DoctorSchedules.
     */
    distinct?: DoctorScheduleScalarFieldEnum | DoctorScheduleScalarFieldEnum[]
  }

  /**
   * DoctorSchedule findMany
   */
  export type DoctorScheduleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoctorSchedule
     */
    select?: DoctorScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DoctorSchedule
     */
    omit?: DoctorScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorScheduleInclude<ExtArgs> | null
    /**
     * Filter, which DoctorSchedules to fetch.
     */
    where?: DoctorScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DoctorSchedules to fetch.
     */
    orderBy?: DoctorScheduleOrderByWithRelationInput | DoctorScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DoctorSchedules.
     */
    cursor?: DoctorScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DoctorSchedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DoctorSchedules.
     */
    skip?: number
    distinct?: DoctorScheduleScalarFieldEnum | DoctorScheduleScalarFieldEnum[]
  }

  /**
   * DoctorSchedule create
   */
  export type DoctorScheduleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoctorSchedule
     */
    select?: DoctorScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DoctorSchedule
     */
    omit?: DoctorScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorScheduleInclude<ExtArgs> | null
    /**
     * The data needed to create a DoctorSchedule.
     */
    data: XOR<DoctorScheduleCreateInput, DoctorScheduleUncheckedCreateInput>
  }

  /**
   * DoctorSchedule createMany
   */
  export type DoctorScheduleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DoctorSchedules.
     */
    data: DoctorScheduleCreateManyInput | DoctorScheduleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DoctorSchedule createManyAndReturn
   */
  export type DoctorScheduleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoctorSchedule
     */
    select?: DoctorScheduleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DoctorSchedule
     */
    omit?: DoctorScheduleOmit<ExtArgs> | null
    /**
     * The data used to create many DoctorSchedules.
     */
    data: DoctorScheduleCreateManyInput | DoctorScheduleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorScheduleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DoctorSchedule update
   */
  export type DoctorScheduleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoctorSchedule
     */
    select?: DoctorScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DoctorSchedule
     */
    omit?: DoctorScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorScheduleInclude<ExtArgs> | null
    /**
     * The data needed to update a DoctorSchedule.
     */
    data: XOR<DoctorScheduleUpdateInput, DoctorScheduleUncheckedUpdateInput>
    /**
     * Choose, which DoctorSchedule to update.
     */
    where: DoctorScheduleWhereUniqueInput
  }

  /**
   * DoctorSchedule updateMany
   */
  export type DoctorScheduleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DoctorSchedules.
     */
    data: XOR<DoctorScheduleUpdateManyMutationInput, DoctorScheduleUncheckedUpdateManyInput>
    /**
     * Filter which DoctorSchedules to update
     */
    where?: DoctorScheduleWhereInput
    /**
     * Limit how many DoctorSchedules to update.
     */
    limit?: number
  }

  /**
   * DoctorSchedule updateManyAndReturn
   */
  export type DoctorScheduleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoctorSchedule
     */
    select?: DoctorScheduleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DoctorSchedule
     */
    omit?: DoctorScheduleOmit<ExtArgs> | null
    /**
     * The data used to update DoctorSchedules.
     */
    data: XOR<DoctorScheduleUpdateManyMutationInput, DoctorScheduleUncheckedUpdateManyInput>
    /**
     * Filter which DoctorSchedules to update
     */
    where?: DoctorScheduleWhereInput
    /**
     * Limit how many DoctorSchedules to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorScheduleIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DoctorSchedule upsert
   */
  export type DoctorScheduleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoctorSchedule
     */
    select?: DoctorScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DoctorSchedule
     */
    omit?: DoctorScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorScheduleInclude<ExtArgs> | null
    /**
     * The filter to search for the DoctorSchedule to update in case it exists.
     */
    where: DoctorScheduleWhereUniqueInput
    /**
     * In case the DoctorSchedule found by the `where` argument doesn't exist, create a new DoctorSchedule with this data.
     */
    create: XOR<DoctorScheduleCreateInput, DoctorScheduleUncheckedCreateInput>
    /**
     * In case the DoctorSchedule was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DoctorScheduleUpdateInput, DoctorScheduleUncheckedUpdateInput>
  }

  /**
   * DoctorSchedule delete
   */
  export type DoctorScheduleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoctorSchedule
     */
    select?: DoctorScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DoctorSchedule
     */
    omit?: DoctorScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorScheduleInclude<ExtArgs> | null
    /**
     * Filter which DoctorSchedule to delete.
     */
    where: DoctorScheduleWhereUniqueInput
  }

  /**
   * DoctorSchedule deleteMany
   */
  export type DoctorScheduleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DoctorSchedules to delete
     */
    where?: DoctorScheduleWhereInput
    /**
     * Limit how many DoctorSchedules to delete.
     */
    limit?: number
  }

  /**
   * DoctorSchedule without action
   */
  export type DoctorScheduleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoctorSchedule
     */
    select?: DoctorScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DoctorSchedule
     */
    omit?: DoctorScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorScheduleInclude<ExtArgs> | null
  }


  /**
   * Model Employee
   */

  export type AggregateEmployee = {
    _count: EmployeeCountAggregateOutputType | null
    _avg: EmployeeAvgAggregateOutputType | null
    _sum: EmployeeSumAggregateOutputType | null
    _min: EmployeeMinAggregateOutputType | null
    _max: EmployeeMaxAggregateOutputType | null
  }

  export type EmployeeAvgAggregateOutputType = {
    id: number | null
  }

  export type EmployeeSumAggregateOutputType = {
    id: number | null
  }

  export type EmployeeMinAggregateOutputType = {
    id: number | null
    fullName: string | null
    identityNo: string | null
    isEnabled: boolean | null
  }

  export type EmployeeMaxAggregateOutputType = {
    id: number | null
    fullName: string | null
    identityNo: string | null
    isEnabled: boolean | null
  }

  export type EmployeeCountAggregateOutputType = {
    id: number
    fullName: number
    identityNo: number
    isEnabled: number
    _all: number
  }


  export type EmployeeAvgAggregateInputType = {
    id?: true
  }

  export type EmployeeSumAggregateInputType = {
    id?: true
  }

  export type EmployeeMinAggregateInputType = {
    id?: true
    fullName?: true
    identityNo?: true
    isEnabled?: true
  }

  export type EmployeeMaxAggregateInputType = {
    id?: true
    fullName?: true
    identityNo?: true
    isEnabled?: true
  }

  export type EmployeeCountAggregateInputType = {
    id?: true
    fullName?: true
    identityNo?: true
    isEnabled?: true
    _all?: true
  }

  export type EmployeeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Employee to aggregate.
     */
    where?: EmployeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Employees to fetch.
     */
    orderBy?: EmployeeOrderByWithRelationInput | EmployeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmployeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Employees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Employees
    **/
    _count?: true | EmployeeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EmployeeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EmployeeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmployeeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmployeeMaxAggregateInputType
  }

  export type GetEmployeeAggregateType<T extends EmployeeAggregateArgs> = {
        [P in keyof T & keyof AggregateEmployee]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmployee[P]>
      : GetScalarType<T[P], AggregateEmployee[P]>
  }




  export type EmployeeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeeWhereInput
    orderBy?: EmployeeOrderByWithAggregationInput | EmployeeOrderByWithAggregationInput[]
    by: EmployeeScalarFieldEnum[] | EmployeeScalarFieldEnum
    having?: EmployeeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmployeeCountAggregateInputType | true
    _avg?: EmployeeAvgAggregateInputType
    _sum?: EmployeeSumAggregateInputType
    _min?: EmployeeMinAggregateInputType
    _max?: EmployeeMaxAggregateInputType
  }

  export type EmployeeGroupByOutputType = {
    id: number
    fullName: string
    identityNo: string | null
    isEnabled: boolean
    _count: EmployeeCountAggregateOutputType | null
    _avg: EmployeeAvgAggregateOutputType | null
    _sum: EmployeeSumAggregateOutputType | null
    _min: EmployeeMinAggregateOutputType | null
    _max: EmployeeMaxAggregateOutputType | null
  }

  type GetEmployeeGroupByPayload<T extends EmployeeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmployeeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmployeeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmployeeGroupByOutputType[P]>
            : GetScalarType<T[P], EmployeeGroupByOutputType[P]>
        }
      >
    >


  export type EmployeeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fullName?: boolean
    identityNo?: boolean
    isEnabled?: boolean
    doctorSchedules?: boolean | Employee$doctorSchedulesArgs<ExtArgs>
    reservations?: boolean | Employee$reservationsArgs<ExtArgs>
    _count?: boolean | EmployeeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["employee"]>

  export type EmployeeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fullName?: boolean
    identityNo?: boolean
    isEnabled?: boolean
  }, ExtArgs["result"]["employee"]>

  export type EmployeeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fullName?: boolean
    identityNo?: boolean
    isEnabled?: boolean
  }, ExtArgs["result"]["employee"]>

  export type EmployeeSelectScalar = {
    id?: boolean
    fullName?: boolean
    identityNo?: boolean
    isEnabled?: boolean
  }

  export type EmployeeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "fullName" | "identityNo" | "isEnabled", ExtArgs["result"]["employee"]>
  export type EmployeeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    doctorSchedules?: boolean | Employee$doctorSchedulesArgs<ExtArgs>
    reservations?: boolean | Employee$reservationsArgs<ExtArgs>
    _count?: boolean | EmployeeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type EmployeeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type EmployeeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $EmployeePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Employee"
    objects: {
      doctorSchedules: Prisma.$DoctorSchedulePayload<ExtArgs>[]
      reservations: Prisma.$ReservationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      fullName: string
      identityNo: string | null
      isEnabled: boolean
    }, ExtArgs["result"]["employee"]>
    composites: {}
  }

  type EmployeeGetPayload<S extends boolean | null | undefined | EmployeeDefaultArgs> = $Result.GetResult<Prisma.$EmployeePayload, S>

  type EmployeeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EmployeeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EmployeeCountAggregateInputType | true
    }

  export interface EmployeeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Employee'], meta: { name: 'Employee' } }
    /**
     * Find zero or one Employee that matches the filter.
     * @param {EmployeeFindUniqueArgs} args - Arguments to find a Employee
     * @example
     * // Get one Employee
     * const employee = await prisma.employee.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmployeeFindUniqueArgs>(args: SelectSubset<T, EmployeeFindUniqueArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Employee that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EmployeeFindUniqueOrThrowArgs} args - Arguments to find a Employee
     * @example
     * // Get one Employee
     * const employee = await prisma.employee.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmployeeFindUniqueOrThrowArgs>(args: SelectSubset<T, EmployeeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Employee that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeFindFirstArgs} args - Arguments to find a Employee
     * @example
     * // Get one Employee
     * const employee = await prisma.employee.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmployeeFindFirstArgs>(args?: SelectSubset<T, EmployeeFindFirstArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Employee that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeFindFirstOrThrowArgs} args - Arguments to find a Employee
     * @example
     * // Get one Employee
     * const employee = await prisma.employee.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmployeeFindFirstOrThrowArgs>(args?: SelectSubset<T, EmployeeFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Employees that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Employees
     * const employees = await prisma.employee.findMany()
     * 
     * // Get first 10 Employees
     * const employees = await prisma.employee.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const employeeWithIdOnly = await prisma.employee.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EmployeeFindManyArgs>(args?: SelectSubset<T, EmployeeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Employee.
     * @param {EmployeeCreateArgs} args - Arguments to create a Employee.
     * @example
     * // Create one Employee
     * const Employee = await prisma.employee.create({
     *   data: {
     *     // ... data to create a Employee
     *   }
     * })
     * 
     */
    create<T extends EmployeeCreateArgs>(args: SelectSubset<T, EmployeeCreateArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Employees.
     * @param {EmployeeCreateManyArgs} args - Arguments to create many Employees.
     * @example
     * // Create many Employees
     * const employee = await prisma.employee.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmployeeCreateManyArgs>(args?: SelectSubset<T, EmployeeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Employees and returns the data saved in the database.
     * @param {EmployeeCreateManyAndReturnArgs} args - Arguments to create many Employees.
     * @example
     * // Create many Employees
     * const employee = await prisma.employee.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Employees and only return the `id`
     * const employeeWithIdOnly = await prisma.employee.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EmployeeCreateManyAndReturnArgs>(args?: SelectSubset<T, EmployeeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Employee.
     * @param {EmployeeDeleteArgs} args - Arguments to delete one Employee.
     * @example
     * // Delete one Employee
     * const Employee = await prisma.employee.delete({
     *   where: {
     *     // ... filter to delete one Employee
     *   }
     * })
     * 
     */
    delete<T extends EmployeeDeleteArgs>(args: SelectSubset<T, EmployeeDeleteArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Employee.
     * @param {EmployeeUpdateArgs} args - Arguments to update one Employee.
     * @example
     * // Update one Employee
     * const employee = await prisma.employee.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmployeeUpdateArgs>(args: SelectSubset<T, EmployeeUpdateArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Employees.
     * @param {EmployeeDeleteManyArgs} args - Arguments to filter Employees to delete.
     * @example
     * // Delete a few Employees
     * const { count } = await prisma.employee.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmployeeDeleteManyArgs>(args?: SelectSubset<T, EmployeeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Employees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Employees
     * const employee = await prisma.employee.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmployeeUpdateManyArgs>(args: SelectSubset<T, EmployeeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Employees and returns the data updated in the database.
     * @param {EmployeeUpdateManyAndReturnArgs} args - Arguments to update many Employees.
     * @example
     * // Update many Employees
     * const employee = await prisma.employee.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Employees and only return the `id`
     * const employeeWithIdOnly = await prisma.employee.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EmployeeUpdateManyAndReturnArgs>(args: SelectSubset<T, EmployeeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Employee.
     * @param {EmployeeUpsertArgs} args - Arguments to update or create a Employee.
     * @example
     * // Update or create a Employee
     * const employee = await prisma.employee.upsert({
     *   create: {
     *     // ... data to create a Employee
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Employee we want to update
     *   }
     * })
     */
    upsert<T extends EmployeeUpsertArgs>(args: SelectSubset<T, EmployeeUpsertArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Employees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeCountArgs} args - Arguments to filter Employees to count.
     * @example
     * // Count the number of Employees
     * const count = await prisma.employee.count({
     *   where: {
     *     // ... the filter for the Employees we want to count
     *   }
     * })
    **/
    count<T extends EmployeeCountArgs>(
      args?: Subset<T, EmployeeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmployeeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Employee.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmployeeAggregateArgs>(args: Subset<T, EmployeeAggregateArgs>): Prisma.PrismaPromise<GetEmployeeAggregateType<T>>

    /**
     * Group by Employee.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmployeeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmployeeGroupByArgs['orderBy'] }
        : { orderBy?: EmployeeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmployeeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmployeeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Employee model
   */
  readonly fields: EmployeeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Employee.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmployeeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    doctorSchedules<T extends Employee$doctorSchedulesArgs<ExtArgs> = {}>(args?: Subset<T, Employee$doctorSchedulesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DoctorSchedulePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    reservations<T extends Employee$reservationsArgs<ExtArgs> = {}>(args?: Subset<T, Employee$reservationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReservationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Employee model
   */
  interface EmployeeFieldRefs {
    readonly id: FieldRef<"Employee", 'Int'>
    readonly fullName: FieldRef<"Employee", 'String'>
    readonly identityNo: FieldRef<"Employee", 'String'>
    readonly isEnabled: FieldRef<"Employee", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Employee findUnique
   */
  export type EmployeeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter, which Employee to fetch.
     */
    where: EmployeeWhereUniqueInput
  }

  /**
   * Employee findUniqueOrThrow
   */
  export type EmployeeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter, which Employee to fetch.
     */
    where: EmployeeWhereUniqueInput
  }

  /**
   * Employee findFirst
   */
  export type EmployeeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter, which Employee to fetch.
     */
    where?: EmployeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Employees to fetch.
     */
    orderBy?: EmployeeOrderByWithRelationInput | EmployeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Employees.
     */
    cursor?: EmployeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Employees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Employees.
     */
    distinct?: EmployeeScalarFieldEnum | EmployeeScalarFieldEnum[]
  }

  /**
   * Employee findFirstOrThrow
   */
  export type EmployeeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter, which Employee to fetch.
     */
    where?: EmployeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Employees to fetch.
     */
    orderBy?: EmployeeOrderByWithRelationInput | EmployeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Employees.
     */
    cursor?: EmployeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Employees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Employees.
     */
    distinct?: EmployeeScalarFieldEnum | EmployeeScalarFieldEnum[]
  }

  /**
   * Employee findMany
   */
  export type EmployeeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter, which Employees to fetch.
     */
    where?: EmployeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Employees to fetch.
     */
    orderBy?: EmployeeOrderByWithRelationInput | EmployeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Employees.
     */
    cursor?: EmployeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Employees.
     */
    skip?: number
    distinct?: EmployeeScalarFieldEnum | EmployeeScalarFieldEnum[]
  }

  /**
   * Employee create
   */
  export type EmployeeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * The data needed to create a Employee.
     */
    data: XOR<EmployeeCreateInput, EmployeeUncheckedCreateInput>
  }

  /**
   * Employee createMany
   */
  export type EmployeeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Employees.
     */
    data: EmployeeCreateManyInput | EmployeeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Employee createManyAndReturn
   */
  export type EmployeeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * The data used to create many Employees.
     */
    data: EmployeeCreateManyInput | EmployeeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Employee update
   */
  export type EmployeeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * The data needed to update a Employee.
     */
    data: XOR<EmployeeUpdateInput, EmployeeUncheckedUpdateInput>
    /**
     * Choose, which Employee to update.
     */
    where: EmployeeWhereUniqueInput
  }

  /**
   * Employee updateMany
   */
  export type EmployeeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Employees.
     */
    data: XOR<EmployeeUpdateManyMutationInput, EmployeeUncheckedUpdateManyInput>
    /**
     * Filter which Employees to update
     */
    where?: EmployeeWhereInput
    /**
     * Limit how many Employees to update.
     */
    limit?: number
  }

  /**
   * Employee updateManyAndReturn
   */
  export type EmployeeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * The data used to update Employees.
     */
    data: XOR<EmployeeUpdateManyMutationInput, EmployeeUncheckedUpdateManyInput>
    /**
     * Filter which Employees to update
     */
    where?: EmployeeWhereInput
    /**
     * Limit how many Employees to update.
     */
    limit?: number
  }

  /**
   * Employee upsert
   */
  export type EmployeeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * The filter to search for the Employee to update in case it exists.
     */
    where: EmployeeWhereUniqueInput
    /**
     * In case the Employee found by the `where` argument doesn't exist, create a new Employee with this data.
     */
    create: XOR<EmployeeCreateInput, EmployeeUncheckedCreateInput>
    /**
     * In case the Employee was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmployeeUpdateInput, EmployeeUncheckedUpdateInput>
  }

  /**
   * Employee delete
   */
  export type EmployeeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter which Employee to delete.
     */
    where: EmployeeWhereUniqueInput
  }

  /**
   * Employee deleteMany
   */
  export type EmployeeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Employees to delete
     */
    where?: EmployeeWhereInput
    /**
     * Limit how many Employees to delete.
     */
    limit?: number
  }

  /**
   * Employee.doctorSchedules
   */
  export type Employee$doctorSchedulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoctorSchedule
     */
    select?: DoctorScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DoctorSchedule
     */
    omit?: DoctorScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorScheduleInclude<ExtArgs> | null
    where?: DoctorScheduleWhereInput
    orderBy?: DoctorScheduleOrderByWithRelationInput | DoctorScheduleOrderByWithRelationInput[]
    cursor?: DoctorScheduleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DoctorScheduleScalarFieldEnum | DoctorScheduleScalarFieldEnum[]
  }

  /**
   * Employee.reservations
   */
  export type Employee$reservationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reservation
     */
    select?: ReservationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reservation
     */
    omit?: ReservationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationInclude<ExtArgs> | null
    where?: ReservationWhereInput
    orderBy?: ReservationOrderByWithRelationInput | ReservationOrderByWithRelationInput[]
    cursor?: ReservationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReservationScalarFieldEnum | ReservationScalarFieldEnum[]
  }

  /**
   * Employee without action
   */
  export type EmployeeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
  }


  /**
   * Model Reservation
   */

  export type AggregateReservation = {
    _count: ReservationCountAggregateOutputType | null
    _avg: ReservationAvgAggregateOutputType | null
    _sum: ReservationSumAggregateOutputType | null
    _min: ReservationMinAggregateOutputType | null
    _max: ReservationMaxAggregateOutputType | null
  }

  export type ReservationAvgAggregateOutputType = {
    unitId: number | null
    queueNumber: number | null
    paymentMethodId: number | null
    doctorId: number | null
    referralSourceId: number | null
    educationId: number | null
  }

  export type ReservationSumAggregateOutputType = {
    unitId: number | null
    queueNumber: number | null
    paymentMethodId: number | null
    doctorId: number | null
    referralSourceId: number | null
    educationId: number | null
  }

  export type ReservationMinAggregateOutputType = {
    id: string | null
    isEnabled: boolean | null
    unitId: number | null
    identity: string | null
    queueNumber: number | null
    reservationNumber: string | null
    reservationDate: Date | null
    paymentMethodId: number | null
    bpjsNumber: string | null
    otherInsuranceNumber: string | null
    createdAt: Date | null
    referralNumber: string | null
    doctorId: number | null
    notes: string | null
    queueType: string | null
    referralSourceId: number | null
    isConfirmed: boolean | null
    callStatus: string | null
    isCancelled: boolean | null
    cancelReason: string | null
    educationId: number | null
    type: string | null
    patientType: string | null
  }

  export type ReservationMaxAggregateOutputType = {
    id: string | null
    isEnabled: boolean | null
    unitId: number | null
    identity: string | null
    queueNumber: number | null
    reservationNumber: string | null
    reservationDate: Date | null
    paymentMethodId: number | null
    bpjsNumber: string | null
    otherInsuranceNumber: string | null
    createdAt: Date | null
    referralNumber: string | null
    doctorId: number | null
    notes: string | null
    queueType: string | null
    referralSourceId: number | null
    isConfirmed: boolean | null
    callStatus: string | null
    isCancelled: boolean | null
    cancelReason: string | null
    educationId: number | null
    type: string | null
    patientType: string | null
  }

  export type ReservationCountAggregateOutputType = {
    id: number
    isEnabled: number
    unitId: number
    identity: number
    queueNumber: number
    reservationNumber: number
    reservationDate: number
    paymentMethodId: number
    bpjsNumber: number
    otherInsuranceNumber: number
    createdAt: number
    referralNumber: number
    doctorId: number
    notes: number
    queueType: number
    referralSourceId: number
    isConfirmed: number
    callStatus: number
    isCancelled: number
    cancelReason: number
    educationId: number
    type: number
    patientType: number
    _all: number
  }


  export type ReservationAvgAggregateInputType = {
    unitId?: true
    queueNumber?: true
    paymentMethodId?: true
    doctorId?: true
    referralSourceId?: true
    educationId?: true
  }

  export type ReservationSumAggregateInputType = {
    unitId?: true
    queueNumber?: true
    paymentMethodId?: true
    doctorId?: true
    referralSourceId?: true
    educationId?: true
  }

  export type ReservationMinAggregateInputType = {
    id?: true
    isEnabled?: true
    unitId?: true
    identity?: true
    queueNumber?: true
    reservationNumber?: true
    reservationDate?: true
    paymentMethodId?: true
    bpjsNumber?: true
    otherInsuranceNumber?: true
    createdAt?: true
    referralNumber?: true
    doctorId?: true
    notes?: true
    queueType?: true
    referralSourceId?: true
    isConfirmed?: true
    callStatus?: true
    isCancelled?: true
    cancelReason?: true
    educationId?: true
    type?: true
    patientType?: true
  }

  export type ReservationMaxAggregateInputType = {
    id?: true
    isEnabled?: true
    unitId?: true
    identity?: true
    queueNumber?: true
    reservationNumber?: true
    reservationDate?: true
    paymentMethodId?: true
    bpjsNumber?: true
    otherInsuranceNumber?: true
    createdAt?: true
    referralNumber?: true
    doctorId?: true
    notes?: true
    queueType?: true
    referralSourceId?: true
    isConfirmed?: true
    callStatus?: true
    isCancelled?: true
    cancelReason?: true
    educationId?: true
    type?: true
    patientType?: true
  }

  export type ReservationCountAggregateInputType = {
    id?: true
    isEnabled?: true
    unitId?: true
    identity?: true
    queueNumber?: true
    reservationNumber?: true
    reservationDate?: true
    paymentMethodId?: true
    bpjsNumber?: true
    otherInsuranceNumber?: true
    createdAt?: true
    referralNumber?: true
    doctorId?: true
    notes?: true
    queueType?: true
    referralSourceId?: true
    isConfirmed?: true
    callStatus?: true
    isCancelled?: true
    cancelReason?: true
    educationId?: true
    type?: true
    patientType?: true
    _all?: true
  }

  export type ReservationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Reservation to aggregate.
     */
    where?: ReservationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reservations to fetch.
     */
    orderBy?: ReservationOrderByWithRelationInput | ReservationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReservationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reservations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reservations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Reservations
    **/
    _count?: true | ReservationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReservationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReservationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReservationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReservationMaxAggregateInputType
  }

  export type GetReservationAggregateType<T extends ReservationAggregateArgs> = {
        [P in keyof T & keyof AggregateReservation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReservation[P]>
      : GetScalarType<T[P], AggregateReservation[P]>
  }




  export type ReservationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReservationWhereInput
    orderBy?: ReservationOrderByWithAggregationInput | ReservationOrderByWithAggregationInput[]
    by: ReservationScalarFieldEnum[] | ReservationScalarFieldEnum
    having?: ReservationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReservationCountAggregateInputType | true
    _avg?: ReservationAvgAggregateInputType
    _sum?: ReservationSumAggregateInputType
    _min?: ReservationMinAggregateInputType
    _max?: ReservationMaxAggregateInputType
  }

  export type ReservationGroupByOutputType = {
    id: string
    isEnabled: boolean
    unitId: number
    identity: string
    queueNumber: number
    reservationNumber: string
    reservationDate: Date
    paymentMethodId: number
    bpjsNumber: string | null
    otherInsuranceNumber: string | null
    createdAt: Date
    referralNumber: string | null
    doctorId: number | null
    notes: string | null
    queueType: string
    referralSourceId: number | null
    isConfirmed: boolean
    callStatus: string
    isCancelled: boolean
    cancelReason: string | null
    educationId: number | null
    type: string | null
    patientType: string | null
    _count: ReservationCountAggregateOutputType | null
    _avg: ReservationAvgAggregateOutputType | null
    _sum: ReservationSumAggregateOutputType | null
    _min: ReservationMinAggregateOutputType | null
    _max: ReservationMaxAggregateOutputType | null
  }

  type GetReservationGroupByPayload<T extends ReservationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReservationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReservationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReservationGroupByOutputType[P]>
            : GetScalarType<T[P], ReservationGroupByOutputType[P]>
        }
      >
    >


  export type ReservationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    isEnabled?: boolean
    unitId?: boolean
    identity?: boolean
    queueNumber?: boolean
    reservationNumber?: boolean
    reservationDate?: boolean
    paymentMethodId?: boolean
    bpjsNumber?: boolean
    otherInsuranceNumber?: boolean
    createdAt?: boolean
    referralNumber?: boolean
    doctorId?: boolean
    notes?: boolean
    queueType?: boolean
    referralSourceId?: boolean
    isConfirmed?: boolean
    callStatus?: boolean
    isCancelled?: boolean
    cancelReason?: boolean
    educationId?: boolean
    type?: boolean
    patientType?: boolean
    unit?: boolean | UnitDefaultArgs<ExtArgs>
    patient?: boolean | Reservation$patientArgs<ExtArgs>
    paymentMethod?: boolean | PaymentMethodDefaultArgs<ExtArgs>
    doctor?: boolean | Reservation$doctorArgs<ExtArgs>
    referralSource?: boolean | Reservation$referralSourceArgs<ExtArgs>
  }, ExtArgs["result"]["reservation"]>

  export type ReservationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    isEnabled?: boolean
    unitId?: boolean
    identity?: boolean
    queueNumber?: boolean
    reservationNumber?: boolean
    reservationDate?: boolean
    paymentMethodId?: boolean
    bpjsNumber?: boolean
    otherInsuranceNumber?: boolean
    createdAt?: boolean
    referralNumber?: boolean
    doctorId?: boolean
    notes?: boolean
    queueType?: boolean
    referralSourceId?: boolean
    isConfirmed?: boolean
    callStatus?: boolean
    isCancelled?: boolean
    cancelReason?: boolean
    educationId?: boolean
    type?: boolean
    patientType?: boolean
    unit?: boolean | UnitDefaultArgs<ExtArgs>
    patient?: boolean | Reservation$patientArgs<ExtArgs>
    paymentMethod?: boolean | PaymentMethodDefaultArgs<ExtArgs>
    doctor?: boolean | Reservation$doctorArgs<ExtArgs>
    referralSource?: boolean | Reservation$referralSourceArgs<ExtArgs>
  }, ExtArgs["result"]["reservation"]>

  export type ReservationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    isEnabled?: boolean
    unitId?: boolean
    identity?: boolean
    queueNumber?: boolean
    reservationNumber?: boolean
    reservationDate?: boolean
    paymentMethodId?: boolean
    bpjsNumber?: boolean
    otherInsuranceNumber?: boolean
    createdAt?: boolean
    referralNumber?: boolean
    doctorId?: boolean
    notes?: boolean
    queueType?: boolean
    referralSourceId?: boolean
    isConfirmed?: boolean
    callStatus?: boolean
    isCancelled?: boolean
    cancelReason?: boolean
    educationId?: boolean
    type?: boolean
    patientType?: boolean
    unit?: boolean | UnitDefaultArgs<ExtArgs>
    patient?: boolean | Reservation$patientArgs<ExtArgs>
    paymentMethod?: boolean | PaymentMethodDefaultArgs<ExtArgs>
    doctor?: boolean | Reservation$doctorArgs<ExtArgs>
    referralSource?: boolean | Reservation$referralSourceArgs<ExtArgs>
  }, ExtArgs["result"]["reservation"]>

  export type ReservationSelectScalar = {
    id?: boolean
    isEnabled?: boolean
    unitId?: boolean
    identity?: boolean
    queueNumber?: boolean
    reservationNumber?: boolean
    reservationDate?: boolean
    paymentMethodId?: boolean
    bpjsNumber?: boolean
    otherInsuranceNumber?: boolean
    createdAt?: boolean
    referralNumber?: boolean
    doctorId?: boolean
    notes?: boolean
    queueType?: boolean
    referralSourceId?: boolean
    isConfirmed?: boolean
    callStatus?: boolean
    isCancelled?: boolean
    cancelReason?: boolean
    educationId?: boolean
    type?: boolean
    patientType?: boolean
  }

  export type ReservationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "isEnabled" | "unitId" | "identity" | "queueNumber" | "reservationNumber" | "reservationDate" | "paymentMethodId" | "bpjsNumber" | "otherInsuranceNumber" | "createdAt" | "referralNumber" | "doctorId" | "notes" | "queueType" | "referralSourceId" | "isConfirmed" | "callStatus" | "isCancelled" | "cancelReason" | "educationId" | "type" | "patientType", ExtArgs["result"]["reservation"]>
  export type ReservationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    unit?: boolean | UnitDefaultArgs<ExtArgs>
    patient?: boolean | Reservation$patientArgs<ExtArgs>
    paymentMethod?: boolean | PaymentMethodDefaultArgs<ExtArgs>
    doctor?: boolean | Reservation$doctorArgs<ExtArgs>
    referralSource?: boolean | Reservation$referralSourceArgs<ExtArgs>
  }
  export type ReservationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    unit?: boolean | UnitDefaultArgs<ExtArgs>
    patient?: boolean | Reservation$patientArgs<ExtArgs>
    paymentMethod?: boolean | PaymentMethodDefaultArgs<ExtArgs>
    doctor?: boolean | Reservation$doctorArgs<ExtArgs>
    referralSource?: boolean | Reservation$referralSourceArgs<ExtArgs>
  }
  export type ReservationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    unit?: boolean | UnitDefaultArgs<ExtArgs>
    patient?: boolean | Reservation$patientArgs<ExtArgs>
    paymentMethod?: boolean | PaymentMethodDefaultArgs<ExtArgs>
    doctor?: boolean | Reservation$doctorArgs<ExtArgs>
    referralSource?: boolean | Reservation$referralSourceArgs<ExtArgs>
  }

  export type $ReservationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Reservation"
    objects: {
      unit: Prisma.$UnitPayload<ExtArgs>
      patient: Prisma.$PatientPayload<ExtArgs> | null
      paymentMethod: Prisma.$PaymentMethodPayload<ExtArgs>
      doctor: Prisma.$EmployeePayload<ExtArgs> | null
      referralSource: Prisma.$ReferralSourcePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      isEnabled: boolean
      unitId: number
      identity: string
      queueNumber: number
      reservationNumber: string
      reservationDate: Date
      paymentMethodId: number
      bpjsNumber: string | null
      otherInsuranceNumber: string | null
      createdAt: Date
      referralNumber: string | null
      doctorId: number | null
      notes: string | null
      queueType: string
      referralSourceId: number | null
      isConfirmed: boolean
      callStatus: string
      isCancelled: boolean
      cancelReason: string | null
      educationId: number | null
      type: string | null
      patientType: string | null
    }, ExtArgs["result"]["reservation"]>
    composites: {}
  }

  type ReservationGetPayload<S extends boolean | null | undefined | ReservationDefaultArgs> = $Result.GetResult<Prisma.$ReservationPayload, S>

  type ReservationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ReservationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ReservationCountAggregateInputType | true
    }

  export interface ReservationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Reservation'], meta: { name: 'Reservation' } }
    /**
     * Find zero or one Reservation that matches the filter.
     * @param {ReservationFindUniqueArgs} args - Arguments to find a Reservation
     * @example
     * // Get one Reservation
     * const reservation = await prisma.reservation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReservationFindUniqueArgs>(args: SelectSubset<T, ReservationFindUniqueArgs<ExtArgs>>): Prisma__ReservationClient<$Result.GetResult<Prisma.$ReservationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Reservation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ReservationFindUniqueOrThrowArgs} args - Arguments to find a Reservation
     * @example
     * // Get one Reservation
     * const reservation = await prisma.reservation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReservationFindUniqueOrThrowArgs>(args: SelectSubset<T, ReservationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReservationClient<$Result.GetResult<Prisma.$ReservationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Reservation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReservationFindFirstArgs} args - Arguments to find a Reservation
     * @example
     * // Get one Reservation
     * const reservation = await prisma.reservation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReservationFindFirstArgs>(args?: SelectSubset<T, ReservationFindFirstArgs<ExtArgs>>): Prisma__ReservationClient<$Result.GetResult<Prisma.$ReservationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Reservation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReservationFindFirstOrThrowArgs} args - Arguments to find a Reservation
     * @example
     * // Get one Reservation
     * const reservation = await prisma.reservation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReservationFindFirstOrThrowArgs>(args?: SelectSubset<T, ReservationFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReservationClient<$Result.GetResult<Prisma.$ReservationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Reservations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReservationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reservations
     * const reservations = await prisma.reservation.findMany()
     * 
     * // Get first 10 Reservations
     * const reservations = await prisma.reservation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reservationWithIdOnly = await prisma.reservation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReservationFindManyArgs>(args?: SelectSubset<T, ReservationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReservationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Reservation.
     * @param {ReservationCreateArgs} args - Arguments to create a Reservation.
     * @example
     * // Create one Reservation
     * const Reservation = await prisma.reservation.create({
     *   data: {
     *     // ... data to create a Reservation
     *   }
     * })
     * 
     */
    create<T extends ReservationCreateArgs>(args: SelectSubset<T, ReservationCreateArgs<ExtArgs>>): Prisma__ReservationClient<$Result.GetResult<Prisma.$ReservationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Reservations.
     * @param {ReservationCreateManyArgs} args - Arguments to create many Reservations.
     * @example
     * // Create many Reservations
     * const reservation = await prisma.reservation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReservationCreateManyArgs>(args?: SelectSubset<T, ReservationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Reservations and returns the data saved in the database.
     * @param {ReservationCreateManyAndReturnArgs} args - Arguments to create many Reservations.
     * @example
     * // Create many Reservations
     * const reservation = await prisma.reservation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Reservations and only return the `id`
     * const reservationWithIdOnly = await prisma.reservation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReservationCreateManyAndReturnArgs>(args?: SelectSubset<T, ReservationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReservationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Reservation.
     * @param {ReservationDeleteArgs} args - Arguments to delete one Reservation.
     * @example
     * // Delete one Reservation
     * const Reservation = await prisma.reservation.delete({
     *   where: {
     *     // ... filter to delete one Reservation
     *   }
     * })
     * 
     */
    delete<T extends ReservationDeleteArgs>(args: SelectSubset<T, ReservationDeleteArgs<ExtArgs>>): Prisma__ReservationClient<$Result.GetResult<Prisma.$ReservationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Reservation.
     * @param {ReservationUpdateArgs} args - Arguments to update one Reservation.
     * @example
     * // Update one Reservation
     * const reservation = await prisma.reservation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReservationUpdateArgs>(args: SelectSubset<T, ReservationUpdateArgs<ExtArgs>>): Prisma__ReservationClient<$Result.GetResult<Prisma.$ReservationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Reservations.
     * @param {ReservationDeleteManyArgs} args - Arguments to filter Reservations to delete.
     * @example
     * // Delete a few Reservations
     * const { count } = await prisma.reservation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReservationDeleteManyArgs>(args?: SelectSubset<T, ReservationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reservations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReservationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reservations
     * const reservation = await prisma.reservation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReservationUpdateManyArgs>(args: SelectSubset<T, ReservationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reservations and returns the data updated in the database.
     * @param {ReservationUpdateManyAndReturnArgs} args - Arguments to update many Reservations.
     * @example
     * // Update many Reservations
     * const reservation = await prisma.reservation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Reservations and only return the `id`
     * const reservationWithIdOnly = await prisma.reservation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ReservationUpdateManyAndReturnArgs>(args: SelectSubset<T, ReservationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReservationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Reservation.
     * @param {ReservationUpsertArgs} args - Arguments to update or create a Reservation.
     * @example
     * // Update or create a Reservation
     * const reservation = await prisma.reservation.upsert({
     *   create: {
     *     // ... data to create a Reservation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Reservation we want to update
     *   }
     * })
     */
    upsert<T extends ReservationUpsertArgs>(args: SelectSubset<T, ReservationUpsertArgs<ExtArgs>>): Prisma__ReservationClient<$Result.GetResult<Prisma.$ReservationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Reservations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReservationCountArgs} args - Arguments to filter Reservations to count.
     * @example
     * // Count the number of Reservations
     * const count = await prisma.reservation.count({
     *   where: {
     *     // ... the filter for the Reservations we want to count
     *   }
     * })
    **/
    count<T extends ReservationCountArgs>(
      args?: Subset<T, ReservationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReservationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Reservation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReservationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReservationAggregateArgs>(args: Subset<T, ReservationAggregateArgs>): Prisma.PrismaPromise<GetReservationAggregateType<T>>

    /**
     * Group by Reservation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReservationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReservationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReservationGroupByArgs['orderBy'] }
        : { orderBy?: ReservationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReservationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReservationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Reservation model
   */
  readonly fields: ReservationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Reservation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReservationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    unit<T extends UnitDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UnitDefaultArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    patient<T extends Reservation$patientArgs<ExtArgs> = {}>(args?: Subset<T, Reservation$patientArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    paymentMethod<T extends PaymentMethodDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PaymentMethodDefaultArgs<ExtArgs>>): Prisma__PaymentMethodClient<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    doctor<T extends Reservation$doctorArgs<ExtArgs> = {}>(args?: Subset<T, Reservation$doctorArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    referralSource<T extends Reservation$referralSourceArgs<ExtArgs> = {}>(args?: Subset<T, Reservation$referralSourceArgs<ExtArgs>>): Prisma__ReferralSourceClient<$Result.GetResult<Prisma.$ReferralSourcePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Reservation model
   */
  interface ReservationFieldRefs {
    readonly id: FieldRef<"Reservation", 'String'>
    readonly isEnabled: FieldRef<"Reservation", 'Boolean'>
    readonly unitId: FieldRef<"Reservation", 'Int'>
    readonly identity: FieldRef<"Reservation", 'String'>
    readonly queueNumber: FieldRef<"Reservation", 'Int'>
    readonly reservationNumber: FieldRef<"Reservation", 'String'>
    readonly reservationDate: FieldRef<"Reservation", 'DateTime'>
    readonly paymentMethodId: FieldRef<"Reservation", 'Int'>
    readonly bpjsNumber: FieldRef<"Reservation", 'String'>
    readonly otherInsuranceNumber: FieldRef<"Reservation", 'String'>
    readonly createdAt: FieldRef<"Reservation", 'DateTime'>
    readonly referralNumber: FieldRef<"Reservation", 'String'>
    readonly doctorId: FieldRef<"Reservation", 'Int'>
    readonly notes: FieldRef<"Reservation", 'String'>
    readonly queueType: FieldRef<"Reservation", 'String'>
    readonly referralSourceId: FieldRef<"Reservation", 'Int'>
    readonly isConfirmed: FieldRef<"Reservation", 'Boolean'>
    readonly callStatus: FieldRef<"Reservation", 'String'>
    readonly isCancelled: FieldRef<"Reservation", 'Boolean'>
    readonly cancelReason: FieldRef<"Reservation", 'String'>
    readonly educationId: FieldRef<"Reservation", 'Int'>
    readonly type: FieldRef<"Reservation", 'String'>
    readonly patientType: FieldRef<"Reservation", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Reservation findUnique
   */
  export type ReservationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reservation
     */
    select?: ReservationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reservation
     */
    omit?: ReservationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationInclude<ExtArgs> | null
    /**
     * Filter, which Reservation to fetch.
     */
    where: ReservationWhereUniqueInput
  }

  /**
   * Reservation findUniqueOrThrow
   */
  export type ReservationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reservation
     */
    select?: ReservationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reservation
     */
    omit?: ReservationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationInclude<ExtArgs> | null
    /**
     * Filter, which Reservation to fetch.
     */
    where: ReservationWhereUniqueInput
  }

  /**
   * Reservation findFirst
   */
  export type ReservationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reservation
     */
    select?: ReservationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reservation
     */
    omit?: ReservationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationInclude<ExtArgs> | null
    /**
     * Filter, which Reservation to fetch.
     */
    where?: ReservationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reservations to fetch.
     */
    orderBy?: ReservationOrderByWithRelationInput | ReservationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reservations.
     */
    cursor?: ReservationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reservations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reservations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reservations.
     */
    distinct?: ReservationScalarFieldEnum | ReservationScalarFieldEnum[]
  }

  /**
   * Reservation findFirstOrThrow
   */
  export type ReservationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reservation
     */
    select?: ReservationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reservation
     */
    omit?: ReservationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationInclude<ExtArgs> | null
    /**
     * Filter, which Reservation to fetch.
     */
    where?: ReservationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reservations to fetch.
     */
    orderBy?: ReservationOrderByWithRelationInput | ReservationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reservations.
     */
    cursor?: ReservationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reservations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reservations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reservations.
     */
    distinct?: ReservationScalarFieldEnum | ReservationScalarFieldEnum[]
  }

  /**
   * Reservation findMany
   */
  export type ReservationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reservation
     */
    select?: ReservationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reservation
     */
    omit?: ReservationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationInclude<ExtArgs> | null
    /**
     * Filter, which Reservations to fetch.
     */
    where?: ReservationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reservations to fetch.
     */
    orderBy?: ReservationOrderByWithRelationInput | ReservationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Reservations.
     */
    cursor?: ReservationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reservations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reservations.
     */
    skip?: number
    distinct?: ReservationScalarFieldEnum | ReservationScalarFieldEnum[]
  }

  /**
   * Reservation create
   */
  export type ReservationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reservation
     */
    select?: ReservationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reservation
     */
    omit?: ReservationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationInclude<ExtArgs> | null
    /**
     * The data needed to create a Reservation.
     */
    data: XOR<ReservationCreateInput, ReservationUncheckedCreateInput>
  }

  /**
   * Reservation createMany
   */
  export type ReservationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Reservations.
     */
    data: ReservationCreateManyInput | ReservationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Reservation createManyAndReturn
   */
  export type ReservationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reservation
     */
    select?: ReservationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Reservation
     */
    omit?: ReservationOmit<ExtArgs> | null
    /**
     * The data used to create many Reservations.
     */
    data: ReservationCreateManyInput | ReservationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Reservation update
   */
  export type ReservationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reservation
     */
    select?: ReservationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reservation
     */
    omit?: ReservationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationInclude<ExtArgs> | null
    /**
     * The data needed to update a Reservation.
     */
    data: XOR<ReservationUpdateInput, ReservationUncheckedUpdateInput>
    /**
     * Choose, which Reservation to update.
     */
    where: ReservationWhereUniqueInput
  }

  /**
   * Reservation updateMany
   */
  export type ReservationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Reservations.
     */
    data: XOR<ReservationUpdateManyMutationInput, ReservationUncheckedUpdateManyInput>
    /**
     * Filter which Reservations to update
     */
    where?: ReservationWhereInput
    /**
     * Limit how many Reservations to update.
     */
    limit?: number
  }

  /**
   * Reservation updateManyAndReturn
   */
  export type ReservationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reservation
     */
    select?: ReservationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Reservation
     */
    omit?: ReservationOmit<ExtArgs> | null
    /**
     * The data used to update Reservations.
     */
    data: XOR<ReservationUpdateManyMutationInput, ReservationUncheckedUpdateManyInput>
    /**
     * Filter which Reservations to update
     */
    where?: ReservationWhereInput
    /**
     * Limit how many Reservations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Reservation upsert
   */
  export type ReservationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reservation
     */
    select?: ReservationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reservation
     */
    omit?: ReservationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationInclude<ExtArgs> | null
    /**
     * The filter to search for the Reservation to update in case it exists.
     */
    where: ReservationWhereUniqueInput
    /**
     * In case the Reservation found by the `where` argument doesn't exist, create a new Reservation with this data.
     */
    create: XOR<ReservationCreateInput, ReservationUncheckedCreateInput>
    /**
     * In case the Reservation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReservationUpdateInput, ReservationUncheckedUpdateInput>
  }

  /**
   * Reservation delete
   */
  export type ReservationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reservation
     */
    select?: ReservationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reservation
     */
    omit?: ReservationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationInclude<ExtArgs> | null
    /**
     * Filter which Reservation to delete.
     */
    where: ReservationWhereUniqueInput
  }

  /**
   * Reservation deleteMany
   */
  export type ReservationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Reservations to delete
     */
    where?: ReservationWhereInput
    /**
     * Limit how many Reservations to delete.
     */
    limit?: number
  }

  /**
   * Reservation.patient
   */
  export type Reservation$patientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    where?: PatientWhereInput
  }

  /**
   * Reservation.doctor
   */
  export type Reservation$doctorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    where?: EmployeeWhereInput
  }

  /**
   * Reservation.referralSource
   */
  export type Reservation$referralSourceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferralSource
     */
    select?: ReferralSourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReferralSource
     */
    omit?: ReferralSourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralSourceInclude<ExtArgs> | null
    where?: ReferralSourceWhereInput
  }

  /**
   * Reservation without action
   */
  export type ReservationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reservation
     */
    select?: ReservationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reservation
     */
    omit?: ReservationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationInclude<ExtArgs> | null
  }


  /**
   * Model Patient
   */

  export type AggregatePatient = {
    _count: PatientCountAggregateOutputType | null
    _avg: PatientAvgAggregateOutputType | null
    _sum: PatientSumAggregateOutputType | null
    _min: PatientMinAggregateOutputType | null
    _max: PatientMaxAggregateOutputType | null
  }

  export type PatientAvgAggregateOutputType = {
    id: number | null
    genderId: number | null
  }

  export type PatientSumAggregateOutputType = {
    id: number | null
    genderId: number | null
  }

  export type PatientMinAggregateOutputType = {
    id: number | null
    isEnabled: boolean | null
    name: string | null
    identity: string | null
    genderId: number | null
    birthPlace: string | null
    birthDate: Date | null
    motherName: string | null
    fatherName: string | null
    spouseName: string | null
    bpjsNumber: string | null
    otherInsuranceNumber: string | null
    phoneNumber: string | null
    registeredAt: Date | null
    homeAddress: string | null
  }

  export type PatientMaxAggregateOutputType = {
    id: number | null
    isEnabled: boolean | null
    name: string | null
    identity: string | null
    genderId: number | null
    birthPlace: string | null
    birthDate: Date | null
    motherName: string | null
    fatherName: string | null
    spouseName: string | null
    bpjsNumber: string | null
    otherInsuranceNumber: string | null
    phoneNumber: string | null
    registeredAt: Date | null
    homeAddress: string | null
  }

  export type PatientCountAggregateOutputType = {
    id: number
    isEnabled: number
    name: number
    identity: number
    genderId: number
    birthPlace: number
    birthDate: number
    motherName: number
    fatherName: number
    spouseName: number
    bpjsNumber: number
    otherInsuranceNumber: number
    phoneNumber: number
    registeredAt: number
    homeAddress: number
    _all: number
  }


  export type PatientAvgAggregateInputType = {
    id?: true
    genderId?: true
  }

  export type PatientSumAggregateInputType = {
    id?: true
    genderId?: true
  }

  export type PatientMinAggregateInputType = {
    id?: true
    isEnabled?: true
    name?: true
    identity?: true
    genderId?: true
    birthPlace?: true
    birthDate?: true
    motherName?: true
    fatherName?: true
    spouseName?: true
    bpjsNumber?: true
    otherInsuranceNumber?: true
    phoneNumber?: true
    registeredAt?: true
    homeAddress?: true
  }

  export type PatientMaxAggregateInputType = {
    id?: true
    isEnabled?: true
    name?: true
    identity?: true
    genderId?: true
    birthPlace?: true
    birthDate?: true
    motherName?: true
    fatherName?: true
    spouseName?: true
    bpjsNumber?: true
    otherInsuranceNumber?: true
    phoneNumber?: true
    registeredAt?: true
    homeAddress?: true
  }

  export type PatientCountAggregateInputType = {
    id?: true
    isEnabled?: true
    name?: true
    identity?: true
    genderId?: true
    birthPlace?: true
    birthDate?: true
    motherName?: true
    fatherName?: true
    spouseName?: true
    bpjsNumber?: true
    otherInsuranceNumber?: true
    phoneNumber?: true
    registeredAt?: true
    homeAddress?: true
    _all?: true
  }

  export type PatientAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Patient to aggregate.
     */
    where?: PatientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Patients to fetch.
     */
    orderBy?: PatientOrderByWithRelationInput | PatientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PatientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Patients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Patients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Patients
    **/
    _count?: true | PatientCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PatientAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PatientSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PatientMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PatientMaxAggregateInputType
  }

  export type GetPatientAggregateType<T extends PatientAggregateArgs> = {
        [P in keyof T & keyof AggregatePatient]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePatient[P]>
      : GetScalarType<T[P], AggregatePatient[P]>
  }




  export type PatientGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PatientWhereInput
    orderBy?: PatientOrderByWithAggregationInput | PatientOrderByWithAggregationInput[]
    by: PatientScalarFieldEnum[] | PatientScalarFieldEnum
    having?: PatientScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PatientCountAggregateInputType | true
    _avg?: PatientAvgAggregateInputType
    _sum?: PatientSumAggregateInputType
    _min?: PatientMinAggregateInputType
    _max?: PatientMaxAggregateInputType
  }

  export type PatientGroupByOutputType = {
    id: number
    isEnabled: boolean
    name: string | null
    identity: string
    genderId: number | null
    birthPlace: string | null
    birthDate: Date | null
    motherName: string | null
    fatherName: string | null
    spouseName: string | null
    bpjsNumber: string | null
    otherInsuranceNumber: string | null
    phoneNumber: string | null
    registeredAt: Date | null
    homeAddress: string | null
    _count: PatientCountAggregateOutputType | null
    _avg: PatientAvgAggregateOutputType | null
    _sum: PatientSumAggregateOutputType | null
    _min: PatientMinAggregateOutputType | null
    _max: PatientMaxAggregateOutputType | null
  }

  type GetPatientGroupByPayload<T extends PatientGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PatientGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PatientGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PatientGroupByOutputType[P]>
            : GetScalarType<T[P], PatientGroupByOutputType[P]>
        }
      >
    >


  export type PatientSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    isEnabled?: boolean
    name?: boolean
    identity?: boolean
    genderId?: boolean
    birthPlace?: boolean
    birthDate?: boolean
    motherName?: boolean
    fatherName?: boolean
    spouseName?: boolean
    bpjsNumber?: boolean
    otherInsuranceNumber?: boolean
    phoneNumber?: boolean
    registeredAt?: boolean
    homeAddress?: boolean
    gender?: boolean | Patient$genderArgs<ExtArgs>
    reservations?: boolean | Patient$reservationsArgs<ExtArgs>
    _count?: boolean | PatientCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["patient"]>

  export type PatientSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    isEnabled?: boolean
    name?: boolean
    identity?: boolean
    genderId?: boolean
    birthPlace?: boolean
    birthDate?: boolean
    motherName?: boolean
    fatherName?: boolean
    spouseName?: boolean
    bpjsNumber?: boolean
    otherInsuranceNumber?: boolean
    phoneNumber?: boolean
    registeredAt?: boolean
    homeAddress?: boolean
    gender?: boolean | Patient$genderArgs<ExtArgs>
  }, ExtArgs["result"]["patient"]>

  export type PatientSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    isEnabled?: boolean
    name?: boolean
    identity?: boolean
    genderId?: boolean
    birthPlace?: boolean
    birthDate?: boolean
    motherName?: boolean
    fatherName?: boolean
    spouseName?: boolean
    bpjsNumber?: boolean
    otherInsuranceNumber?: boolean
    phoneNumber?: boolean
    registeredAt?: boolean
    homeAddress?: boolean
    gender?: boolean | Patient$genderArgs<ExtArgs>
  }, ExtArgs["result"]["patient"]>

  export type PatientSelectScalar = {
    id?: boolean
    isEnabled?: boolean
    name?: boolean
    identity?: boolean
    genderId?: boolean
    birthPlace?: boolean
    birthDate?: boolean
    motherName?: boolean
    fatherName?: boolean
    spouseName?: boolean
    bpjsNumber?: boolean
    otherInsuranceNumber?: boolean
    phoneNumber?: boolean
    registeredAt?: boolean
    homeAddress?: boolean
  }

  export type PatientOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "isEnabled" | "name" | "identity" | "genderId" | "birthPlace" | "birthDate" | "motherName" | "fatherName" | "spouseName" | "bpjsNumber" | "otherInsuranceNumber" | "phoneNumber" | "registeredAt" | "homeAddress", ExtArgs["result"]["patient"]>
  export type PatientInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    gender?: boolean | Patient$genderArgs<ExtArgs>
    reservations?: boolean | Patient$reservationsArgs<ExtArgs>
    _count?: boolean | PatientCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PatientIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    gender?: boolean | Patient$genderArgs<ExtArgs>
  }
  export type PatientIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    gender?: boolean | Patient$genderArgs<ExtArgs>
  }

  export type $PatientPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Patient"
    objects: {
      gender: Prisma.$GenderPayload<ExtArgs> | null
      reservations: Prisma.$ReservationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      isEnabled: boolean
      name: string | null
      identity: string
      genderId: number | null
      birthPlace: string | null
      birthDate: Date | null
      motherName: string | null
      fatherName: string | null
      spouseName: string | null
      bpjsNumber: string | null
      otherInsuranceNumber: string | null
      phoneNumber: string | null
      registeredAt: Date | null
      homeAddress: string | null
    }, ExtArgs["result"]["patient"]>
    composites: {}
  }

  type PatientGetPayload<S extends boolean | null | undefined | PatientDefaultArgs> = $Result.GetResult<Prisma.$PatientPayload, S>

  type PatientCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PatientFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PatientCountAggregateInputType | true
    }

  export interface PatientDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Patient'], meta: { name: 'Patient' } }
    /**
     * Find zero or one Patient that matches the filter.
     * @param {PatientFindUniqueArgs} args - Arguments to find a Patient
     * @example
     * // Get one Patient
     * const patient = await prisma.patient.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PatientFindUniqueArgs>(args: SelectSubset<T, PatientFindUniqueArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Patient that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PatientFindUniqueOrThrowArgs} args - Arguments to find a Patient
     * @example
     * // Get one Patient
     * const patient = await prisma.patient.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PatientFindUniqueOrThrowArgs>(args: SelectSubset<T, PatientFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Patient that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientFindFirstArgs} args - Arguments to find a Patient
     * @example
     * // Get one Patient
     * const patient = await prisma.patient.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PatientFindFirstArgs>(args?: SelectSubset<T, PatientFindFirstArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Patient that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientFindFirstOrThrowArgs} args - Arguments to find a Patient
     * @example
     * // Get one Patient
     * const patient = await prisma.patient.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PatientFindFirstOrThrowArgs>(args?: SelectSubset<T, PatientFindFirstOrThrowArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Patients that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Patients
     * const patients = await prisma.patient.findMany()
     * 
     * // Get first 10 Patients
     * const patients = await prisma.patient.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const patientWithIdOnly = await prisma.patient.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PatientFindManyArgs>(args?: SelectSubset<T, PatientFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Patient.
     * @param {PatientCreateArgs} args - Arguments to create a Patient.
     * @example
     * // Create one Patient
     * const Patient = await prisma.patient.create({
     *   data: {
     *     // ... data to create a Patient
     *   }
     * })
     * 
     */
    create<T extends PatientCreateArgs>(args: SelectSubset<T, PatientCreateArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Patients.
     * @param {PatientCreateManyArgs} args - Arguments to create many Patients.
     * @example
     * // Create many Patients
     * const patient = await prisma.patient.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PatientCreateManyArgs>(args?: SelectSubset<T, PatientCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Patients and returns the data saved in the database.
     * @param {PatientCreateManyAndReturnArgs} args - Arguments to create many Patients.
     * @example
     * // Create many Patients
     * const patient = await prisma.patient.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Patients and only return the `id`
     * const patientWithIdOnly = await prisma.patient.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PatientCreateManyAndReturnArgs>(args?: SelectSubset<T, PatientCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Patient.
     * @param {PatientDeleteArgs} args - Arguments to delete one Patient.
     * @example
     * // Delete one Patient
     * const Patient = await prisma.patient.delete({
     *   where: {
     *     // ... filter to delete one Patient
     *   }
     * })
     * 
     */
    delete<T extends PatientDeleteArgs>(args: SelectSubset<T, PatientDeleteArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Patient.
     * @param {PatientUpdateArgs} args - Arguments to update one Patient.
     * @example
     * // Update one Patient
     * const patient = await prisma.patient.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PatientUpdateArgs>(args: SelectSubset<T, PatientUpdateArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Patients.
     * @param {PatientDeleteManyArgs} args - Arguments to filter Patients to delete.
     * @example
     * // Delete a few Patients
     * const { count } = await prisma.patient.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PatientDeleteManyArgs>(args?: SelectSubset<T, PatientDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Patients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Patients
     * const patient = await prisma.patient.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PatientUpdateManyArgs>(args: SelectSubset<T, PatientUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Patients and returns the data updated in the database.
     * @param {PatientUpdateManyAndReturnArgs} args - Arguments to update many Patients.
     * @example
     * // Update many Patients
     * const patient = await prisma.patient.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Patients and only return the `id`
     * const patientWithIdOnly = await prisma.patient.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PatientUpdateManyAndReturnArgs>(args: SelectSubset<T, PatientUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Patient.
     * @param {PatientUpsertArgs} args - Arguments to update or create a Patient.
     * @example
     * // Update or create a Patient
     * const patient = await prisma.patient.upsert({
     *   create: {
     *     // ... data to create a Patient
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Patient we want to update
     *   }
     * })
     */
    upsert<T extends PatientUpsertArgs>(args: SelectSubset<T, PatientUpsertArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Patients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientCountArgs} args - Arguments to filter Patients to count.
     * @example
     * // Count the number of Patients
     * const count = await prisma.patient.count({
     *   where: {
     *     // ... the filter for the Patients we want to count
     *   }
     * })
    **/
    count<T extends PatientCountArgs>(
      args?: Subset<T, PatientCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PatientCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Patient.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PatientAggregateArgs>(args: Subset<T, PatientAggregateArgs>): Prisma.PrismaPromise<GetPatientAggregateType<T>>

    /**
     * Group by Patient.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PatientGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PatientGroupByArgs['orderBy'] }
        : { orderBy?: PatientGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PatientGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPatientGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Patient model
   */
  readonly fields: PatientFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Patient.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PatientClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    gender<T extends Patient$genderArgs<ExtArgs> = {}>(args?: Subset<T, Patient$genderArgs<ExtArgs>>): Prisma__GenderClient<$Result.GetResult<Prisma.$GenderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    reservations<T extends Patient$reservationsArgs<ExtArgs> = {}>(args?: Subset<T, Patient$reservationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReservationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Patient model
   */
  interface PatientFieldRefs {
    readonly id: FieldRef<"Patient", 'Int'>
    readonly isEnabled: FieldRef<"Patient", 'Boolean'>
    readonly name: FieldRef<"Patient", 'String'>
    readonly identity: FieldRef<"Patient", 'String'>
    readonly genderId: FieldRef<"Patient", 'Int'>
    readonly birthPlace: FieldRef<"Patient", 'String'>
    readonly birthDate: FieldRef<"Patient", 'DateTime'>
    readonly motherName: FieldRef<"Patient", 'String'>
    readonly fatherName: FieldRef<"Patient", 'String'>
    readonly spouseName: FieldRef<"Patient", 'String'>
    readonly bpjsNumber: FieldRef<"Patient", 'String'>
    readonly otherInsuranceNumber: FieldRef<"Patient", 'String'>
    readonly phoneNumber: FieldRef<"Patient", 'String'>
    readonly registeredAt: FieldRef<"Patient", 'DateTime'>
    readonly homeAddress: FieldRef<"Patient", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Patient findUnique
   */
  export type PatientFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * Filter, which Patient to fetch.
     */
    where: PatientWhereUniqueInput
  }

  /**
   * Patient findUniqueOrThrow
   */
  export type PatientFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * Filter, which Patient to fetch.
     */
    where: PatientWhereUniqueInput
  }

  /**
   * Patient findFirst
   */
  export type PatientFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * Filter, which Patient to fetch.
     */
    where?: PatientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Patients to fetch.
     */
    orderBy?: PatientOrderByWithRelationInput | PatientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Patients.
     */
    cursor?: PatientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Patients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Patients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Patients.
     */
    distinct?: PatientScalarFieldEnum | PatientScalarFieldEnum[]
  }

  /**
   * Patient findFirstOrThrow
   */
  export type PatientFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * Filter, which Patient to fetch.
     */
    where?: PatientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Patients to fetch.
     */
    orderBy?: PatientOrderByWithRelationInput | PatientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Patients.
     */
    cursor?: PatientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Patients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Patients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Patients.
     */
    distinct?: PatientScalarFieldEnum | PatientScalarFieldEnum[]
  }

  /**
   * Patient findMany
   */
  export type PatientFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * Filter, which Patients to fetch.
     */
    where?: PatientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Patients to fetch.
     */
    orderBy?: PatientOrderByWithRelationInput | PatientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Patients.
     */
    cursor?: PatientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Patients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Patients.
     */
    skip?: number
    distinct?: PatientScalarFieldEnum | PatientScalarFieldEnum[]
  }

  /**
   * Patient create
   */
  export type PatientCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * The data needed to create a Patient.
     */
    data: XOR<PatientCreateInput, PatientUncheckedCreateInput>
  }

  /**
   * Patient createMany
   */
  export type PatientCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Patients.
     */
    data: PatientCreateManyInput | PatientCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Patient createManyAndReturn
   */
  export type PatientCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * The data used to create many Patients.
     */
    data: PatientCreateManyInput | PatientCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Patient update
   */
  export type PatientUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * The data needed to update a Patient.
     */
    data: XOR<PatientUpdateInput, PatientUncheckedUpdateInput>
    /**
     * Choose, which Patient to update.
     */
    where: PatientWhereUniqueInput
  }

  /**
   * Patient updateMany
   */
  export type PatientUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Patients.
     */
    data: XOR<PatientUpdateManyMutationInput, PatientUncheckedUpdateManyInput>
    /**
     * Filter which Patients to update
     */
    where?: PatientWhereInput
    /**
     * Limit how many Patients to update.
     */
    limit?: number
  }

  /**
   * Patient updateManyAndReturn
   */
  export type PatientUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * The data used to update Patients.
     */
    data: XOR<PatientUpdateManyMutationInput, PatientUncheckedUpdateManyInput>
    /**
     * Filter which Patients to update
     */
    where?: PatientWhereInput
    /**
     * Limit how many Patients to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Patient upsert
   */
  export type PatientUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * The filter to search for the Patient to update in case it exists.
     */
    where: PatientWhereUniqueInput
    /**
     * In case the Patient found by the `where` argument doesn't exist, create a new Patient with this data.
     */
    create: XOR<PatientCreateInput, PatientUncheckedCreateInput>
    /**
     * In case the Patient was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PatientUpdateInput, PatientUncheckedUpdateInput>
  }

  /**
   * Patient delete
   */
  export type PatientDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * Filter which Patient to delete.
     */
    where: PatientWhereUniqueInput
  }

  /**
   * Patient deleteMany
   */
  export type PatientDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Patients to delete
     */
    where?: PatientWhereInput
    /**
     * Limit how many Patients to delete.
     */
    limit?: number
  }

  /**
   * Patient.gender
   */
  export type Patient$genderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gender
     */
    select?: GenderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Gender
     */
    omit?: GenderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GenderInclude<ExtArgs> | null
    where?: GenderWhereInput
  }

  /**
   * Patient.reservations
   */
  export type Patient$reservationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reservation
     */
    select?: ReservationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reservation
     */
    omit?: ReservationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationInclude<ExtArgs> | null
    where?: ReservationWhereInput
    orderBy?: ReservationOrderByWithRelationInput | ReservationOrderByWithRelationInput[]
    cursor?: ReservationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReservationScalarFieldEnum | ReservationScalarFieldEnum[]
  }

  /**
   * Patient without action
   */
  export type PatientDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
  }


  /**
   * Model Gender
   */

  export type AggregateGender = {
    _count: GenderCountAggregateOutputType | null
    _avg: GenderAvgAggregateOutputType | null
    _sum: GenderSumAggregateOutputType | null
    _min: GenderMinAggregateOutputType | null
    _max: GenderMaxAggregateOutputType | null
  }

  export type GenderAvgAggregateOutputType = {
    id: number | null
  }

  export type GenderSumAggregateOutputType = {
    id: number | null
  }

  export type GenderMinAggregateOutputType = {
    id: number | null
    gender: string | null
    isEnabled: boolean | null
  }

  export type GenderMaxAggregateOutputType = {
    id: number | null
    gender: string | null
    isEnabled: boolean | null
  }

  export type GenderCountAggregateOutputType = {
    id: number
    gender: number
    isEnabled: number
    _all: number
  }


  export type GenderAvgAggregateInputType = {
    id?: true
  }

  export type GenderSumAggregateInputType = {
    id?: true
  }

  export type GenderMinAggregateInputType = {
    id?: true
    gender?: true
    isEnabled?: true
  }

  export type GenderMaxAggregateInputType = {
    id?: true
    gender?: true
    isEnabled?: true
  }

  export type GenderCountAggregateInputType = {
    id?: true
    gender?: true
    isEnabled?: true
    _all?: true
  }

  export type GenderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Gender to aggregate.
     */
    where?: GenderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Genders to fetch.
     */
    orderBy?: GenderOrderByWithRelationInput | GenderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GenderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Genders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Genders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Genders
    **/
    _count?: true | GenderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GenderAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GenderSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GenderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GenderMaxAggregateInputType
  }

  export type GetGenderAggregateType<T extends GenderAggregateArgs> = {
        [P in keyof T & keyof AggregateGender]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGender[P]>
      : GetScalarType<T[P], AggregateGender[P]>
  }




  export type GenderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GenderWhereInput
    orderBy?: GenderOrderByWithAggregationInput | GenderOrderByWithAggregationInput[]
    by: GenderScalarFieldEnum[] | GenderScalarFieldEnum
    having?: GenderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GenderCountAggregateInputType | true
    _avg?: GenderAvgAggregateInputType
    _sum?: GenderSumAggregateInputType
    _min?: GenderMinAggregateInputType
    _max?: GenderMaxAggregateInputType
  }

  export type GenderGroupByOutputType = {
    id: number
    gender: string
    isEnabled: boolean
    _count: GenderCountAggregateOutputType | null
    _avg: GenderAvgAggregateOutputType | null
    _sum: GenderSumAggregateOutputType | null
    _min: GenderMinAggregateOutputType | null
    _max: GenderMaxAggregateOutputType | null
  }

  type GetGenderGroupByPayload<T extends GenderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GenderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GenderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GenderGroupByOutputType[P]>
            : GetScalarType<T[P], GenderGroupByOutputType[P]>
        }
      >
    >


  export type GenderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    gender?: boolean
    isEnabled?: boolean
    patients?: boolean | Gender$patientsArgs<ExtArgs>
    _count?: boolean | GenderCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gender"]>

  export type GenderSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    gender?: boolean
    isEnabled?: boolean
  }, ExtArgs["result"]["gender"]>

  export type GenderSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    gender?: boolean
    isEnabled?: boolean
  }, ExtArgs["result"]["gender"]>

  export type GenderSelectScalar = {
    id?: boolean
    gender?: boolean
    isEnabled?: boolean
  }

  export type GenderOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "gender" | "isEnabled", ExtArgs["result"]["gender"]>
  export type GenderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patients?: boolean | Gender$patientsArgs<ExtArgs>
    _count?: boolean | GenderCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type GenderIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type GenderIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $GenderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Gender"
    objects: {
      patients: Prisma.$PatientPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      gender: string
      isEnabled: boolean
    }, ExtArgs["result"]["gender"]>
    composites: {}
  }

  type GenderGetPayload<S extends boolean | null | undefined | GenderDefaultArgs> = $Result.GetResult<Prisma.$GenderPayload, S>

  type GenderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GenderFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GenderCountAggregateInputType | true
    }

  export interface GenderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Gender'], meta: { name: 'Gender' } }
    /**
     * Find zero or one Gender that matches the filter.
     * @param {GenderFindUniqueArgs} args - Arguments to find a Gender
     * @example
     * // Get one Gender
     * const gender = await prisma.gender.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GenderFindUniqueArgs>(args: SelectSubset<T, GenderFindUniqueArgs<ExtArgs>>): Prisma__GenderClient<$Result.GetResult<Prisma.$GenderPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Gender that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GenderFindUniqueOrThrowArgs} args - Arguments to find a Gender
     * @example
     * // Get one Gender
     * const gender = await prisma.gender.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GenderFindUniqueOrThrowArgs>(args: SelectSubset<T, GenderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GenderClient<$Result.GetResult<Prisma.$GenderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Gender that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GenderFindFirstArgs} args - Arguments to find a Gender
     * @example
     * // Get one Gender
     * const gender = await prisma.gender.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GenderFindFirstArgs>(args?: SelectSubset<T, GenderFindFirstArgs<ExtArgs>>): Prisma__GenderClient<$Result.GetResult<Prisma.$GenderPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Gender that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GenderFindFirstOrThrowArgs} args - Arguments to find a Gender
     * @example
     * // Get one Gender
     * const gender = await prisma.gender.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GenderFindFirstOrThrowArgs>(args?: SelectSubset<T, GenderFindFirstOrThrowArgs<ExtArgs>>): Prisma__GenderClient<$Result.GetResult<Prisma.$GenderPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Genders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GenderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Genders
     * const genders = await prisma.gender.findMany()
     * 
     * // Get first 10 Genders
     * const genders = await prisma.gender.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const genderWithIdOnly = await prisma.gender.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GenderFindManyArgs>(args?: SelectSubset<T, GenderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GenderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Gender.
     * @param {GenderCreateArgs} args - Arguments to create a Gender.
     * @example
     * // Create one Gender
     * const Gender = await prisma.gender.create({
     *   data: {
     *     // ... data to create a Gender
     *   }
     * })
     * 
     */
    create<T extends GenderCreateArgs>(args: SelectSubset<T, GenderCreateArgs<ExtArgs>>): Prisma__GenderClient<$Result.GetResult<Prisma.$GenderPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Genders.
     * @param {GenderCreateManyArgs} args - Arguments to create many Genders.
     * @example
     * // Create many Genders
     * const gender = await prisma.gender.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GenderCreateManyArgs>(args?: SelectSubset<T, GenderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Genders and returns the data saved in the database.
     * @param {GenderCreateManyAndReturnArgs} args - Arguments to create many Genders.
     * @example
     * // Create many Genders
     * const gender = await prisma.gender.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Genders and only return the `id`
     * const genderWithIdOnly = await prisma.gender.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GenderCreateManyAndReturnArgs>(args?: SelectSubset<T, GenderCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GenderPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Gender.
     * @param {GenderDeleteArgs} args - Arguments to delete one Gender.
     * @example
     * // Delete one Gender
     * const Gender = await prisma.gender.delete({
     *   where: {
     *     // ... filter to delete one Gender
     *   }
     * })
     * 
     */
    delete<T extends GenderDeleteArgs>(args: SelectSubset<T, GenderDeleteArgs<ExtArgs>>): Prisma__GenderClient<$Result.GetResult<Prisma.$GenderPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Gender.
     * @param {GenderUpdateArgs} args - Arguments to update one Gender.
     * @example
     * // Update one Gender
     * const gender = await prisma.gender.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GenderUpdateArgs>(args: SelectSubset<T, GenderUpdateArgs<ExtArgs>>): Prisma__GenderClient<$Result.GetResult<Prisma.$GenderPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Genders.
     * @param {GenderDeleteManyArgs} args - Arguments to filter Genders to delete.
     * @example
     * // Delete a few Genders
     * const { count } = await prisma.gender.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GenderDeleteManyArgs>(args?: SelectSubset<T, GenderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Genders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GenderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Genders
     * const gender = await prisma.gender.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GenderUpdateManyArgs>(args: SelectSubset<T, GenderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Genders and returns the data updated in the database.
     * @param {GenderUpdateManyAndReturnArgs} args - Arguments to update many Genders.
     * @example
     * // Update many Genders
     * const gender = await prisma.gender.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Genders and only return the `id`
     * const genderWithIdOnly = await prisma.gender.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends GenderUpdateManyAndReturnArgs>(args: SelectSubset<T, GenderUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GenderPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Gender.
     * @param {GenderUpsertArgs} args - Arguments to update or create a Gender.
     * @example
     * // Update or create a Gender
     * const gender = await prisma.gender.upsert({
     *   create: {
     *     // ... data to create a Gender
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Gender we want to update
     *   }
     * })
     */
    upsert<T extends GenderUpsertArgs>(args: SelectSubset<T, GenderUpsertArgs<ExtArgs>>): Prisma__GenderClient<$Result.GetResult<Prisma.$GenderPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Genders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GenderCountArgs} args - Arguments to filter Genders to count.
     * @example
     * // Count the number of Genders
     * const count = await prisma.gender.count({
     *   where: {
     *     // ... the filter for the Genders we want to count
     *   }
     * })
    **/
    count<T extends GenderCountArgs>(
      args?: Subset<T, GenderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GenderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Gender.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GenderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GenderAggregateArgs>(args: Subset<T, GenderAggregateArgs>): Prisma.PrismaPromise<GetGenderAggregateType<T>>

    /**
     * Group by Gender.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GenderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GenderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GenderGroupByArgs['orderBy'] }
        : { orderBy?: GenderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GenderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGenderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Gender model
   */
  readonly fields: GenderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Gender.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GenderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    patients<T extends Gender$patientsArgs<ExtArgs> = {}>(args?: Subset<T, Gender$patientsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Gender model
   */
  interface GenderFieldRefs {
    readonly id: FieldRef<"Gender", 'Int'>
    readonly gender: FieldRef<"Gender", 'String'>
    readonly isEnabled: FieldRef<"Gender", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Gender findUnique
   */
  export type GenderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gender
     */
    select?: GenderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Gender
     */
    omit?: GenderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GenderInclude<ExtArgs> | null
    /**
     * Filter, which Gender to fetch.
     */
    where: GenderWhereUniqueInput
  }

  /**
   * Gender findUniqueOrThrow
   */
  export type GenderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gender
     */
    select?: GenderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Gender
     */
    omit?: GenderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GenderInclude<ExtArgs> | null
    /**
     * Filter, which Gender to fetch.
     */
    where: GenderWhereUniqueInput
  }

  /**
   * Gender findFirst
   */
  export type GenderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gender
     */
    select?: GenderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Gender
     */
    omit?: GenderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GenderInclude<ExtArgs> | null
    /**
     * Filter, which Gender to fetch.
     */
    where?: GenderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Genders to fetch.
     */
    orderBy?: GenderOrderByWithRelationInput | GenderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Genders.
     */
    cursor?: GenderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Genders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Genders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Genders.
     */
    distinct?: GenderScalarFieldEnum | GenderScalarFieldEnum[]
  }

  /**
   * Gender findFirstOrThrow
   */
  export type GenderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gender
     */
    select?: GenderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Gender
     */
    omit?: GenderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GenderInclude<ExtArgs> | null
    /**
     * Filter, which Gender to fetch.
     */
    where?: GenderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Genders to fetch.
     */
    orderBy?: GenderOrderByWithRelationInput | GenderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Genders.
     */
    cursor?: GenderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Genders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Genders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Genders.
     */
    distinct?: GenderScalarFieldEnum | GenderScalarFieldEnum[]
  }

  /**
   * Gender findMany
   */
  export type GenderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gender
     */
    select?: GenderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Gender
     */
    omit?: GenderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GenderInclude<ExtArgs> | null
    /**
     * Filter, which Genders to fetch.
     */
    where?: GenderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Genders to fetch.
     */
    orderBy?: GenderOrderByWithRelationInput | GenderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Genders.
     */
    cursor?: GenderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Genders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Genders.
     */
    skip?: number
    distinct?: GenderScalarFieldEnum | GenderScalarFieldEnum[]
  }

  /**
   * Gender create
   */
  export type GenderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gender
     */
    select?: GenderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Gender
     */
    omit?: GenderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GenderInclude<ExtArgs> | null
    /**
     * The data needed to create a Gender.
     */
    data: XOR<GenderCreateInput, GenderUncheckedCreateInput>
  }

  /**
   * Gender createMany
   */
  export type GenderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Genders.
     */
    data: GenderCreateManyInput | GenderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Gender createManyAndReturn
   */
  export type GenderCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gender
     */
    select?: GenderSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Gender
     */
    omit?: GenderOmit<ExtArgs> | null
    /**
     * The data used to create many Genders.
     */
    data: GenderCreateManyInput | GenderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Gender update
   */
  export type GenderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gender
     */
    select?: GenderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Gender
     */
    omit?: GenderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GenderInclude<ExtArgs> | null
    /**
     * The data needed to update a Gender.
     */
    data: XOR<GenderUpdateInput, GenderUncheckedUpdateInput>
    /**
     * Choose, which Gender to update.
     */
    where: GenderWhereUniqueInput
  }

  /**
   * Gender updateMany
   */
  export type GenderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Genders.
     */
    data: XOR<GenderUpdateManyMutationInput, GenderUncheckedUpdateManyInput>
    /**
     * Filter which Genders to update
     */
    where?: GenderWhereInput
    /**
     * Limit how many Genders to update.
     */
    limit?: number
  }

  /**
   * Gender updateManyAndReturn
   */
  export type GenderUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gender
     */
    select?: GenderSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Gender
     */
    omit?: GenderOmit<ExtArgs> | null
    /**
     * The data used to update Genders.
     */
    data: XOR<GenderUpdateManyMutationInput, GenderUncheckedUpdateManyInput>
    /**
     * Filter which Genders to update
     */
    where?: GenderWhereInput
    /**
     * Limit how many Genders to update.
     */
    limit?: number
  }

  /**
   * Gender upsert
   */
  export type GenderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gender
     */
    select?: GenderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Gender
     */
    omit?: GenderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GenderInclude<ExtArgs> | null
    /**
     * The filter to search for the Gender to update in case it exists.
     */
    where: GenderWhereUniqueInput
    /**
     * In case the Gender found by the `where` argument doesn't exist, create a new Gender with this data.
     */
    create: XOR<GenderCreateInput, GenderUncheckedCreateInput>
    /**
     * In case the Gender was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GenderUpdateInput, GenderUncheckedUpdateInput>
  }

  /**
   * Gender delete
   */
  export type GenderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gender
     */
    select?: GenderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Gender
     */
    omit?: GenderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GenderInclude<ExtArgs> | null
    /**
     * Filter which Gender to delete.
     */
    where: GenderWhereUniqueInput
  }

  /**
   * Gender deleteMany
   */
  export type GenderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Genders to delete
     */
    where?: GenderWhereInput
    /**
     * Limit how many Genders to delete.
     */
    limit?: number
  }

  /**
   * Gender.patients
   */
  export type Gender$patientsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    where?: PatientWhereInput
    orderBy?: PatientOrderByWithRelationInput | PatientOrderByWithRelationInput[]
    cursor?: PatientWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PatientScalarFieldEnum | PatientScalarFieldEnum[]
  }

  /**
   * Gender without action
   */
  export type GenderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gender
     */
    select?: GenderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Gender
     */
    omit?: GenderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GenderInclude<ExtArgs> | null
  }


  /**
   * Model ReferralSource
   */

  export type AggregateReferralSource = {
    _count: ReferralSourceCountAggregateOutputType | null
    _avg: ReferralSourceAvgAggregateOutputType | null
    _sum: ReferralSourceSumAggregateOutputType | null
    _min: ReferralSourceMinAggregateOutputType | null
    _max: ReferralSourceMaxAggregateOutputType | null
  }

  export type ReferralSourceAvgAggregateOutputType = {
    id: number | null
  }

  export type ReferralSourceSumAggregateOutputType = {
    id: number | null
  }

  export type ReferralSourceMinAggregateOutputType = {
    id: number | null
    source: string | null
    isEnabled: boolean | null
  }

  export type ReferralSourceMaxAggregateOutputType = {
    id: number | null
    source: string | null
    isEnabled: boolean | null
  }

  export type ReferralSourceCountAggregateOutputType = {
    id: number
    source: number
    isEnabled: number
    _all: number
  }


  export type ReferralSourceAvgAggregateInputType = {
    id?: true
  }

  export type ReferralSourceSumAggregateInputType = {
    id?: true
  }

  export type ReferralSourceMinAggregateInputType = {
    id?: true
    source?: true
    isEnabled?: true
  }

  export type ReferralSourceMaxAggregateInputType = {
    id?: true
    source?: true
    isEnabled?: true
  }

  export type ReferralSourceCountAggregateInputType = {
    id?: true
    source?: true
    isEnabled?: true
    _all?: true
  }

  export type ReferralSourceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReferralSource to aggregate.
     */
    where?: ReferralSourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReferralSources to fetch.
     */
    orderBy?: ReferralSourceOrderByWithRelationInput | ReferralSourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReferralSourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReferralSources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReferralSources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ReferralSources
    **/
    _count?: true | ReferralSourceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReferralSourceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReferralSourceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReferralSourceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReferralSourceMaxAggregateInputType
  }

  export type GetReferralSourceAggregateType<T extends ReferralSourceAggregateArgs> = {
        [P in keyof T & keyof AggregateReferralSource]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReferralSource[P]>
      : GetScalarType<T[P], AggregateReferralSource[P]>
  }




  export type ReferralSourceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReferralSourceWhereInput
    orderBy?: ReferralSourceOrderByWithAggregationInput | ReferralSourceOrderByWithAggregationInput[]
    by: ReferralSourceScalarFieldEnum[] | ReferralSourceScalarFieldEnum
    having?: ReferralSourceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReferralSourceCountAggregateInputType | true
    _avg?: ReferralSourceAvgAggregateInputType
    _sum?: ReferralSourceSumAggregateInputType
    _min?: ReferralSourceMinAggregateInputType
    _max?: ReferralSourceMaxAggregateInputType
  }

  export type ReferralSourceGroupByOutputType = {
    id: number
    source: string
    isEnabled: boolean
    _count: ReferralSourceCountAggregateOutputType | null
    _avg: ReferralSourceAvgAggregateOutputType | null
    _sum: ReferralSourceSumAggregateOutputType | null
    _min: ReferralSourceMinAggregateOutputType | null
    _max: ReferralSourceMaxAggregateOutputType | null
  }

  type GetReferralSourceGroupByPayload<T extends ReferralSourceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReferralSourceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReferralSourceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReferralSourceGroupByOutputType[P]>
            : GetScalarType<T[P], ReferralSourceGroupByOutputType[P]>
        }
      >
    >


  export type ReferralSourceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    source?: boolean
    isEnabled?: boolean
    reservations?: boolean | ReferralSource$reservationsArgs<ExtArgs>
    _count?: boolean | ReferralSourceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["referralSource"]>

  export type ReferralSourceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    source?: boolean
    isEnabled?: boolean
  }, ExtArgs["result"]["referralSource"]>

  export type ReferralSourceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    source?: boolean
    isEnabled?: boolean
  }, ExtArgs["result"]["referralSource"]>

  export type ReferralSourceSelectScalar = {
    id?: boolean
    source?: boolean
    isEnabled?: boolean
  }

  export type ReferralSourceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "source" | "isEnabled", ExtArgs["result"]["referralSource"]>
  export type ReferralSourceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    reservations?: boolean | ReferralSource$reservationsArgs<ExtArgs>
    _count?: boolean | ReferralSourceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ReferralSourceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ReferralSourceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ReferralSourcePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ReferralSource"
    objects: {
      reservations: Prisma.$ReservationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      source: string
      isEnabled: boolean
    }, ExtArgs["result"]["referralSource"]>
    composites: {}
  }

  type ReferralSourceGetPayload<S extends boolean | null | undefined | ReferralSourceDefaultArgs> = $Result.GetResult<Prisma.$ReferralSourcePayload, S>

  type ReferralSourceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ReferralSourceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ReferralSourceCountAggregateInputType | true
    }

  export interface ReferralSourceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ReferralSource'], meta: { name: 'ReferralSource' } }
    /**
     * Find zero or one ReferralSource that matches the filter.
     * @param {ReferralSourceFindUniqueArgs} args - Arguments to find a ReferralSource
     * @example
     * // Get one ReferralSource
     * const referralSource = await prisma.referralSource.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReferralSourceFindUniqueArgs>(args: SelectSubset<T, ReferralSourceFindUniqueArgs<ExtArgs>>): Prisma__ReferralSourceClient<$Result.GetResult<Prisma.$ReferralSourcePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ReferralSource that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ReferralSourceFindUniqueOrThrowArgs} args - Arguments to find a ReferralSource
     * @example
     * // Get one ReferralSource
     * const referralSource = await prisma.referralSource.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReferralSourceFindUniqueOrThrowArgs>(args: SelectSubset<T, ReferralSourceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReferralSourceClient<$Result.GetResult<Prisma.$ReferralSourcePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ReferralSource that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralSourceFindFirstArgs} args - Arguments to find a ReferralSource
     * @example
     * // Get one ReferralSource
     * const referralSource = await prisma.referralSource.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReferralSourceFindFirstArgs>(args?: SelectSubset<T, ReferralSourceFindFirstArgs<ExtArgs>>): Prisma__ReferralSourceClient<$Result.GetResult<Prisma.$ReferralSourcePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ReferralSource that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralSourceFindFirstOrThrowArgs} args - Arguments to find a ReferralSource
     * @example
     * // Get one ReferralSource
     * const referralSource = await prisma.referralSource.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReferralSourceFindFirstOrThrowArgs>(args?: SelectSubset<T, ReferralSourceFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReferralSourceClient<$Result.GetResult<Prisma.$ReferralSourcePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ReferralSources that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralSourceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ReferralSources
     * const referralSources = await prisma.referralSource.findMany()
     * 
     * // Get first 10 ReferralSources
     * const referralSources = await prisma.referralSource.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const referralSourceWithIdOnly = await prisma.referralSource.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReferralSourceFindManyArgs>(args?: SelectSubset<T, ReferralSourceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReferralSourcePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ReferralSource.
     * @param {ReferralSourceCreateArgs} args - Arguments to create a ReferralSource.
     * @example
     * // Create one ReferralSource
     * const ReferralSource = await prisma.referralSource.create({
     *   data: {
     *     // ... data to create a ReferralSource
     *   }
     * })
     * 
     */
    create<T extends ReferralSourceCreateArgs>(args: SelectSubset<T, ReferralSourceCreateArgs<ExtArgs>>): Prisma__ReferralSourceClient<$Result.GetResult<Prisma.$ReferralSourcePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ReferralSources.
     * @param {ReferralSourceCreateManyArgs} args - Arguments to create many ReferralSources.
     * @example
     * // Create many ReferralSources
     * const referralSource = await prisma.referralSource.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReferralSourceCreateManyArgs>(args?: SelectSubset<T, ReferralSourceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ReferralSources and returns the data saved in the database.
     * @param {ReferralSourceCreateManyAndReturnArgs} args - Arguments to create many ReferralSources.
     * @example
     * // Create many ReferralSources
     * const referralSource = await prisma.referralSource.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ReferralSources and only return the `id`
     * const referralSourceWithIdOnly = await prisma.referralSource.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReferralSourceCreateManyAndReturnArgs>(args?: SelectSubset<T, ReferralSourceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReferralSourcePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ReferralSource.
     * @param {ReferralSourceDeleteArgs} args - Arguments to delete one ReferralSource.
     * @example
     * // Delete one ReferralSource
     * const ReferralSource = await prisma.referralSource.delete({
     *   where: {
     *     // ... filter to delete one ReferralSource
     *   }
     * })
     * 
     */
    delete<T extends ReferralSourceDeleteArgs>(args: SelectSubset<T, ReferralSourceDeleteArgs<ExtArgs>>): Prisma__ReferralSourceClient<$Result.GetResult<Prisma.$ReferralSourcePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ReferralSource.
     * @param {ReferralSourceUpdateArgs} args - Arguments to update one ReferralSource.
     * @example
     * // Update one ReferralSource
     * const referralSource = await prisma.referralSource.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReferralSourceUpdateArgs>(args: SelectSubset<T, ReferralSourceUpdateArgs<ExtArgs>>): Prisma__ReferralSourceClient<$Result.GetResult<Prisma.$ReferralSourcePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ReferralSources.
     * @param {ReferralSourceDeleteManyArgs} args - Arguments to filter ReferralSources to delete.
     * @example
     * // Delete a few ReferralSources
     * const { count } = await prisma.referralSource.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReferralSourceDeleteManyArgs>(args?: SelectSubset<T, ReferralSourceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReferralSources.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralSourceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ReferralSources
     * const referralSource = await prisma.referralSource.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReferralSourceUpdateManyArgs>(args: SelectSubset<T, ReferralSourceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReferralSources and returns the data updated in the database.
     * @param {ReferralSourceUpdateManyAndReturnArgs} args - Arguments to update many ReferralSources.
     * @example
     * // Update many ReferralSources
     * const referralSource = await prisma.referralSource.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ReferralSources and only return the `id`
     * const referralSourceWithIdOnly = await prisma.referralSource.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ReferralSourceUpdateManyAndReturnArgs>(args: SelectSubset<T, ReferralSourceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReferralSourcePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ReferralSource.
     * @param {ReferralSourceUpsertArgs} args - Arguments to update or create a ReferralSource.
     * @example
     * // Update or create a ReferralSource
     * const referralSource = await prisma.referralSource.upsert({
     *   create: {
     *     // ... data to create a ReferralSource
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ReferralSource we want to update
     *   }
     * })
     */
    upsert<T extends ReferralSourceUpsertArgs>(args: SelectSubset<T, ReferralSourceUpsertArgs<ExtArgs>>): Prisma__ReferralSourceClient<$Result.GetResult<Prisma.$ReferralSourcePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ReferralSources.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralSourceCountArgs} args - Arguments to filter ReferralSources to count.
     * @example
     * // Count the number of ReferralSources
     * const count = await prisma.referralSource.count({
     *   where: {
     *     // ... the filter for the ReferralSources we want to count
     *   }
     * })
    **/
    count<T extends ReferralSourceCountArgs>(
      args?: Subset<T, ReferralSourceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReferralSourceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ReferralSource.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralSourceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReferralSourceAggregateArgs>(args: Subset<T, ReferralSourceAggregateArgs>): Prisma.PrismaPromise<GetReferralSourceAggregateType<T>>

    /**
     * Group by ReferralSource.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralSourceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReferralSourceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReferralSourceGroupByArgs['orderBy'] }
        : { orderBy?: ReferralSourceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReferralSourceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReferralSourceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ReferralSource model
   */
  readonly fields: ReferralSourceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ReferralSource.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReferralSourceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    reservations<T extends ReferralSource$reservationsArgs<ExtArgs> = {}>(args?: Subset<T, ReferralSource$reservationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReservationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ReferralSource model
   */
  interface ReferralSourceFieldRefs {
    readonly id: FieldRef<"ReferralSource", 'Int'>
    readonly source: FieldRef<"ReferralSource", 'String'>
    readonly isEnabled: FieldRef<"ReferralSource", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * ReferralSource findUnique
   */
  export type ReferralSourceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferralSource
     */
    select?: ReferralSourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReferralSource
     */
    omit?: ReferralSourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralSourceInclude<ExtArgs> | null
    /**
     * Filter, which ReferralSource to fetch.
     */
    where: ReferralSourceWhereUniqueInput
  }

  /**
   * ReferralSource findUniqueOrThrow
   */
  export type ReferralSourceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferralSource
     */
    select?: ReferralSourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReferralSource
     */
    omit?: ReferralSourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralSourceInclude<ExtArgs> | null
    /**
     * Filter, which ReferralSource to fetch.
     */
    where: ReferralSourceWhereUniqueInput
  }

  /**
   * ReferralSource findFirst
   */
  export type ReferralSourceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferralSource
     */
    select?: ReferralSourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReferralSource
     */
    omit?: ReferralSourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralSourceInclude<ExtArgs> | null
    /**
     * Filter, which ReferralSource to fetch.
     */
    where?: ReferralSourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReferralSources to fetch.
     */
    orderBy?: ReferralSourceOrderByWithRelationInput | ReferralSourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReferralSources.
     */
    cursor?: ReferralSourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReferralSources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReferralSources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReferralSources.
     */
    distinct?: ReferralSourceScalarFieldEnum | ReferralSourceScalarFieldEnum[]
  }

  /**
   * ReferralSource findFirstOrThrow
   */
  export type ReferralSourceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferralSource
     */
    select?: ReferralSourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReferralSource
     */
    omit?: ReferralSourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralSourceInclude<ExtArgs> | null
    /**
     * Filter, which ReferralSource to fetch.
     */
    where?: ReferralSourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReferralSources to fetch.
     */
    orderBy?: ReferralSourceOrderByWithRelationInput | ReferralSourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReferralSources.
     */
    cursor?: ReferralSourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReferralSources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReferralSources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReferralSources.
     */
    distinct?: ReferralSourceScalarFieldEnum | ReferralSourceScalarFieldEnum[]
  }

  /**
   * ReferralSource findMany
   */
  export type ReferralSourceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferralSource
     */
    select?: ReferralSourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReferralSource
     */
    omit?: ReferralSourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralSourceInclude<ExtArgs> | null
    /**
     * Filter, which ReferralSources to fetch.
     */
    where?: ReferralSourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReferralSources to fetch.
     */
    orderBy?: ReferralSourceOrderByWithRelationInput | ReferralSourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ReferralSources.
     */
    cursor?: ReferralSourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReferralSources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReferralSources.
     */
    skip?: number
    distinct?: ReferralSourceScalarFieldEnum | ReferralSourceScalarFieldEnum[]
  }

  /**
   * ReferralSource create
   */
  export type ReferralSourceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferralSource
     */
    select?: ReferralSourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReferralSource
     */
    omit?: ReferralSourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralSourceInclude<ExtArgs> | null
    /**
     * The data needed to create a ReferralSource.
     */
    data: XOR<ReferralSourceCreateInput, ReferralSourceUncheckedCreateInput>
  }

  /**
   * ReferralSource createMany
   */
  export type ReferralSourceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ReferralSources.
     */
    data: ReferralSourceCreateManyInput | ReferralSourceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ReferralSource createManyAndReturn
   */
  export type ReferralSourceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferralSource
     */
    select?: ReferralSourceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ReferralSource
     */
    omit?: ReferralSourceOmit<ExtArgs> | null
    /**
     * The data used to create many ReferralSources.
     */
    data: ReferralSourceCreateManyInput | ReferralSourceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ReferralSource update
   */
  export type ReferralSourceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferralSource
     */
    select?: ReferralSourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReferralSource
     */
    omit?: ReferralSourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralSourceInclude<ExtArgs> | null
    /**
     * The data needed to update a ReferralSource.
     */
    data: XOR<ReferralSourceUpdateInput, ReferralSourceUncheckedUpdateInput>
    /**
     * Choose, which ReferralSource to update.
     */
    where: ReferralSourceWhereUniqueInput
  }

  /**
   * ReferralSource updateMany
   */
  export type ReferralSourceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ReferralSources.
     */
    data: XOR<ReferralSourceUpdateManyMutationInput, ReferralSourceUncheckedUpdateManyInput>
    /**
     * Filter which ReferralSources to update
     */
    where?: ReferralSourceWhereInput
    /**
     * Limit how many ReferralSources to update.
     */
    limit?: number
  }

  /**
   * ReferralSource updateManyAndReturn
   */
  export type ReferralSourceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferralSource
     */
    select?: ReferralSourceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ReferralSource
     */
    omit?: ReferralSourceOmit<ExtArgs> | null
    /**
     * The data used to update ReferralSources.
     */
    data: XOR<ReferralSourceUpdateManyMutationInput, ReferralSourceUncheckedUpdateManyInput>
    /**
     * Filter which ReferralSources to update
     */
    where?: ReferralSourceWhereInput
    /**
     * Limit how many ReferralSources to update.
     */
    limit?: number
  }

  /**
   * ReferralSource upsert
   */
  export type ReferralSourceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferralSource
     */
    select?: ReferralSourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReferralSource
     */
    omit?: ReferralSourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralSourceInclude<ExtArgs> | null
    /**
     * The filter to search for the ReferralSource to update in case it exists.
     */
    where: ReferralSourceWhereUniqueInput
    /**
     * In case the ReferralSource found by the `where` argument doesn't exist, create a new ReferralSource with this data.
     */
    create: XOR<ReferralSourceCreateInput, ReferralSourceUncheckedCreateInput>
    /**
     * In case the ReferralSource was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReferralSourceUpdateInput, ReferralSourceUncheckedUpdateInput>
  }

  /**
   * ReferralSource delete
   */
  export type ReferralSourceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferralSource
     */
    select?: ReferralSourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReferralSource
     */
    omit?: ReferralSourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralSourceInclude<ExtArgs> | null
    /**
     * Filter which ReferralSource to delete.
     */
    where: ReferralSourceWhereUniqueInput
  }

  /**
   * ReferralSource deleteMany
   */
  export type ReferralSourceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReferralSources to delete
     */
    where?: ReferralSourceWhereInput
    /**
     * Limit how many ReferralSources to delete.
     */
    limit?: number
  }

  /**
   * ReferralSource.reservations
   */
  export type ReferralSource$reservationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reservation
     */
    select?: ReservationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reservation
     */
    omit?: ReservationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationInclude<ExtArgs> | null
    where?: ReservationWhereInput
    orderBy?: ReservationOrderByWithRelationInput | ReservationOrderByWithRelationInput[]
    cursor?: ReservationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReservationScalarFieldEnum | ReservationScalarFieldEnum[]
  }

  /**
   * ReferralSource without action
   */
  export type ReferralSourceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferralSource
     */
    select?: ReferralSourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReferralSource
     */
    omit?: ReferralSourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralSourceInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const PaymentMethodScalarFieldEnum: {
    id: 'id',
    isEnabled: 'isEnabled',
    displayName: 'displayName'
  };

  export type PaymentMethodScalarFieldEnum = (typeof PaymentMethodScalarFieldEnum)[keyof typeof PaymentMethodScalarFieldEnum]


  export const BedScalarFieldEnum: {
    id: 'id',
    displayName: 'displayName',
    bedNumber: 'bedNumber',
    isEnabled: 'isEnabled',
    roomId: 'roomId',
    bedStatusId: 'bedStatusId'
  };

  export type BedScalarFieldEnum = (typeof BedScalarFieldEnum)[keyof typeof BedScalarFieldEnum]


  export const RoomScalarFieldEnum: {
    id: 'id',
    roomName: 'roomName',
    isEnabled: 'isEnabled',
    unitId: 'unitId',
    classId: 'classId'
  };

  export type RoomScalarFieldEnum = (typeof RoomScalarFieldEnum)[keyof typeof RoomScalarFieldEnum]


  export const UnitScalarFieldEnum: {
    id: 'id',
    unitName: 'unitName',
    isEnabled: 'isEnabled',
    departmentId: 'departmentId'
  };

  export type UnitScalarFieldEnum = (typeof UnitScalarFieldEnum)[keyof typeof UnitScalarFieldEnum]


  export const BedStatusScalarFieldEnum: {
    id: 'id',
    status: 'status',
    isEnabled: 'isEnabled'
  };

  export type BedStatusScalarFieldEnum = (typeof BedStatusScalarFieldEnum)[keyof typeof BedStatusScalarFieldEnum]


  export const ClassScalarFieldEnum: {
    id: 'id',
    className: 'className',
    isEnabled: 'isEnabled'
  };

  export type ClassScalarFieldEnum = (typeof ClassScalarFieldEnum)[keyof typeof ClassScalarFieldEnum]


  export const DepartmentScalarFieldEnum: {
    id: 'id',
    departmentName: 'departmentName',
    isEnabled: 'isEnabled'
  };

  export type DepartmentScalarFieldEnum = (typeof DepartmentScalarFieldEnum)[keyof typeof DepartmentScalarFieldEnum]


  export const ProductScalarFieldEnum: {
    id: 'id',
    productName: 'productName',
    isEnabled: 'isEnabled'
  };

  export type ProductScalarFieldEnum = (typeof ProductScalarFieldEnum)[keyof typeof ProductScalarFieldEnum]


  export const ServiceReceiptScalarFieldEnum: {
    id: 'id',
    receiptAt: 'receiptAt'
  };

  export type ServiceReceiptScalarFieldEnum = (typeof ServiceReceiptScalarFieldEnum)[keyof typeof ServiceReceiptScalarFieldEnum]


  export const StockDetailScalarFieldEnum: {
    id: 'id',
    productId: 'productId',
    unitId: 'unitId',
    receiptId: 'receiptId',
    sourceProductId: 'sourceProductId',
    netPrice: 'netPrice',
    discountPrice: 'discountPrice',
    quantity: 'quantity',
    isEnabled: 'isEnabled',
    expiredAt: 'expiredAt'
  };

  export type StockDetailScalarFieldEnum = (typeof StockDetailScalarFieldEnum)[keyof typeof StockDetailScalarFieldEnum]


  export const DoctorScheduleScalarFieldEnum: {
    id: 'id',
    unitId: 'unitId',
    doctorId: 'doctorId',
    startTime: 'startTime',
    endTime: 'endTime',
    note: 'note',
    days: 'days',
    quota: 'quota',
    isEnabled: 'isEnabled'
  };

  export type DoctorScheduleScalarFieldEnum = (typeof DoctorScheduleScalarFieldEnum)[keyof typeof DoctorScheduleScalarFieldEnum]


  export const EmployeeScalarFieldEnum: {
    id: 'id',
    fullName: 'fullName',
    identityNo: 'identityNo',
    isEnabled: 'isEnabled'
  };

  export type EmployeeScalarFieldEnum = (typeof EmployeeScalarFieldEnum)[keyof typeof EmployeeScalarFieldEnum]


  export const ReservationScalarFieldEnum: {
    id: 'id',
    isEnabled: 'isEnabled',
    unitId: 'unitId',
    identity: 'identity',
    queueNumber: 'queueNumber',
    reservationNumber: 'reservationNumber',
    reservationDate: 'reservationDate',
    paymentMethodId: 'paymentMethodId',
    bpjsNumber: 'bpjsNumber',
    otherInsuranceNumber: 'otherInsuranceNumber',
    createdAt: 'createdAt',
    referralNumber: 'referralNumber',
    doctorId: 'doctorId',
    notes: 'notes',
    queueType: 'queueType',
    referralSourceId: 'referralSourceId',
    isConfirmed: 'isConfirmed',
    callStatus: 'callStatus',
    isCancelled: 'isCancelled',
    cancelReason: 'cancelReason',
    educationId: 'educationId',
    type: 'type',
    patientType: 'patientType'
  };

  export type ReservationScalarFieldEnum = (typeof ReservationScalarFieldEnum)[keyof typeof ReservationScalarFieldEnum]


  export const PatientScalarFieldEnum: {
    id: 'id',
    isEnabled: 'isEnabled',
    name: 'name',
    identity: 'identity',
    genderId: 'genderId',
    birthPlace: 'birthPlace',
    birthDate: 'birthDate',
    motherName: 'motherName',
    fatherName: 'fatherName',
    spouseName: 'spouseName',
    bpjsNumber: 'bpjsNumber',
    otherInsuranceNumber: 'otherInsuranceNumber',
    phoneNumber: 'phoneNumber',
    registeredAt: 'registeredAt',
    homeAddress: 'homeAddress'
  };

  export type PatientScalarFieldEnum = (typeof PatientScalarFieldEnum)[keyof typeof PatientScalarFieldEnum]


  export const GenderScalarFieldEnum: {
    id: 'id',
    gender: 'gender',
    isEnabled: 'isEnabled'
  };

  export type GenderScalarFieldEnum = (typeof GenderScalarFieldEnum)[keyof typeof GenderScalarFieldEnum]


  export const ReferralSourceScalarFieldEnum: {
    id: 'id',
    source: 'source',
    isEnabled: 'isEnabled'
  };

  export type ReferralSourceScalarFieldEnum = (typeof ReferralSourceScalarFieldEnum)[keyof typeof ReferralSourceScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type PaymentMethodWhereInput = {
    AND?: PaymentMethodWhereInput | PaymentMethodWhereInput[]
    OR?: PaymentMethodWhereInput[]
    NOT?: PaymentMethodWhereInput | PaymentMethodWhereInput[]
    id?: IntFilter<"PaymentMethod"> | number
    isEnabled?: BoolFilter<"PaymentMethod"> | boolean
    displayName?: StringFilter<"PaymentMethod"> | string
    reservations?: ReservationListRelationFilter
  }

  export type PaymentMethodOrderByWithRelationInput = {
    id?: SortOrder
    isEnabled?: SortOrder
    displayName?: SortOrder
    reservations?: ReservationOrderByRelationAggregateInput
  }

  export type PaymentMethodWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PaymentMethodWhereInput | PaymentMethodWhereInput[]
    OR?: PaymentMethodWhereInput[]
    NOT?: PaymentMethodWhereInput | PaymentMethodWhereInput[]
    isEnabled?: BoolFilter<"PaymentMethod"> | boolean
    displayName?: StringFilter<"PaymentMethod"> | string
    reservations?: ReservationListRelationFilter
  }, "id">

  export type PaymentMethodOrderByWithAggregationInput = {
    id?: SortOrder
    isEnabled?: SortOrder
    displayName?: SortOrder
    _count?: PaymentMethodCountOrderByAggregateInput
    _avg?: PaymentMethodAvgOrderByAggregateInput
    _max?: PaymentMethodMaxOrderByAggregateInput
    _min?: PaymentMethodMinOrderByAggregateInput
    _sum?: PaymentMethodSumOrderByAggregateInput
  }

  export type PaymentMethodScalarWhereWithAggregatesInput = {
    AND?: PaymentMethodScalarWhereWithAggregatesInput | PaymentMethodScalarWhereWithAggregatesInput[]
    OR?: PaymentMethodScalarWhereWithAggregatesInput[]
    NOT?: PaymentMethodScalarWhereWithAggregatesInput | PaymentMethodScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PaymentMethod"> | number
    isEnabled?: BoolWithAggregatesFilter<"PaymentMethod"> | boolean
    displayName?: StringWithAggregatesFilter<"PaymentMethod"> | string
  }

  export type BedWhereInput = {
    AND?: BedWhereInput | BedWhereInput[]
    OR?: BedWhereInput[]
    NOT?: BedWhereInput | BedWhereInput[]
    id?: IntFilter<"Bed"> | number
    displayName?: StringFilter<"Bed"> | string
    bedNumber?: IntFilter<"Bed"> | number
    isEnabled?: BoolFilter<"Bed"> | boolean
    roomId?: IntNullableFilter<"Bed"> | number | null
    bedStatusId?: IntNullableFilter<"Bed"> | number | null
    room?: XOR<RoomNullableScalarRelationFilter, RoomWhereInput> | null
    bedStatus?: XOR<BedStatusNullableScalarRelationFilter, BedStatusWhereInput> | null
  }

  export type BedOrderByWithRelationInput = {
    id?: SortOrder
    displayName?: SortOrder
    bedNumber?: SortOrder
    isEnabled?: SortOrder
    roomId?: SortOrderInput | SortOrder
    bedStatusId?: SortOrderInput | SortOrder
    room?: RoomOrderByWithRelationInput
    bedStatus?: BedStatusOrderByWithRelationInput
  }

  export type BedWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: BedWhereInput | BedWhereInput[]
    OR?: BedWhereInput[]
    NOT?: BedWhereInput | BedWhereInput[]
    displayName?: StringFilter<"Bed"> | string
    bedNumber?: IntFilter<"Bed"> | number
    isEnabled?: BoolFilter<"Bed"> | boolean
    roomId?: IntNullableFilter<"Bed"> | number | null
    bedStatusId?: IntNullableFilter<"Bed"> | number | null
    room?: XOR<RoomNullableScalarRelationFilter, RoomWhereInput> | null
    bedStatus?: XOR<BedStatusNullableScalarRelationFilter, BedStatusWhereInput> | null
  }, "id">

  export type BedOrderByWithAggregationInput = {
    id?: SortOrder
    displayName?: SortOrder
    bedNumber?: SortOrder
    isEnabled?: SortOrder
    roomId?: SortOrderInput | SortOrder
    bedStatusId?: SortOrderInput | SortOrder
    _count?: BedCountOrderByAggregateInput
    _avg?: BedAvgOrderByAggregateInput
    _max?: BedMaxOrderByAggregateInput
    _min?: BedMinOrderByAggregateInput
    _sum?: BedSumOrderByAggregateInput
  }

  export type BedScalarWhereWithAggregatesInput = {
    AND?: BedScalarWhereWithAggregatesInput | BedScalarWhereWithAggregatesInput[]
    OR?: BedScalarWhereWithAggregatesInput[]
    NOT?: BedScalarWhereWithAggregatesInput | BedScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Bed"> | number
    displayName?: StringWithAggregatesFilter<"Bed"> | string
    bedNumber?: IntWithAggregatesFilter<"Bed"> | number
    isEnabled?: BoolWithAggregatesFilter<"Bed"> | boolean
    roomId?: IntNullableWithAggregatesFilter<"Bed"> | number | null
    bedStatusId?: IntNullableWithAggregatesFilter<"Bed"> | number | null
  }

  export type RoomWhereInput = {
    AND?: RoomWhereInput | RoomWhereInput[]
    OR?: RoomWhereInput[]
    NOT?: RoomWhereInput | RoomWhereInput[]
    id?: IntFilter<"Room"> | number
    roomName?: StringFilter<"Room"> | string
    isEnabled?: BoolFilter<"Room"> | boolean
    unitId?: IntNullableFilter<"Room"> | number | null
    classId?: IntNullableFilter<"Room"> | number | null
    unit?: XOR<UnitNullableScalarRelationFilter, UnitWhereInput> | null
    class?: XOR<ClassNullableScalarRelationFilter, ClassWhereInput> | null
    beds?: BedListRelationFilter
  }

  export type RoomOrderByWithRelationInput = {
    id?: SortOrder
    roomName?: SortOrder
    isEnabled?: SortOrder
    unitId?: SortOrderInput | SortOrder
    classId?: SortOrderInput | SortOrder
    unit?: UnitOrderByWithRelationInput
    class?: ClassOrderByWithRelationInput
    beds?: BedOrderByRelationAggregateInput
  }

  export type RoomWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: RoomWhereInput | RoomWhereInput[]
    OR?: RoomWhereInput[]
    NOT?: RoomWhereInput | RoomWhereInput[]
    roomName?: StringFilter<"Room"> | string
    isEnabled?: BoolFilter<"Room"> | boolean
    unitId?: IntNullableFilter<"Room"> | number | null
    classId?: IntNullableFilter<"Room"> | number | null
    unit?: XOR<UnitNullableScalarRelationFilter, UnitWhereInput> | null
    class?: XOR<ClassNullableScalarRelationFilter, ClassWhereInput> | null
    beds?: BedListRelationFilter
  }, "id">

  export type RoomOrderByWithAggregationInput = {
    id?: SortOrder
    roomName?: SortOrder
    isEnabled?: SortOrder
    unitId?: SortOrderInput | SortOrder
    classId?: SortOrderInput | SortOrder
    _count?: RoomCountOrderByAggregateInput
    _avg?: RoomAvgOrderByAggregateInput
    _max?: RoomMaxOrderByAggregateInput
    _min?: RoomMinOrderByAggregateInput
    _sum?: RoomSumOrderByAggregateInput
  }

  export type RoomScalarWhereWithAggregatesInput = {
    AND?: RoomScalarWhereWithAggregatesInput | RoomScalarWhereWithAggregatesInput[]
    OR?: RoomScalarWhereWithAggregatesInput[]
    NOT?: RoomScalarWhereWithAggregatesInput | RoomScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Room"> | number
    roomName?: StringWithAggregatesFilter<"Room"> | string
    isEnabled?: BoolWithAggregatesFilter<"Room"> | boolean
    unitId?: IntNullableWithAggregatesFilter<"Room"> | number | null
    classId?: IntNullableWithAggregatesFilter<"Room"> | number | null
  }

  export type UnitWhereInput = {
    AND?: UnitWhereInput | UnitWhereInput[]
    OR?: UnitWhereInput[]
    NOT?: UnitWhereInput | UnitWhereInput[]
    id?: IntFilter<"Unit"> | number
    unitName?: StringFilter<"Unit"> | string
    isEnabled?: BoolFilter<"Unit"> | boolean
    departmentId?: IntNullableFilter<"Unit"> | number | null
    rooms?: RoomListRelationFilter
    department?: XOR<DepartmentNullableScalarRelationFilter, DepartmentWhereInput> | null
    stockDetails?: StockDetailListRelationFilter
    doctorSchedules?: DoctorScheduleListRelationFilter
    reservations?: ReservationListRelationFilter
  }

  export type UnitOrderByWithRelationInput = {
    id?: SortOrder
    unitName?: SortOrder
    isEnabled?: SortOrder
    departmentId?: SortOrderInput | SortOrder
    rooms?: RoomOrderByRelationAggregateInput
    department?: DepartmentOrderByWithRelationInput
    stockDetails?: StockDetailOrderByRelationAggregateInput
    doctorSchedules?: DoctorScheduleOrderByRelationAggregateInput
    reservations?: ReservationOrderByRelationAggregateInput
  }

  export type UnitWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: UnitWhereInput | UnitWhereInput[]
    OR?: UnitWhereInput[]
    NOT?: UnitWhereInput | UnitWhereInput[]
    unitName?: StringFilter<"Unit"> | string
    isEnabled?: BoolFilter<"Unit"> | boolean
    departmentId?: IntNullableFilter<"Unit"> | number | null
    rooms?: RoomListRelationFilter
    department?: XOR<DepartmentNullableScalarRelationFilter, DepartmentWhereInput> | null
    stockDetails?: StockDetailListRelationFilter
    doctorSchedules?: DoctorScheduleListRelationFilter
    reservations?: ReservationListRelationFilter
  }, "id">

  export type UnitOrderByWithAggregationInput = {
    id?: SortOrder
    unitName?: SortOrder
    isEnabled?: SortOrder
    departmentId?: SortOrderInput | SortOrder
    _count?: UnitCountOrderByAggregateInput
    _avg?: UnitAvgOrderByAggregateInput
    _max?: UnitMaxOrderByAggregateInput
    _min?: UnitMinOrderByAggregateInput
    _sum?: UnitSumOrderByAggregateInput
  }

  export type UnitScalarWhereWithAggregatesInput = {
    AND?: UnitScalarWhereWithAggregatesInput | UnitScalarWhereWithAggregatesInput[]
    OR?: UnitScalarWhereWithAggregatesInput[]
    NOT?: UnitScalarWhereWithAggregatesInput | UnitScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Unit"> | number
    unitName?: StringWithAggregatesFilter<"Unit"> | string
    isEnabled?: BoolWithAggregatesFilter<"Unit"> | boolean
    departmentId?: IntNullableWithAggregatesFilter<"Unit"> | number | null
  }

  export type BedStatusWhereInput = {
    AND?: BedStatusWhereInput | BedStatusWhereInput[]
    OR?: BedStatusWhereInput[]
    NOT?: BedStatusWhereInput | BedStatusWhereInput[]
    id?: IntFilter<"BedStatus"> | number
    status?: StringFilter<"BedStatus"> | string
    isEnabled?: BoolFilter<"BedStatus"> | boolean
    beds?: BedListRelationFilter
  }

  export type BedStatusOrderByWithRelationInput = {
    id?: SortOrder
    status?: SortOrder
    isEnabled?: SortOrder
    beds?: BedOrderByRelationAggregateInput
  }

  export type BedStatusWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: BedStatusWhereInput | BedStatusWhereInput[]
    OR?: BedStatusWhereInput[]
    NOT?: BedStatusWhereInput | BedStatusWhereInput[]
    status?: StringFilter<"BedStatus"> | string
    isEnabled?: BoolFilter<"BedStatus"> | boolean
    beds?: BedListRelationFilter
  }, "id">

  export type BedStatusOrderByWithAggregationInput = {
    id?: SortOrder
    status?: SortOrder
    isEnabled?: SortOrder
    _count?: BedStatusCountOrderByAggregateInput
    _avg?: BedStatusAvgOrderByAggregateInput
    _max?: BedStatusMaxOrderByAggregateInput
    _min?: BedStatusMinOrderByAggregateInput
    _sum?: BedStatusSumOrderByAggregateInput
  }

  export type BedStatusScalarWhereWithAggregatesInput = {
    AND?: BedStatusScalarWhereWithAggregatesInput | BedStatusScalarWhereWithAggregatesInput[]
    OR?: BedStatusScalarWhereWithAggregatesInput[]
    NOT?: BedStatusScalarWhereWithAggregatesInput | BedStatusScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"BedStatus"> | number
    status?: StringWithAggregatesFilter<"BedStatus"> | string
    isEnabled?: BoolWithAggregatesFilter<"BedStatus"> | boolean
  }

  export type ClassWhereInput = {
    AND?: ClassWhereInput | ClassWhereInput[]
    OR?: ClassWhereInput[]
    NOT?: ClassWhereInput | ClassWhereInput[]
    id?: IntFilter<"Class"> | number
    className?: StringFilter<"Class"> | string
    isEnabled?: BoolFilter<"Class"> | boolean
    rooms?: RoomListRelationFilter
  }

  export type ClassOrderByWithRelationInput = {
    id?: SortOrder
    className?: SortOrder
    isEnabled?: SortOrder
    rooms?: RoomOrderByRelationAggregateInput
  }

  export type ClassWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ClassWhereInput | ClassWhereInput[]
    OR?: ClassWhereInput[]
    NOT?: ClassWhereInput | ClassWhereInput[]
    className?: StringFilter<"Class"> | string
    isEnabled?: BoolFilter<"Class"> | boolean
    rooms?: RoomListRelationFilter
  }, "id">

  export type ClassOrderByWithAggregationInput = {
    id?: SortOrder
    className?: SortOrder
    isEnabled?: SortOrder
    _count?: ClassCountOrderByAggregateInput
    _avg?: ClassAvgOrderByAggregateInput
    _max?: ClassMaxOrderByAggregateInput
    _min?: ClassMinOrderByAggregateInput
    _sum?: ClassSumOrderByAggregateInput
  }

  export type ClassScalarWhereWithAggregatesInput = {
    AND?: ClassScalarWhereWithAggregatesInput | ClassScalarWhereWithAggregatesInput[]
    OR?: ClassScalarWhereWithAggregatesInput[]
    NOT?: ClassScalarWhereWithAggregatesInput | ClassScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Class"> | number
    className?: StringWithAggregatesFilter<"Class"> | string
    isEnabled?: BoolWithAggregatesFilter<"Class"> | boolean
  }

  export type DepartmentWhereInput = {
    AND?: DepartmentWhereInput | DepartmentWhereInput[]
    OR?: DepartmentWhereInput[]
    NOT?: DepartmentWhereInput | DepartmentWhereInput[]
    id?: IntFilter<"Department"> | number
    departmentName?: StringFilter<"Department"> | string
    isEnabled?: BoolFilter<"Department"> | boolean
    units?: UnitListRelationFilter
  }

  export type DepartmentOrderByWithRelationInput = {
    id?: SortOrder
    departmentName?: SortOrder
    isEnabled?: SortOrder
    units?: UnitOrderByRelationAggregateInput
  }

  export type DepartmentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: DepartmentWhereInput | DepartmentWhereInput[]
    OR?: DepartmentWhereInput[]
    NOT?: DepartmentWhereInput | DepartmentWhereInput[]
    departmentName?: StringFilter<"Department"> | string
    isEnabled?: BoolFilter<"Department"> | boolean
    units?: UnitListRelationFilter
  }, "id">

  export type DepartmentOrderByWithAggregationInput = {
    id?: SortOrder
    departmentName?: SortOrder
    isEnabled?: SortOrder
    _count?: DepartmentCountOrderByAggregateInput
    _avg?: DepartmentAvgOrderByAggregateInput
    _max?: DepartmentMaxOrderByAggregateInput
    _min?: DepartmentMinOrderByAggregateInput
    _sum?: DepartmentSumOrderByAggregateInput
  }

  export type DepartmentScalarWhereWithAggregatesInput = {
    AND?: DepartmentScalarWhereWithAggregatesInput | DepartmentScalarWhereWithAggregatesInput[]
    OR?: DepartmentScalarWhereWithAggregatesInput[]
    NOT?: DepartmentScalarWhereWithAggregatesInput | DepartmentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Department"> | number
    departmentName?: StringWithAggregatesFilter<"Department"> | string
    isEnabled?: BoolWithAggregatesFilter<"Department"> | boolean
  }

  export type ProductWhereInput = {
    AND?: ProductWhereInput | ProductWhereInput[]
    OR?: ProductWhereInput[]
    NOT?: ProductWhereInput | ProductWhereInput[]
    id?: IntFilter<"Product"> | number
    productName?: StringFilter<"Product"> | string
    isEnabled?: BoolFilter<"Product"> | boolean
    stockDetails?: StockDetailListRelationFilter
  }

  export type ProductOrderByWithRelationInput = {
    id?: SortOrder
    productName?: SortOrder
    isEnabled?: SortOrder
    stockDetails?: StockDetailOrderByRelationAggregateInput
  }

  export type ProductWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ProductWhereInput | ProductWhereInput[]
    OR?: ProductWhereInput[]
    NOT?: ProductWhereInput | ProductWhereInput[]
    productName?: StringFilter<"Product"> | string
    isEnabled?: BoolFilter<"Product"> | boolean
    stockDetails?: StockDetailListRelationFilter
  }, "id">

  export type ProductOrderByWithAggregationInput = {
    id?: SortOrder
    productName?: SortOrder
    isEnabled?: SortOrder
    _count?: ProductCountOrderByAggregateInput
    _avg?: ProductAvgOrderByAggregateInput
    _max?: ProductMaxOrderByAggregateInput
    _min?: ProductMinOrderByAggregateInput
    _sum?: ProductSumOrderByAggregateInput
  }

  export type ProductScalarWhereWithAggregatesInput = {
    AND?: ProductScalarWhereWithAggregatesInput | ProductScalarWhereWithAggregatesInput[]
    OR?: ProductScalarWhereWithAggregatesInput[]
    NOT?: ProductScalarWhereWithAggregatesInput | ProductScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Product"> | number
    productName?: StringWithAggregatesFilter<"Product"> | string
    isEnabled?: BoolWithAggregatesFilter<"Product"> | boolean
  }

  export type ServiceReceiptWhereInput = {
    AND?: ServiceReceiptWhereInput | ServiceReceiptWhereInput[]
    OR?: ServiceReceiptWhereInput[]
    NOT?: ServiceReceiptWhereInput | ServiceReceiptWhereInput[]
    id?: StringFilter<"ServiceReceipt"> | string
    receiptAt?: DateTimeFilter<"ServiceReceipt"> | Date | string
    stockDetails?: StockDetailListRelationFilter
  }

  export type ServiceReceiptOrderByWithRelationInput = {
    id?: SortOrder
    receiptAt?: SortOrder
    stockDetails?: StockDetailOrderByRelationAggregateInput
  }

  export type ServiceReceiptWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ServiceReceiptWhereInput | ServiceReceiptWhereInput[]
    OR?: ServiceReceiptWhereInput[]
    NOT?: ServiceReceiptWhereInput | ServiceReceiptWhereInput[]
    receiptAt?: DateTimeFilter<"ServiceReceipt"> | Date | string
    stockDetails?: StockDetailListRelationFilter
  }, "id">

  export type ServiceReceiptOrderByWithAggregationInput = {
    id?: SortOrder
    receiptAt?: SortOrder
    _count?: ServiceReceiptCountOrderByAggregateInput
    _max?: ServiceReceiptMaxOrderByAggregateInput
    _min?: ServiceReceiptMinOrderByAggregateInput
  }

  export type ServiceReceiptScalarWhereWithAggregatesInput = {
    AND?: ServiceReceiptScalarWhereWithAggregatesInput | ServiceReceiptScalarWhereWithAggregatesInput[]
    OR?: ServiceReceiptScalarWhereWithAggregatesInput[]
    NOT?: ServiceReceiptScalarWhereWithAggregatesInput | ServiceReceiptScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ServiceReceipt"> | string
    receiptAt?: DateTimeWithAggregatesFilter<"ServiceReceipt"> | Date | string
  }

  export type StockDetailWhereInput = {
    AND?: StockDetailWhereInput | StockDetailWhereInput[]
    OR?: StockDetailWhereInput[]
    NOT?: StockDetailWhereInput | StockDetailWhereInput[]
    id?: StringFilter<"StockDetail"> | string
    productId?: IntFilter<"StockDetail"> | number
    unitId?: IntFilter<"StockDetail"> | number
    receiptId?: StringFilter<"StockDetail"> | string
    sourceProductId?: IntNullableFilter<"StockDetail"> | number | null
    netPrice?: FloatNullableFilter<"StockDetail"> | number | null
    discountPrice?: FloatNullableFilter<"StockDetail"> | number | null
    quantity?: FloatFilter<"StockDetail"> | number
    isEnabled?: BoolFilter<"StockDetail"> | boolean
    expiredAt?: DateTimeNullableFilter<"StockDetail"> | Date | string | null
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    unit?: XOR<UnitScalarRelationFilter, UnitWhereInput>
    receipt?: XOR<ServiceReceiptScalarRelationFilter, ServiceReceiptWhereInput>
  }

  export type StockDetailOrderByWithRelationInput = {
    id?: SortOrder
    productId?: SortOrder
    unitId?: SortOrder
    receiptId?: SortOrder
    sourceProductId?: SortOrderInput | SortOrder
    netPrice?: SortOrderInput | SortOrder
    discountPrice?: SortOrderInput | SortOrder
    quantity?: SortOrder
    isEnabled?: SortOrder
    expiredAt?: SortOrderInput | SortOrder
    product?: ProductOrderByWithRelationInput
    unit?: UnitOrderByWithRelationInput
    receipt?: ServiceReceiptOrderByWithRelationInput
  }

  export type StockDetailWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: StockDetailWhereInput | StockDetailWhereInput[]
    OR?: StockDetailWhereInput[]
    NOT?: StockDetailWhereInput | StockDetailWhereInput[]
    productId?: IntFilter<"StockDetail"> | number
    unitId?: IntFilter<"StockDetail"> | number
    receiptId?: StringFilter<"StockDetail"> | string
    sourceProductId?: IntNullableFilter<"StockDetail"> | number | null
    netPrice?: FloatNullableFilter<"StockDetail"> | number | null
    discountPrice?: FloatNullableFilter<"StockDetail"> | number | null
    quantity?: FloatFilter<"StockDetail"> | number
    isEnabled?: BoolFilter<"StockDetail"> | boolean
    expiredAt?: DateTimeNullableFilter<"StockDetail"> | Date | string | null
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    unit?: XOR<UnitScalarRelationFilter, UnitWhereInput>
    receipt?: XOR<ServiceReceiptScalarRelationFilter, ServiceReceiptWhereInput>
  }, "id">

  export type StockDetailOrderByWithAggregationInput = {
    id?: SortOrder
    productId?: SortOrder
    unitId?: SortOrder
    receiptId?: SortOrder
    sourceProductId?: SortOrderInput | SortOrder
    netPrice?: SortOrderInput | SortOrder
    discountPrice?: SortOrderInput | SortOrder
    quantity?: SortOrder
    isEnabled?: SortOrder
    expiredAt?: SortOrderInput | SortOrder
    _count?: StockDetailCountOrderByAggregateInput
    _avg?: StockDetailAvgOrderByAggregateInput
    _max?: StockDetailMaxOrderByAggregateInput
    _min?: StockDetailMinOrderByAggregateInput
    _sum?: StockDetailSumOrderByAggregateInput
  }

  export type StockDetailScalarWhereWithAggregatesInput = {
    AND?: StockDetailScalarWhereWithAggregatesInput | StockDetailScalarWhereWithAggregatesInput[]
    OR?: StockDetailScalarWhereWithAggregatesInput[]
    NOT?: StockDetailScalarWhereWithAggregatesInput | StockDetailScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"StockDetail"> | string
    productId?: IntWithAggregatesFilter<"StockDetail"> | number
    unitId?: IntWithAggregatesFilter<"StockDetail"> | number
    receiptId?: StringWithAggregatesFilter<"StockDetail"> | string
    sourceProductId?: IntNullableWithAggregatesFilter<"StockDetail"> | number | null
    netPrice?: FloatNullableWithAggregatesFilter<"StockDetail"> | number | null
    discountPrice?: FloatNullableWithAggregatesFilter<"StockDetail"> | number | null
    quantity?: FloatWithAggregatesFilter<"StockDetail"> | number
    isEnabled?: BoolWithAggregatesFilter<"StockDetail"> | boolean
    expiredAt?: DateTimeNullableWithAggregatesFilter<"StockDetail"> | Date | string | null
  }

  export type DoctorScheduleWhereInput = {
    AND?: DoctorScheduleWhereInput | DoctorScheduleWhereInput[]
    OR?: DoctorScheduleWhereInput[]
    NOT?: DoctorScheduleWhereInput | DoctorScheduleWhereInput[]
    id?: IntFilter<"DoctorSchedule"> | number
    unitId?: IntFilter<"DoctorSchedule"> | number
    doctorId?: IntFilter<"DoctorSchedule"> | number
    startTime?: DateTimeFilter<"DoctorSchedule"> | Date | string
    endTime?: DateTimeFilter<"DoctorSchedule"> | Date | string
    note?: StringNullableFilter<"DoctorSchedule"> | string | null
    days?: StringFilter<"DoctorSchedule"> | string
    quota?: IntFilter<"DoctorSchedule"> | number
    isEnabled?: BoolFilter<"DoctorSchedule"> | boolean
    unit?: XOR<UnitScalarRelationFilter, UnitWhereInput>
    doctor?: XOR<EmployeeScalarRelationFilter, EmployeeWhereInput>
  }

  export type DoctorScheduleOrderByWithRelationInput = {
    id?: SortOrder
    unitId?: SortOrder
    doctorId?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    note?: SortOrderInput | SortOrder
    days?: SortOrder
    quota?: SortOrder
    isEnabled?: SortOrder
    unit?: UnitOrderByWithRelationInput
    doctor?: EmployeeOrderByWithRelationInput
  }

  export type DoctorScheduleWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: DoctorScheduleWhereInput | DoctorScheduleWhereInput[]
    OR?: DoctorScheduleWhereInput[]
    NOT?: DoctorScheduleWhereInput | DoctorScheduleWhereInput[]
    unitId?: IntFilter<"DoctorSchedule"> | number
    doctorId?: IntFilter<"DoctorSchedule"> | number
    startTime?: DateTimeFilter<"DoctorSchedule"> | Date | string
    endTime?: DateTimeFilter<"DoctorSchedule"> | Date | string
    note?: StringNullableFilter<"DoctorSchedule"> | string | null
    days?: StringFilter<"DoctorSchedule"> | string
    quota?: IntFilter<"DoctorSchedule"> | number
    isEnabled?: BoolFilter<"DoctorSchedule"> | boolean
    unit?: XOR<UnitScalarRelationFilter, UnitWhereInput>
    doctor?: XOR<EmployeeScalarRelationFilter, EmployeeWhereInput>
  }, "id">

  export type DoctorScheduleOrderByWithAggregationInput = {
    id?: SortOrder
    unitId?: SortOrder
    doctorId?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    note?: SortOrderInput | SortOrder
    days?: SortOrder
    quota?: SortOrder
    isEnabled?: SortOrder
    _count?: DoctorScheduleCountOrderByAggregateInput
    _avg?: DoctorScheduleAvgOrderByAggregateInput
    _max?: DoctorScheduleMaxOrderByAggregateInput
    _min?: DoctorScheduleMinOrderByAggregateInput
    _sum?: DoctorScheduleSumOrderByAggregateInput
  }

  export type DoctorScheduleScalarWhereWithAggregatesInput = {
    AND?: DoctorScheduleScalarWhereWithAggregatesInput | DoctorScheduleScalarWhereWithAggregatesInput[]
    OR?: DoctorScheduleScalarWhereWithAggregatesInput[]
    NOT?: DoctorScheduleScalarWhereWithAggregatesInput | DoctorScheduleScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"DoctorSchedule"> | number
    unitId?: IntWithAggregatesFilter<"DoctorSchedule"> | number
    doctorId?: IntWithAggregatesFilter<"DoctorSchedule"> | number
    startTime?: DateTimeWithAggregatesFilter<"DoctorSchedule"> | Date | string
    endTime?: DateTimeWithAggregatesFilter<"DoctorSchedule"> | Date | string
    note?: StringNullableWithAggregatesFilter<"DoctorSchedule"> | string | null
    days?: StringWithAggregatesFilter<"DoctorSchedule"> | string
    quota?: IntWithAggregatesFilter<"DoctorSchedule"> | number
    isEnabled?: BoolWithAggregatesFilter<"DoctorSchedule"> | boolean
  }

  export type EmployeeWhereInput = {
    AND?: EmployeeWhereInput | EmployeeWhereInput[]
    OR?: EmployeeWhereInput[]
    NOT?: EmployeeWhereInput | EmployeeWhereInput[]
    id?: IntFilter<"Employee"> | number
    fullName?: StringFilter<"Employee"> | string
    identityNo?: StringNullableFilter<"Employee"> | string | null
    isEnabled?: BoolFilter<"Employee"> | boolean
    doctorSchedules?: DoctorScheduleListRelationFilter
    reservations?: ReservationListRelationFilter
  }

  export type EmployeeOrderByWithRelationInput = {
    id?: SortOrder
    fullName?: SortOrder
    identityNo?: SortOrderInput | SortOrder
    isEnabled?: SortOrder
    doctorSchedules?: DoctorScheduleOrderByRelationAggregateInput
    reservations?: ReservationOrderByRelationAggregateInput
  }

  export type EmployeeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: EmployeeWhereInput | EmployeeWhereInput[]
    OR?: EmployeeWhereInput[]
    NOT?: EmployeeWhereInput | EmployeeWhereInput[]
    fullName?: StringFilter<"Employee"> | string
    identityNo?: StringNullableFilter<"Employee"> | string | null
    isEnabled?: BoolFilter<"Employee"> | boolean
    doctorSchedules?: DoctorScheduleListRelationFilter
    reservations?: ReservationListRelationFilter
  }, "id">

  export type EmployeeOrderByWithAggregationInput = {
    id?: SortOrder
    fullName?: SortOrder
    identityNo?: SortOrderInput | SortOrder
    isEnabled?: SortOrder
    _count?: EmployeeCountOrderByAggregateInput
    _avg?: EmployeeAvgOrderByAggregateInput
    _max?: EmployeeMaxOrderByAggregateInput
    _min?: EmployeeMinOrderByAggregateInput
    _sum?: EmployeeSumOrderByAggregateInput
  }

  export type EmployeeScalarWhereWithAggregatesInput = {
    AND?: EmployeeScalarWhereWithAggregatesInput | EmployeeScalarWhereWithAggregatesInput[]
    OR?: EmployeeScalarWhereWithAggregatesInput[]
    NOT?: EmployeeScalarWhereWithAggregatesInput | EmployeeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Employee"> | number
    fullName?: StringWithAggregatesFilter<"Employee"> | string
    identityNo?: StringNullableWithAggregatesFilter<"Employee"> | string | null
    isEnabled?: BoolWithAggregatesFilter<"Employee"> | boolean
  }

  export type ReservationWhereInput = {
    AND?: ReservationWhereInput | ReservationWhereInput[]
    OR?: ReservationWhereInput[]
    NOT?: ReservationWhereInput | ReservationWhereInput[]
    id?: StringFilter<"Reservation"> | string
    isEnabled?: BoolFilter<"Reservation"> | boolean
    unitId?: IntFilter<"Reservation"> | number
    identity?: StringFilter<"Reservation"> | string
    queueNumber?: IntFilter<"Reservation"> | number
    reservationNumber?: StringFilter<"Reservation"> | string
    reservationDate?: DateTimeFilter<"Reservation"> | Date | string
    paymentMethodId?: IntFilter<"Reservation"> | number
    bpjsNumber?: StringNullableFilter<"Reservation"> | string | null
    otherInsuranceNumber?: StringNullableFilter<"Reservation"> | string | null
    createdAt?: DateTimeFilter<"Reservation"> | Date | string
    referralNumber?: StringNullableFilter<"Reservation"> | string | null
    doctorId?: IntNullableFilter<"Reservation"> | number | null
    notes?: StringNullableFilter<"Reservation"> | string | null
    queueType?: StringFilter<"Reservation"> | string
    referralSourceId?: IntNullableFilter<"Reservation"> | number | null
    isConfirmed?: BoolFilter<"Reservation"> | boolean
    callStatus?: StringFilter<"Reservation"> | string
    isCancelled?: BoolFilter<"Reservation"> | boolean
    cancelReason?: StringNullableFilter<"Reservation"> | string | null
    educationId?: IntNullableFilter<"Reservation"> | number | null
    type?: StringNullableFilter<"Reservation"> | string | null
    patientType?: StringNullableFilter<"Reservation"> | string | null
    unit?: XOR<UnitScalarRelationFilter, UnitWhereInput>
    patient?: XOR<PatientNullableScalarRelationFilter, PatientWhereInput> | null
    paymentMethod?: XOR<PaymentMethodScalarRelationFilter, PaymentMethodWhereInput>
    doctor?: XOR<EmployeeNullableScalarRelationFilter, EmployeeWhereInput> | null
    referralSource?: XOR<ReferralSourceNullableScalarRelationFilter, ReferralSourceWhereInput> | null
  }

  export type ReservationOrderByWithRelationInput = {
    id?: SortOrder
    isEnabled?: SortOrder
    unitId?: SortOrder
    identity?: SortOrder
    queueNumber?: SortOrder
    reservationNumber?: SortOrder
    reservationDate?: SortOrder
    paymentMethodId?: SortOrder
    bpjsNumber?: SortOrderInput | SortOrder
    otherInsuranceNumber?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    referralNumber?: SortOrderInput | SortOrder
    doctorId?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    queueType?: SortOrder
    referralSourceId?: SortOrderInput | SortOrder
    isConfirmed?: SortOrder
    callStatus?: SortOrder
    isCancelled?: SortOrder
    cancelReason?: SortOrderInput | SortOrder
    educationId?: SortOrderInput | SortOrder
    type?: SortOrderInput | SortOrder
    patientType?: SortOrderInput | SortOrder
    unit?: UnitOrderByWithRelationInput
    patient?: PatientOrderByWithRelationInput
    paymentMethod?: PaymentMethodOrderByWithRelationInput
    doctor?: EmployeeOrderByWithRelationInput
    referralSource?: ReferralSourceOrderByWithRelationInput
  }

  export type ReservationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ReservationWhereInput | ReservationWhereInput[]
    OR?: ReservationWhereInput[]
    NOT?: ReservationWhereInput | ReservationWhereInput[]
    isEnabled?: BoolFilter<"Reservation"> | boolean
    unitId?: IntFilter<"Reservation"> | number
    identity?: StringFilter<"Reservation"> | string
    queueNumber?: IntFilter<"Reservation"> | number
    reservationNumber?: StringFilter<"Reservation"> | string
    reservationDate?: DateTimeFilter<"Reservation"> | Date | string
    paymentMethodId?: IntFilter<"Reservation"> | number
    bpjsNumber?: StringNullableFilter<"Reservation"> | string | null
    otherInsuranceNumber?: StringNullableFilter<"Reservation"> | string | null
    createdAt?: DateTimeFilter<"Reservation"> | Date | string
    referralNumber?: StringNullableFilter<"Reservation"> | string | null
    doctorId?: IntNullableFilter<"Reservation"> | number | null
    notes?: StringNullableFilter<"Reservation"> | string | null
    queueType?: StringFilter<"Reservation"> | string
    referralSourceId?: IntNullableFilter<"Reservation"> | number | null
    isConfirmed?: BoolFilter<"Reservation"> | boolean
    callStatus?: StringFilter<"Reservation"> | string
    isCancelled?: BoolFilter<"Reservation"> | boolean
    cancelReason?: StringNullableFilter<"Reservation"> | string | null
    educationId?: IntNullableFilter<"Reservation"> | number | null
    type?: StringNullableFilter<"Reservation"> | string | null
    patientType?: StringNullableFilter<"Reservation"> | string | null
    unit?: XOR<UnitScalarRelationFilter, UnitWhereInput>
    patient?: XOR<PatientNullableScalarRelationFilter, PatientWhereInput> | null
    paymentMethod?: XOR<PaymentMethodScalarRelationFilter, PaymentMethodWhereInput>
    doctor?: XOR<EmployeeNullableScalarRelationFilter, EmployeeWhereInput> | null
    referralSource?: XOR<ReferralSourceNullableScalarRelationFilter, ReferralSourceWhereInput> | null
  }, "id">

  export type ReservationOrderByWithAggregationInput = {
    id?: SortOrder
    isEnabled?: SortOrder
    unitId?: SortOrder
    identity?: SortOrder
    queueNumber?: SortOrder
    reservationNumber?: SortOrder
    reservationDate?: SortOrder
    paymentMethodId?: SortOrder
    bpjsNumber?: SortOrderInput | SortOrder
    otherInsuranceNumber?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    referralNumber?: SortOrderInput | SortOrder
    doctorId?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    queueType?: SortOrder
    referralSourceId?: SortOrderInput | SortOrder
    isConfirmed?: SortOrder
    callStatus?: SortOrder
    isCancelled?: SortOrder
    cancelReason?: SortOrderInput | SortOrder
    educationId?: SortOrderInput | SortOrder
    type?: SortOrderInput | SortOrder
    patientType?: SortOrderInput | SortOrder
    _count?: ReservationCountOrderByAggregateInput
    _avg?: ReservationAvgOrderByAggregateInput
    _max?: ReservationMaxOrderByAggregateInput
    _min?: ReservationMinOrderByAggregateInput
    _sum?: ReservationSumOrderByAggregateInput
  }

  export type ReservationScalarWhereWithAggregatesInput = {
    AND?: ReservationScalarWhereWithAggregatesInput | ReservationScalarWhereWithAggregatesInput[]
    OR?: ReservationScalarWhereWithAggregatesInput[]
    NOT?: ReservationScalarWhereWithAggregatesInput | ReservationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Reservation"> | string
    isEnabled?: BoolWithAggregatesFilter<"Reservation"> | boolean
    unitId?: IntWithAggregatesFilter<"Reservation"> | number
    identity?: StringWithAggregatesFilter<"Reservation"> | string
    queueNumber?: IntWithAggregatesFilter<"Reservation"> | number
    reservationNumber?: StringWithAggregatesFilter<"Reservation"> | string
    reservationDate?: DateTimeWithAggregatesFilter<"Reservation"> | Date | string
    paymentMethodId?: IntWithAggregatesFilter<"Reservation"> | number
    bpjsNumber?: StringNullableWithAggregatesFilter<"Reservation"> | string | null
    otherInsuranceNumber?: StringNullableWithAggregatesFilter<"Reservation"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Reservation"> | Date | string
    referralNumber?: StringNullableWithAggregatesFilter<"Reservation"> | string | null
    doctorId?: IntNullableWithAggregatesFilter<"Reservation"> | number | null
    notes?: StringNullableWithAggregatesFilter<"Reservation"> | string | null
    queueType?: StringWithAggregatesFilter<"Reservation"> | string
    referralSourceId?: IntNullableWithAggregatesFilter<"Reservation"> | number | null
    isConfirmed?: BoolWithAggregatesFilter<"Reservation"> | boolean
    callStatus?: StringWithAggregatesFilter<"Reservation"> | string
    isCancelled?: BoolWithAggregatesFilter<"Reservation"> | boolean
    cancelReason?: StringNullableWithAggregatesFilter<"Reservation"> | string | null
    educationId?: IntNullableWithAggregatesFilter<"Reservation"> | number | null
    type?: StringNullableWithAggregatesFilter<"Reservation"> | string | null
    patientType?: StringNullableWithAggregatesFilter<"Reservation"> | string | null
  }

  export type PatientWhereInput = {
    AND?: PatientWhereInput | PatientWhereInput[]
    OR?: PatientWhereInput[]
    NOT?: PatientWhereInput | PatientWhereInput[]
    id?: IntFilter<"Patient"> | number
    isEnabled?: BoolFilter<"Patient"> | boolean
    name?: StringNullableFilter<"Patient"> | string | null
    identity?: StringFilter<"Patient"> | string
    genderId?: IntNullableFilter<"Patient"> | number | null
    birthPlace?: StringNullableFilter<"Patient"> | string | null
    birthDate?: DateTimeNullableFilter<"Patient"> | Date | string | null
    motherName?: StringNullableFilter<"Patient"> | string | null
    fatherName?: StringNullableFilter<"Patient"> | string | null
    spouseName?: StringNullableFilter<"Patient"> | string | null
    bpjsNumber?: StringNullableFilter<"Patient"> | string | null
    otherInsuranceNumber?: StringNullableFilter<"Patient"> | string | null
    phoneNumber?: StringNullableFilter<"Patient"> | string | null
    registeredAt?: DateTimeNullableFilter<"Patient"> | Date | string | null
    homeAddress?: StringNullableFilter<"Patient"> | string | null
    gender?: XOR<GenderNullableScalarRelationFilter, GenderWhereInput> | null
    reservations?: ReservationListRelationFilter
  }

  export type PatientOrderByWithRelationInput = {
    id?: SortOrder
    isEnabled?: SortOrder
    name?: SortOrderInput | SortOrder
    identity?: SortOrder
    genderId?: SortOrderInput | SortOrder
    birthPlace?: SortOrderInput | SortOrder
    birthDate?: SortOrderInput | SortOrder
    motherName?: SortOrderInput | SortOrder
    fatherName?: SortOrderInput | SortOrder
    spouseName?: SortOrderInput | SortOrder
    bpjsNumber?: SortOrderInput | SortOrder
    otherInsuranceNumber?: SortOrderInput | SortOrder
    phoneNumber?: SortOrderInput | SortOrder
    registeredAt?: SortOrderInput | SortOrder
    homeAddress?: SortOrderInput | SortOrder
    gender?: GenderOrderByWithRelationInput
    reservations?: ReservationOrderByRelationAggregateInput
  }

  export type PatientWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    identity?: string
    AND?: PatientWhereInput | PatientWhereInput[]
    OR?: PatientWhereInput[]
    NOT?: PatientWhereInput | PatientWhereInput[]
    isEnabled?: BoolFilter<"Patient"> | boolean
    name?: StringNullableFilter<"Patient"> | string | null
    genderId?: IntNullableFilter<"Patient"> | number | null
    birthPlace?: StringNullableFilter<"Patient"> | string | null
    birthDate?: DateTimeNullableFilter<"Patient"> | Date | string | null
    motherName?: StringNullableFilter<"Patient"> | string | null
    fatherName?: StringNullableFilter<"Patient"> | string | null
    spouseName?: StringNullableFilter<"Patient"> | string | null
    bpjsNumber?: StringNullableFilter<"Patient"> | string | null
    otherInsuranceNumber?: StringNullableFilter<"Patient"> | string | null
    phoneNumber?: StringNullableFilter<"Patient"> | string | null
    registeredAt?: DateTimeNullableFilter<"Patient"> | Date | string | null
    homeAddress?: StringNullableFilter<"Patient"> | string | null
    gender?: XOR<GenderNullableScalarRelationFilter, GenderWhereInput> | null
    reservations?: ReservationListRelationFilter
  }, "id" | "identity">

  export type PatientOrderByWithAggregationInput = {
    id?: SortOrder
    isEnabled?: SortOrder
    name?: SortOrderInput | SortOrder
    identity?: SortOrder
    genderId?: SortOrderInput | SortOrder
    birthPlace?: SortOrderInput | SortOrder
    birthDate?: SortOrderInput | SortOrder
    motherName?: SortOrderInput | SortOrder
    fatherName?: SortOrderInput | SortOrder
    spouseName?: SortOrderInput | SortOrder
    bpjsNumber?: SortOrderInput | SortOrder
    otherInsuranceNumber?: SortOrderInput | SortOrder
    phoneNumber?: SortOrderInput | SortOrder
    registeredAt?: SortOrderInput | SortOrder
    homeAddress?: SortOrderInput | SortOrder
    _count?: PatientCountOrderByAggregateInput
    _avg?: PatientAvgOrderByAggregateInput
    _max?: PatientMaxOrderByAggregateInput
    _min?: PatientMinOrderByAggregateInput
    _sum?: PatientSumOrderByAggregateInput
  }

  export type PatientScalarWhereWithAggregatesInput = {
    AND?: PatientScalarWhereWithAggregatesInput | PatientScalarWhereWithAggregatesInput[]
    OR?: PatientScalarWhereWithAggregatesInput[]
    NOT?: PatientScalarWhereWithAggregatesInput | PatientScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Patient"> | number
    isEnabled?: BoolWithAggregatesFilter<"Patient"> | boolean
    name?: StringNullableWithAggregatesFilter<"Patient"> | string | null
    identity?: StringWithAggregatesFilter<"Patient"> | string
    genderId?: IntNullableWithAggregatesFilter<"Patient"> | number | null
    birthPlace?: StringNullableWithAggregatesFilter<"Patient"> | string | null
    birthDate?: DateTimeNullableWithAggregatesFilter<"Patient"> | Date | string | null
    motherName?: StringNullableWithAggregatesFilter<"Patient"> | string | null
    fatherName?: StringNullableWithAggregatesFilter<"Patient"> | string | null
    spouseName?: StringNullableWithAggregatesFilter<"Patient"> | string | null
    bpjsNumber?: StringNullableWithAggregatesFilter<"Patient"> | string | null
    otherInsuranceNumber?: StringNullableWithAggregatesFilter<"Patient"> | string | null
    phoneNumber?: StringNullableWithAggregatesFilter<"Patient"> | string | null
    registeredAt?: DateTimeNullableWithAggregatesFilter<"Patient"> | Date | string | null
    homeAddress?: StringNullableWithAggregatesFilter<"Patient"> | string | null
  }

  export type GenderWhereInput = {
    AND?: GenderWhereInput | GenderWhereInput[]
    OR?: GenderWhereInput[]
    NOT?: GenderWhereInput | GenderWhereInput[]
    id?: IntFilter<"Gender"> | number
    gender?: StringFilter<"Gender"> | string
    isEnabled?: BoolFilter<"Gender"> | boolean
    patients?: PatientListRelationFilter
  }

  export type GenderOrderByWithRelationInput = {
    id?: SortOrder
    gender?: SortOrder
    isEnabled?: SortOrder
    patients?: PatientOrderByRelationAggregateInput
  }

  export type GenderWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: GenderWhereInput | GenderWhereInput[]
    OR?: GenderWhereInput[]
    NOT?: GenderWhereInput | GenderWhereInput[]
    gender?: StringFilter<"Gender"> | string
    isEnabled?: BoolFilter<"Gender"> | boolean
    patients?: PatientListRelationFilter
  }, "id">

  export type GenderOrderByWithAggregationInput = {
    id?: SortOrder
    gender?: SortOrder
    isEnabled?: SortOrder
    _count?: GenderCountOrderByAggregateInput
    _avg?: GenderAvgOrderByAggregateInput
    _max?: GenderMaxOrderByAggregateInput
    _min?: GenderMinOrderByAggregateInput
    _sum?: GenderSumOrderByAggregateInput
  }

  export type GenderScalarWhereWithAggregatesInput = {
    AND?: GenderScalarWhereWithAggregatesInput | GenderScalarWhereWithAggregatesInput[]
    OR?: GenderScalarWhereWithAggregatesInput[]
    NOT?: GenderScalarWhereWithAggregatesInput | GenderScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Gender"> | number
    gender?: StringWithAggregatesFilter<"Gender"> | string
    isEnabled?: BoolWithAggregatesFilter<"Gender"> | boolean
  }

  export type ReferralSourceWhereInput = {
    AND?: ReferralSourceWhereInput | ReferralSourceWhereInput[]
    OR?: ReferralSourceWhereInput[]
    NOT?: ReferralSourceWhereInput | ReferralSourceWhereInput[]
    id?: IntFilter<"ReferralSource"> | number
    source?: StringFilter<"ReferralSource"> | string
    isEnabled?: BoolFilter<"ReferralSource"> | boolean
    reservations?: ReservationListRelationFilter
  }

  export type ReferralSourceOrderByWithRelationInput = {
    id?: SortOrder
    source?: SortOrder
    isEnabled?: SortOrder
    reservations?: ReservationOrderByRelationAggregateInput
  }

  export type ReferralSourceWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ReferralSourceWhereInput | ReferralSourceWhereInput[]
    OR?: ReferralSourceWhereInput[]
    NOT?: ReferralSourceWhereInput | ReferralSourceWhereInput[]
    source?: StringFilter<"ReferralSource"> | string
    isEnabled?: BoolFilter<"ReferralSource"> | boolean
    reservations?: ReservationListRelationFilter
  }, "id">

  export type ReferralSourceOrderByWithAggregationInput = {
    id?: SortOrder
    source?: SortOrder
    isEnabled?: SortOrder
    _count?: ReferralSourceCountOrderByAggregateInput
    _avg?: ReferralSourceAvgOrderByAggregateInput
    _max?: ReferralSourceMaxOrderByAggregateInput
    _min?: ReferralSourceMinOrderByAggregateInput
    _sum?: ReferralSourceSumOrderByAggregateInput
  }

  export type ReferralSourceScalarWhereWithAggregatesInput = {
    AND?: ReferralSourceScalarWhereWithAggregatesInput | ReferralSourceScalarWhereWithAggregatesInput[]
    OR?: ReferralSourceScalarWhereWithAggregatesInput[]
    NOT?: ReferralSourceScalarWhereWithAggregatesInput | ReferralSourceScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ReferralSource"> | number
    source?: StringWithAggregatesFilter<"ReferralSource"> | string
    isEnabled?: BoolWithAggregatesFilter<"ReferralSource"> | boolean
  }

  export type PaymentMethodCreateInput = {
    id: number
    isEnabled: boolean
    displayName: string
    reservations?: ReservationCreateNestedManyWithoutPaymentMethodInput
  }

  export type PaymentMethodUncheckedCreateInput = {
    id: number
    isEnabled: boolean
    displayName: string
    reservations?: ReservationUncheckedCreateNestedManyWithoutPaymentMethodInput
  }

  export type PaymentMethodUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    displayName?: StringFieldUpdateOperationsInput | string
    reservations?: ReservationUpdateManyWithoutPaymentMethodNestedInput
  }

  export type PaymentMethodUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    displayName?: StringFieldUpdateOperationsInput | string
    reservations?: ReservationUncheckedUpdateManyWithoutPaymentMethodNestedInput
  }

  export type PaymentMethodCreateManyInput = {
    id: number
    isEnabled: boolean
    displayName: string
  }

  export type PaymentMethodUpdateManyMutationInput = {
    id?: IntFieldUpdateOperationsInput | number
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    displayName?: StringFieldUpdateOperationsInput | string
  }

  export type PaymentMethodUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    displayName?: StringFieldUpdateOperationsInput | string
  }

  export type BedCreateInput = {
    id: number
    displayName: string
    bedNumber: number
    isEnabled: boolean
    room?: RoomCreateNestedOneWithoutBedsInput
    bedStatus?: BedStatusCreateNestedOneWithoutBedsInput
  }

  export type BedUncheckedCreateInput = {
    id: number
    displayName: string
    bedNumber: number
    isEnabled: boolean
    roomId?: number | null
    bedStatusId?: number | null
  }

  export type BedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    displayName?: StringFieldUpdateOperationsInput | string
    bedNumber?: IntFieldUpdateOperationsInput | number
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    room?: RoomUpdateOneWithoutBedsNestedInput
    bedStatus?: BedStatusUpdateOneWithoutBedsNestedInput
  }

  export type BedUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    displayName?: StringFieldUpdateOperationsInput | string
    bedNumber?: IntFieldUpdateOperationsInput | number
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    roomId?: NullableIntFieldUpdateOperationsInput | number | null
    bedStatusId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type BedCreateManyInput = {
    id: number
    displayName: string
    bedNumber: number
    isEnabled: boolean
    roomId?: number | null
    bedStatusId?: number | null
  }

  export type BedUpdateManyMutationInput = {
    id?: IntFieldUpdateOperationsInput | number
    displayName?: StringFieldUpdateOperationsInput | string
    bedNumber?: IntFieldUpdateOperationsInput | number
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
  }

  export type BedUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    displayName?: StringFieldUpdateOperationsInput | string
    bedNumber?: IntFieldUpdateOperationsInput | number
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    roomId?: NullableIntFieldUpdateOperationsInput | number | null
    bedStatusId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type RoomCreateInput = {
    id: number
    roomName: string
    isEnabled: boolean
    unit?: UnitCreateNestedOneWithoutRoomsInput
    class?: ClassCreateNestedOneWithoutRoomsInput
    beds?: BedCreateNestedManyWithoutRoomInput
  }

  export type RoomUncheckedCreateInput = {
    id: number
    roomName: string
    isEnabled: boolean
    unitId?: number | null
    classId?: number | null
    beds?: BedUncheckedCreateNestedManyWithoutRoomInput
  }

  export type RoomUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    roomName?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    unit?: UnitUpdateOneWithoutRoomsNestedInput
    class?: ClassUpdateOneWithoutRoomsNestedInput
    beds?: BedUpdateManyWithoutRoomNestedInput
  }

  export type RoomUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    roomName?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    unitId?: NullableIntFieldUpdateOperationsInput | number | null
    classId?: NullableIntFieldUpdateOperationsInput | number | null
    beds?: BedUncheckedUpdateManyWithoutRoomNestedInput
  }

  export type RoomCreateManyInput = {
    id: number
    roomName: string
    isEnabled: boolean
    unitId?: number | null
    classId?: number | null
  }

  export type RoomUpdateManyMutationInput = {
    id?: IntFieldUpdateOperationsInput | number
    roomName?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RoomUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    roomName?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    unitId?: NullableIntFieldUpdateOperationsInput | number | null
    classId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type UnitCreateInput = {
    id: number
    unitName: string
    isEnabled: boolean
    rooms?: RoomCreateNestedManyWithoutUnitInput
    department?: DepartmentCreateNestedOneWithoutUnitsInput
    stockDetails?: StockDetailCreateNestedManyWithoutUnitInput
    doctorSchedules?: DoctorScheduleCreateNestedManyWithoutUnitInput
    reservations?: ReservationCreateNestedManyWithoutUnitInput
  }

  export type UnitUncheckedCreateInput = {
    id: number
    unitName: string
    isEnabled: boolean
    departmentId?: number | null
    rooms?: RoomUncheckedCreateNestedManyWithoutUnitInput
    stockDetails?: StockDetailUncheckedCreateNestedManyWithoutUnitInput
    doctorSchedules?: DoctorScheduleUncheckedCreateNestedManyWithoutUnitInput
    reservations?: ReservationUncheckedCreateNestedManyWithoutUnitInput
  }

  export type UnitUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    unitName?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    rooms?: RoomUpdateManyWithoutUnitNestedInput
    department?: DepartmentUpdateOneWithoutUnitsNestedInput
    stockDetails?: StockDetailUpdateManyWithoutUnitNestedInput
    doctorSchedules?: DoctorScheduleUpdateManyWithoutUnitNestedInput
    reservations?: ReservationUpdateManyWithoutUnitNestedInput
  }

  export type UnitUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    unitName?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    departmentId?: NullableIntFieldUpdateOperationsInput | number | null
    rooms?: RoomUncheckedUpdateManyWithoutUnitNestedInput
    stockDetails?: StockDetailUncheckedUpdateManyWithoutUnitNestedInput
    doctorSchedules?: DoctorScheduleUncheckedUpdateManyWithoutUnitNestedInput
    reservations?: ReservationUncheckedUpdateManyWithoutUnitNestedInput
  }

  export type UnitCreateManyInput = {
    id: number
    unitName: string
    isEnabled: boolean
    departmentId?: number | null
  }

  export type UnitUpdateManyMutationInput = {
    id?: IntFieldUpdateOperationsInput | number
    unitName?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UnitUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    unitName?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    departmentId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type BedStatusCreateInput = {
    id: number
    status: string
    isEnabled: boolean
    beds?: BedCreateNestedManyWithoutBedStatusInput
  }

  export type BedStatusUncheckedCreateInput = {
    id: number
    status: string
    isEnabled: boolean
    beds?: BedUncheckedCreateNestedManyWithoutBedStatusInput
  }

  export type BedStatusUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    beds?: BedUpdateManyWithoutBedStatusNestedInput
  }

  export type BedStatusUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    beds?: BedUncheckedUpdateManyWithoutBedStatusNestedInput
  }

  export type BedStatusCreateManyInput = {
    id: number
    status: string
    isEnabled: boolean
  }

  export type BedStatusUpdateManyMutationInput = {
    id?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
  }

  export type BedStatusUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ClassCreateInput = {
    id: number
    className: string
    isEnabled: boolean
    rooms?: RoomCreateNestedManyWithoutClassInput
  }

  export type ClassUncheckedCreateInput = {
    id: number
    className: string
    isEnabled: boolean
    rooms?: RoomUncheckedCreateNestedManyWithoutClassInput
  }

  export type ClassUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    className?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    rooms?: RoomUpdateManyWithoutClassNestedInput
  }

  export type ClassUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    className?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    rooms?: RoomUncheckedUpdateManyWithoutClassNestedInput
  }

  export type ClassCreateManyInput = {
    id: number
    className: string
    isEnabled: boolean
  }

  export type ClassUpdateManyMutationInput = {
    id?: IntFieldUpdateOperationsInput | number
    className?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ClassUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    className?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
  }

  export type DepartmentCreateInput = {
    id: number
    departmentName: string
    isEnabled: boolean
    units?: UnitCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentUncheckedCreateInput = {
    id: number
    departmentName: string
    isEnabled: boolean
    units?: UnitUncheckedCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    departmentName?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    units?: UnitUpdateManyWithoutDepartmentNestedInput
  }

  export type DepartmentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    departmentName?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    units?: UnitUncheckedUpdateManyWithoutDepartmentNestedInput
  }

  export type DepartmentCreateManyInput = {
    id: number
    departmentName: string
    isEnabled: boolean
  }

  export type DepartmentUpdateManyMutationInput = {
    id?: IntFieldUpdateOperationsInput | number
    departmentName?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
  }

  export type DepartmentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    departmentName?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ProductCreateInput = {
    id: number
    productName: string
    isEnabled?: boolean
    stockDetails?: StockDetailCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateInput = {
    id: number
    productName: string
    isEnabled?: boolean
    stockDetails?: StockDetailUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    productName?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    stockDetails?: StockDetailUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    productName?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    stockDetails?: StockDetailUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductCreateManyInput = {
    id: number
    productName: string
    isEnabled?: boolean
  }

  export type ProductUpdateManyMutationInput = {
    id?: IntFieldUpdateOperationsInput | number
    productName?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ProductUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    productName?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ServiceReceiptCreateInput = {
    id: string
    receiptAt: Date | string
    stockDetails?: StockDetailCreateNestedManyWithoutReceiptInput
  }

  export type ServiceReceiptUncheckedCreateInput = {
    id: string
    receiptAt: Date | string
    stockDetails?: StockDetailUncheckedCreateNestedManyWithoutReceiptInput
  }

  export type ServiceReceiptUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    receiptAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stockDetails?: StockDetailUpdateManyWithoutReceiptNestedInput
  }

  export type ServiceReceiptUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    receiptAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stockDetails?: StockDetailUncheckedUpdateManyWithoutReceiptNestedInput
  }

  export type ServiceReceiptCreateManyInput = {
    id: string
    receiptAt: Date | string
  }

  export type ServiceReceiptUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    receiptAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceReceiptUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    receiptAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockDetailCreateInput = {
    id: string
    sourceProductId?: number | null
    netPrice?: number | null
    discountPrice?: number | null
    quantity: number
    isEnabled: boolean
    expiredAt?: Date | string | null
    product: ProductCreateNestedOneWithoutStockDetailsInput
    unit: UnitCreateNestedOneWithoutStockDetailsInput
    receipt: ServiceReceiptCreateNestedOneWithoutStockDetailsInput
  }

  export type StockDetailUncheckedCreateInput = {
    id: string
    productId: number
    unitId: number
    receiptId: string
    sourceProductId?: number | null
    netPrice?: number | null
    discountPrice?: number | null
    quantity: number
    isEnabled: boolean
    expiredAt?: Date | string | null
  }

  export type StockDetailUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sourceProductId?: NullableIntFieldUpdateOperationsInput | number | null
    netPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    discountPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    quantity?: FloatFieldUpdateOperationsInput | number
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    expiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    product?: ProductUpdateOneRequiredWithoutStockDetailsNestedInput
    unit?: UnitUpdateOneRequiredWithoutStockDetailsNestedInput
    receipt?: ServiceReceiptUpdateOneRequiredWithoutStockDetailsNestedInput
  }

  export type StockDetailUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: IntFieldUpdateOperationsInput | number
    unitId?: IntFieldUpdateOperationsInput | number
    receiptId?: StringFieldUpdateOperationsInput | string
    sourceProductId?: NullableIntFieldUpdateOperationsInput | number | null
    netPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    discountPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    quantity?: FloatFieldUpdateOperationsInput | number
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    expiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type StockDetailCreateManyInput = {
    id: string
    productId: number
    unitId: number
    receiptId: string
    sourceProductId?: number | null
    netPrice?: number | null
    discountPrice?: number | null
    quantity: number
    isEnabled: boolean
    expiredAt?: Date | string | null
  }

  export type StockDetailUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sourceProductId?: NullableIntFieldUpdateOperationsInput | number | null
    netPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    discountPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    quantity?: FloatFieldUpdateOperationsInput | number
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    expiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type StockDetailUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: IntFieldUpdateOperationsInput | number
    unitId?: IntFieldUpdateOperationsInput | number
    receiptId?: StringFieldUpdateOperationsInput | string
    sourceProductId?: NullableIntFieldUpdateOperationsInput | number | null
    netPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    discountPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    quantity?: FloatFieldUpdateOperationsInput | number
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    expiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DoctorScheduleCreateInput = {
    id: number
    startTime: Date | string
    endTime: Date | string
    note?: string | null
    days: string
    quota: number
    isEnabled: boolean
    unit: UnitCreateNestedOneWithoutDoctorSchedulesInput
    doctor: EmployeeCreateNestedOneWithoutDoctorSchedulesInput
  }

  export type DoctorScheduleUncheckedCreateInput = {
    id: number
    unitId: number
    doctorId: number
    startTime: Date | string
    endTime: Date | string
    note?: string | null
    days: string
    quota: number
    isEnabled: boolean
  }

  export type DoctorScheduleUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    days?: StringFieldUpdateOperationsInput | string
    quota?: IntFieldUpdateOperationsInput | number
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    unit?: UnitUpdateOneRequiredWithoutDoctorSchedulesNestedInput
    doctor?: EmployeeUpdateOneRequiredWithoutDoctorSchedulesNestedInput
  }

  export type DoctorScheduleUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    unitId?: IntFieldUpdateOperationsInput | number
    doctorId?: IntFieldUpdateOperationsInput | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    days?: StringFieldUpdateOperationsInput | string
    quota?: IntFieldUpdateOperationsInput | number
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
  }

  export type DoctorScheduleCreateManyInput = {
    id: number
    unitId: number
    doctorId: number
    startTime: Date | string
    endTime: Date | string
    note?: string | null
    days: string
    quota: number
    isEnabled: boolean
  }

  export type DoctorScheduleUpdateManyMutationInput = {
    id?: IntFieldUpdateOperationsInput | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    days?: StringFieldUpdateOperationsInput | string
    quota?: IntFieldUpdateOperationsInput | number
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
  }

  export type DoctorScheduleUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    unitId?: IntFieldUpdateOperationsInput | number
    doctorId?: IntFieldUpdateOperationsInput | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    days?: StringFieldUpdateOperationsInput | string
    quota?: IntFieldUpdateOperationsInput | number
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
  }

  export type EmployeeCreateInput = {
    id: number
    fullName: string
    identityNo?: string | null
    isEnabled: boolean
    doctorSchedules?: DoctorScheduleCreateNestedManyWithoutDoctorInput
    reservations?: ReservationCreateNestedManyWithoutDoctorInput
  }

  export type EmployeeUncheckedCreateInput = {
    id: number
    fullName: string
    identityNo?: string | null
    isEnabled: boolean
    doctorSchedules?: DoctorScheduleUncheckedCreateNestedManyWithoutDoctorInput
    reservations?: ReservationUncheckedCreateNestedManyWithoutDoctorInput
  }

  export type EmployeeUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    fullName?: StringFieldUpdateOperationsInput | string
    identityNo?: NullableStringFieldUpdateOperationsInput | string | null
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    doctorSchedules?: DoctorScheduleUpdateManyWithoutDoctorNestedInput
    reservations?: ReservationUpdateManyWithoutDoctorNestedInput
  }

  export type EmployeeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    fullName?: StringFieldUpdateOperationsInput | string
    identityNo?: NullableStringFieldUpdateOperationsInput | string | null
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    doctorSchedules?: DoctorScheduleUncheckedUpdateManyWithoutDoctorNestedInput
    reservations?: ReservationUncheckedUpdateManyWithoutDoctorNestedInput
  }

  export type EmployeeCreateManyInput = {
    id: number
    fullName: string
    identityNo?: string | null
    isEnabled: boolean
  }

  export type EmployeeUpdateManyMutationInput = {
    id?: IntFieldUpdateOperationsInput | number
    fullName?: StringFieldUpdateOperationsInput | string
    identityNo?: NullableStringFieldUpdateOperationsInput | string | null
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
  }

  export type EmployeeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    fullName?: StringFieldUpdateOperationsInput | string
    identityNo?: NullableStringFieldUpdateOperationsInput | string | null
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ReservationCreateInput = {
    id: string
    isEnabled?: boolean
    queueNumber: number
    reservationNumber: string
    reservationDate: Date | string
    bpjsNumber?: string | null
    otherInsuranceNumber?: string | null
    createdAt?: Date | string
    referralNumber?: string | null
    notes?: string | null
    queueType: string
    isConfirmed?: boolean
    callStatus?: string
    isCancelled?: boolean
    cancelReason?: string | null
    educationId?: number | null
    type?: string | null
    patientType?: string | null
    unit: UnitCreateNestedOneWithoutReservationsInput
    patient?: PatientCreateNestedOneWithoutReservationsInput
    paymentMethod: PaymentMethodCreateNestedOneWithoutReservationsInput
    doctor?: EmployeeCreateNestedOneWithoutReservationsInput
    referralSource?: ReferralSourceCreateNestedOneWithoutReservationsInput
  }

  export type ReservationUncheckedCreateInput = {
    id: string
    isEnabled?: boolean
    unitId: number
    identity: string
    queueNumber: number
    reservationNumber: string
    reservationDate: Date | string
    paymentMethodId: number
    bpjsNumber?: string | null
    otherInsuranceNumber?: string | null
    createdAt?: Date | string
    referralNumber?: string | null
    doctorId?: number | null
    notes?: string | null
    queueType: string
    referralSourceId?: number | null
    isConfirmed?: boolean
    callStatus?: string
    isCancelled?: boolean
    cancelReason?: string | null
    educationId?: number | null
    type?: string | null
    patientType?: string | null
  }

  export type ReservationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    queueNumber?: IntFieldUpdateOperationsInput | number
    reservationNumber?: StringFieldUpdateOperationsInput | string
    reservationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    bpjsNumber?: NullableStringFieldUpdateOperationsInput | string | null
    otherInsuranceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referralNumber?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    queueType?: StringFieldUpdateOperationsInput | string
    isConfirmed?: BoolFieldUpdateOperationsInput | boolean
    callStatus?: StringFieldUpdateOperationsInput | string
    isCancelled?: BoolFieldUpdateOperationsInput | boolean
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    educationId?: NullableIntFieldUpdateOperationsInput | number | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    patientType?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: UnitUpdateOneRequiredWithoutReservationsNestedInput
    patient?: PatientUpdateOneWithoutReservationsNestedInput
    paymentMethod?: PaymentMethodUpdateOneRequiredWithoutReservationsNestedInput
    doctor?: EmployeeUpdateOneWithoutReservationsNestedInput
    referralSource?: ReferralSourceUpdateOneWithoutReservationsNestedInput
  }

  export type ReservationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    unitId?: IntFieldUpdateOperationsInput | number
    identity?: StringFieldUpdateOperationsInput | string
    queueNumber?: IntFieldUpdateOperationsInput | number
    reservationNumber?: StringFieldUpdateOperationsInput | string
    reservationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMethodId?: IntFieldUpdateOperationsInput | number
    bpjsNumber?: NullableStringFieldUpdateOperationsInput | string | null
    otherInsuranceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referralNumber?: NullableStringFieldUpdateOperationsInput | string | null
    doctorId?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    queueType?: StringFieldUpdateOperationsInput | string
    referralSourceId?: NullableIntFieldUpdateOperationsInput | number | null
    isConfirmed?: BoolFieldUpdateOperationsInput | boolean
    callStatus?: StringFieldUpdateOperationsInput | string
    isCancelled?: BoolFieldUpdateOperationsInput | boolean
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    educationId?: NullableIntFieldUpdateOperationsInput | number | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    patientType?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ReservationCreateManyInput = {
    id: string
    isEnabled?: boolean
    unitId: number
    identity: string
    queueNumber: number
    reservationNumber: string
    reservationDate: Date | string
    paymentMethodId: number
    bpjsNumber?: string | null
    otherInsuranceNumber?: string | null
    createdAt?: Date | string
    referralNumber?: string | null
    doctorId?: number | null
    notes?: string | null
    queueType: string
    referralSourceId?: number | null
    isConfirmed?: boolean
    callStatus?: string
    isCancelled?: boolean
    cancelReason?: string | null
    educationId?: number | null
    type?: string | null
    patientType?: string | null
  }

  export type ReservationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    queueNumber?: IntFieldUpdateOperationsInput | number
    reservationNumber?: StringFieldUpdateOperationsInput | string
    reservationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    bpjsNumber?: NullableStringFieldUpdateOperationsInput | string | null
    otherInsuranceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referralNumber?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    queueType?: StringFieldUpdateOperationsInput | string
    isConfirmed?: BoolFieldUpdateOperationsInput | boolean
    callStatus?: StringFieldUpdateOperationsInput | string
    isCancelled?: BoolFieldUpdateOperationsInput | boolean
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    educationId?: NullableIntFieldUpdateOperationsInput | number | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    patientType?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ReservationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    unitId?: IntFieldUpdateOperationsInput | number
    identity?: StringFieldUpdateOperationsInput | string
    queueNumber?: IntFieldUpdateOperationsInput | number
    reservationNumber?: StringFieldUpdateOperationsInput | string
    reservationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMethodId?: IntFieldUpdateOperationsInput | number
    bpjsNumber?: NullableStringFieldUpdateOperationsInput | string | null
    otherInsuranceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referralNumber?: NullableStringFieldUpdateOperationsInput | string | null
    doctorId?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    queueType?: StringFieldUpdateOperationsInput | string
    referralSourceId?: NullableIntFieldUpdateOperationsInput | number | null
    isConfirmed?: BoolFieldUpdateOperationsInput | boolean
    callStatus?: StringFieldUpdateOperationsInput | string
    isCancelled?: BoolFieldUpdateOperationsInput | boolean
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    educationId?: NullableIntFieldUpdateOperationsInput | number | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    patientType?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PatientCreateInput = {
    id: number
    isEnabled?: boolean
    name?: string | null
    identity: string
    birthPlace?: string | null
    birthDate?: Date | string | null
    motherName?: string | null
    fatherName?: string | null
    spouseName?: string | null
    bpjsNumber?: string | null
    otherInsuranceNumber?: string | null
    phoneNumber?: string | null
    registeredAt?: Date | string | null
    homeAddress?: string | null
    gender?: GenderCreateNestedOneWithoutPatientsInput
    reservations?: ReservationCreateNestedManyWithoutPatientInput
  }

  export type PatientUncheckedCreateInput = {
    id: number
    isEnabled?: boolean
    name?: string | null
    identity: string
    genderId?: number | null
    birthPlace?: string | null
    birthDate?: Date | string | null
    motherName?: string | null
    fatherName?: string | null
    spouseName?: string | null
    bpjsNumber?: string | null
    otherInsuranceNumber?: string | null
    phoneNumber?: string | null
    registeredAt?: Date | string | null
    homeAddress?: string | null
    reservations?: ReservationUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    name?: NullableStringFieldUpdateOperationsInput | string | null
    identity?: StringFieldUpdateOperationsInput | string
    birthPlace?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    motherName?: NullableStringFieldUpdateOperationsInput | string | null
    fatherName?: NullableStringFieldUpdateOperationsInput | string | null
    spouseName?: NullableStringFieldUpdateOperationsInput | string | null
    bpjsNumber?: NullableStringFieldUpdateOperationsInput | string | null
    otherInsuranceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    registeredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    homeAddress?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: GenderUpdateOneWithoutPatientsNestedInput
    reservations?: ReservationUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    name?: NullableStringFieldUpdateOperationsInput | string | null
    identity?: StringFieldUpdateOperationsInput | string
    genderId?: NullableIntFieldUpdateOperationsInput | number | null
    birthPlace?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    motherName?: NullableStringFieldUpdateOperationsInput | string | null
    fatherName?: NullableStringFieldUpdateOperationsInput | string | null
    spouseName?: NullableStringFieldUpdateOperationsInput | string | null
    bpjsNumber?: NullableStringFieldUpdateOperationsInput | string | null
    otherInsuranceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    registeredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    homeAddress?: NullableStringFieldUpdateOperationsInput | string | null
    reservations?: ReservationUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type PatientCreateManyInput = {
    id: number
    isEnabled?: boolean
    name?: string | null
    identity: string
    genderId?: number | null
    birthPlace?: string | null
    birthDate?: Date | string | null
    motherName?: string | null
    fatherName?: string | null
    spouseName?: string | null
    bpjsNumber?: string | null
    otherInsuranceNumber?: string | null
    phoneNumber?: string | null
    registeredAt?: Date | string | null
    homeAddress?: string | null
  }

  export type PatientUpdateManyMutationInput = {
    id?: IntFieldUpdateOperationsInput | number
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    name?: NullableStringFieldUpdateOperationsInput | string | null
    identity?: StringFieldUpdateOperationsInput | string
    birthPlace?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    motherName?: NullableStringFieldUpdateOperationsInput | string | null
    fatherName?: NullableStringFieldUpdateOperationsInput | string | null
    spouseName?: NullableStringFieldUpdateOperationsInput | string | null
    bpjsNumber?: NullableStringFieldUpdateOperationsInput | string | null
    otherInsuranceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    registeredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    homeAddress?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PatientUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    name?: NullableStringFieldUpdateOperationsInput | string | null
    identity?: StringFieldUpdateOperationsInput | string
    genderId?: NullableIntFieldUpdateOperationsInput | number | null
    birthPlace?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    motherName?: NullableStringFieldUpdateOperationsInput | string | null
    fatherName?: NullableStringFieldUpdateOperationsInput | string | null
    spouseName?: NullableStringFieldUpdateOperationsInput | string | null
    bpjsNumber?: NullableStringFieldUpdateOperationsInput | string | null
    otherInsuranceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    registeredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    homeAddress?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type GenderCreateInput = {
    id: number
    gender: string
    isEnabled: boolean
    patients?: PatientCreateNestedManyWithoutGenderInput
  }

  export type GenderUncheckedCreateInput = {
    id: number
    gender: string
    isEnabled: boolean
    patients?: PatientUncheckedCreateNestedManyWithoutGenderInput
  }

  export type GenderUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    gender?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    patients?: PatientUpdateManyWithoutGenderNestedInput
  }

  export type GenderUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    gender?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    patients?: PatientUncheckedUpdateManyWithoutGenderNestedInput
  }

  export type GenderCreateManyInput = {
    id: number
    gender: string
    isEnabled: boolean
  }

  export type GenderUpdateManyMutationInput = {
    id?: IntFieldUpdateOperationsInput | number
    gender?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
  }

  export type GenderUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    gender?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ReferralSourceCreateInput = {
    id: number
    source: string
    isEnabled: boolean
    reservations?: ReservationCreateNestedManyWithoutReferralSourceInput
  }

  export type ReferralSourceUncheckedCreateInput = {
    id: number
    source: string
    isEnabled: boolean
    reservations?: ReservationUncheckedCreateNestedManyWithoutReferralSourceInput
  }

  export type ReferralSourceUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    source?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    reservations?: ReservationUpdateManyWithoutReferralSourceNestedInput
  }

  export type ReferralSourceUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    source?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    reservations?: ReservationUncheckedUpdateManyWithoutReferralSourceNestedInput
  }

  export type ReferralSourceCreateManyInput = {
    id: number
    source: string
    isEnabled: boolean
  }

  export type ReferralSourceUpdateManyMutationInput = {
    id?: IntFieldUpdateOperationsInput | number
    source?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ReferralSourceUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    source?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type ReservationListRelationFilter = {
    every?: ReservationWhereInput
    some?: ReservationWhereInput
    none?: ReservationWhereInput
  }

  export type ReservationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PaymentMethodCountOrderByAggregateInput = {
    id?: SortOrder
    isEnabled?: SortOrder
    displayName?: SortOrder
  }

  export type PaymentMethodAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type PaymentMethodMaxOrderByAggregateInput = {
    id?: SortOrder
    isEnabled?: SortOrder
    displayName?: SortOrder
  }

  export type PaymentMethodMinOrderByAggregateInput = {
    id?: SortOrder
    isEnabled?: SortOrder
    displayName?: SortOrder
  }

  export type PaymentMethodSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type RoomNullableScalarRelationFilter = {
    is?: RoomWhereInput | null
    isNot?: RoomWhereInput | null
  }

  export type BedStatusNullableScalarRelationFilter = {
    is?: BedStatusWhereInput | null
    isNot?: BedStatusWhereInput | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type BedCountOrderByAggregateInput = {
    id?: SortOrder
    displayName?: SortOrder
    bedNumber?: SortOrder
    isEnabled?: SortOrder
    roomId?: SortOrder
    bedStatusId?: SortOrder
  }

  export type BedAvgOrderByAggregateInput = {
    id?: SortOrder
    bedNumber?: SortOrder
    roomId?: SortOrder
    bedStatusId?: SortOrder
  }

  export type BedMaxOrderByAggregateInput = {
    id?: SortOrder
    displayName?: SortOrder
    bedNumber?: SortOrder
    isEnabled?: SortOrder
    roomId?: SortOrder
    bedStatusId?: SortOrder
  }

  export type BedMinOrderByAggregateInput = {
    id?: SortOrder
    displayName?: SortOrder
    bedNumber?: SortOrder
    isEnabled?: SortOrder
    roomId?: SortOrder
    bedStatusId?: SortOrder
  }

  export type BedSumOrderByAggregateInput = {
    id?: SortOrder
    bedNumber?: SortOrder
    roomId?: SortOrder
    bedStatusId?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type UnitNullableScalarRelationFilter = {
    is?: UnitWhereInput | null
    isNot?: UnitWhereInput | null
  }

  export type ClassNullableScalarRelationFilter = {
    is?: ClassWhereInput | null
    isNot?: ClassWhereInput | null
  }

  export type BedListRelationFilter = {
    every?: BedWhereInput
    some?: BedWhereInput
    none?: BedWhereInput
  }

  export type BedOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RoomCountOrderByAggregateInput = {
    id?: SortOrder
    roomName?: SortOrder
    isEnabled?: SortOrder
    unitId?: SortOrder
    classId?: SortOrder
  }

  export type RoomAvgOrderByAggregateInput = {
    id?: SortOrder
    unitId?: SortOrder
    classId?: SortOrder
  }

  export type RoomMaxOrderByAggregateInput = {
    id?: SortOrder
    roomName?: SortOrder
    isEnabled?: SortOrder
    unitId?: SortOrder
    classId?: SortOrder
  }

  export type RoomMinOrderByAggregateInput = {
    id?: SortOrder
    roomName?: SortOrder
    isEnabled?: SortOrder
    unitId?: SortOrder
    classId?: SortOrder
  }

  export type RoomSumOrderByAggregateInput = {
    id?: SortOrder
    unitId?: SortOrder
    classId?: SortOrder
  }

  export type RoomListRelationFilter = {
    every?: RoomWhereInput
    some?: RoomWhereInput
    none?: RoomWhereInput
  }

  export type DepartmentNullableScalarRelationFilter = {
    is?: DepartmentWhereInput | null
    isNot?: DepartmentWhereInput | null
  }

  export type StockDetailListRelationFilter = {
    every?: StockDetailWhereInput
    some?: StockDetailWhereInput
    none?: StockDetailWhereInput
  }

  export type DoctorScheduleListRelationFilter = {
    every?: DoctorScheduleWhereInput
    some?: DoctorScheduleWhereInput
    none?: DoctorScheduleWhereInput
  }

  export type RoomOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StockDetailOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DoctorScheduleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UnitCountOrderByAggregateInput = {
    id?: SortOrder
    unitName?: SortOrder
    isEnabled?: SortOrder
    departmentId?: SortOrder
  }

  export type UnitAvgOrderByAggregateInput = {
    id?: SortOrder
    departmentId?: SortOrder
  }

  export type UnitMaxOrderByAggregateInput = {
    id?: SortOrder
    unitName?: SortOrder
    isEnabled?: SortOrder
    departmentId?: SortOrder
  }

  export type UnitMinOrderByAggregateInput = {
    id?: SortOrder
    unitName?: SortOrder
    isEnabled?: SortOrder
    departmentId?: SortOrder
  }

  export type UnitSumOrderByAggregateInput = {
    id?: SortOrder
    departmentId?: SortOrder
  }

  export type BedStatusCountOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    isEnabled?: SortOrder
  }

  export type BedStatusAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type BedStatusMaxOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    isEnabled?: SortOrder
  }

  export type BedStatusMinOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    isEnabled?: SortOrder
  }

  export type BedStatusSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ClassCountOrderByAggregateInput = {
    id?: SortOrder
    className?: SortOrder
    isEnabled?: SortOrder
  }

  export type ClassAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ClassMaxOrderByAggregateInput = {
    id?: SortOrder
    className?: SortOrder
    isEnabled?: SortOrder
  }

  export type ClassMinOrderByAggregateInput = {
    id?: SortOrder
    className?: SortOrder
    isEnabled?: SortOrder
  }

  export type ClassSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UnitListRelationFilter = {
    every?: UnitWhereInput
    some?: UnitWhereInput
    none?: UnitWhereInput
  }

  export type UnitOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DepartmentCountOrderByAggregateInput = {
    id?: SortOrder
    departmentName?: SortOrder
    isEnabled?: SortOrder
  }

  export type DepartmentAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type DepartmentMaxOrderByAggregateInput = {
    id?: SortOrder
    departmentName?: SortOrder
    isEnabled?: SortOrder
  }

  export type DepartmentMinOrderByAggregateInput = {
    id?: SortOrder
    departmentName?: SortOrder
    isEnabled?: SortOrder
  }

  export type DepartmentSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ProductCountOrderByAggregateInput = {
    id?: SortOrder
    productName?: SortOrder
    isEnabled?: SortOrder
  }

  export type ProductAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ProductMaxOrderByAggregateInput = {
    id?: SortOrder
    productName?: SortOrder
    isEnabled?: SortOrder
  }

  export type ProductMinOrderByAggregateInput = {
    id?: SortOrder
    productName?: SortOrder
    isEnabled?: SortOrder
  }

  export type ProductSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type ServiceReceiptCountOrderByAggregateInput = {
    id?: SortOrder
    receiptAt?: SortOrder
  }

  export type ServiceReceiptMaxOrderByAggregateInput = {
    id?: SortOrder
    receiptAt?: SortOrder
  }

  export type ServiceReceiptMinOrderByAggregateInput = {
    id?: SortOrder
    receiptAt?: SortOrder
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type ProductScalarRelationFilter = {
    is?: ProductWhereInput
    isNot?: ProductWhereInput
  }

  export type UnitScalarRelationFilter = {
    is?: UnitWhereInput
    isNot?: UnitWhereInput
  }

  export type ServiceReceiptScalarRelationFilter = {
    is?: ServiceReceiptWhereInput
    isNot?: ServiceReceiptWhereInput
  }

  export type StockDetailCountOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    unitId?: SortOrder
    receiptId?: SortOrder
    sourceProductId?: SortOrder
    netPrice?: SortOrder
    discountPrice?: SortOrder
    quantity?: SortOrder
    isEnabled?: SortOrder
    expiredAt?: SortOrder
  }

  export type StockDetailAvgOrderByAggregateInput = {
    productId?: SortOrder
    unitId?: SortOrder
    sourceProductId?: SortOrder
    netPrice?: SortOrder
    discountPrice?: SortOrder
    quantity?: SortOrder
  }

  export type StockDetailMaxOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    unitId?: SortOrder
    receiptId?: SortOrder
    sourceProductId?: SortOrder
    netPrice?: SortOrder
    discountPrice?: SortOrder
    quantity?: SortOrder
    isEnabled?: SortOrder
    expiredAt?: SortOrder
  }

  export type StockDetailMinOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    unitId?: SortOrder
    receiptId?: SortOrder
    sourceProductId?: SortOrder
    netPrice?: SortOrder
    discountPrice?: SortOrder
    quantity?: SortOrder
    isEnabled?: SortOrder
    expiredAt?: SortOrder
  }

  export type StockDetailSumOrderByAggregateInput = {
    productId?: SortOrder
    unitId?: SortOrder
    sourceProductId?: SortOrder
    netPrice?: SortOrder
    discountPrice?: SortOrder
    quantity?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type EmployeeScalarRelationFilter = {
    is?: EmployeeWhereInput
    isNot?: EmployeeWhereInput
  }

  export type DoctorScheduleCountOrderByAggregateInput = {
    id?: SortOrder
    unitId?: SortOrder
    doctorId?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    note?: SortOrder
    days?: SortOrder
    quota?: SortOrder
    isEnabled?: SortOrder
  }

  export type DoctorScheduleAvgOrderByAggregateInput = {
    id?: SortOrder
    unitId?: SortOrder
    doctorId?: SortOrder
    quota?: SortOrder
  }

  export type DoctorScheduleMaxOrderByAggregateInput = {
    id?: SortOrder
    unitId?: SortOrder
    doctorId?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    note?: SortOrder
    days?: SortOrder
    quota?: SortOrder
    isEnabled?: SortOrder
  }

  export type DoctorScheduleMinOrderByAggregateInput = {
    id?: SortOrder
    unitId?: SortOrder
    doctorId?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    note?: SortOrder
    days?: SortOrder
    quota?: SortOrder
    isEnabled?: SortOrder
  }

  export type DoctorScheduleSumOrderByAggregateInput = {
    id?: SortOrder
    unitId?: SortOrder
    doctorId?: SortOrder
    quota?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type EmployeeCountOrderByAggregateInput = {
    id?: SortOrder
    fullName?: SortOrder
    identityNo?: SortOrder
    isEnabled?: SortOrder
  }

  export type EmployeeAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EmployeeMaxOrderByAggregateInput = {
    id?: SortOrder
    fullName?: SortOrder
    identityNo?: SortOrder
    isEnabled?: SortOrder
  }

  export type EmployeeMinOrderByAggregateInput = {
    id?: SortOrder
    fullName?: SortOrder
    identityNo?: SortOrder
    isEnabled?: SortOrder
  }

  export type EmployeeSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type PatientNullableScalarRelationFilter = {
    is?: PatientWhereInput | null
    isNot?: PatientWhereInput | null
  }

  export type PaymentMethodScalarRelationFilter = {
    is?: PaymentMethodWhereInput
    isNot?: PaymentMethodWhereInput
  }

  export type EmployeeNullableScalarRelationFilter = {
    is?: EmployeeWhereInput | null
    isNot?: EmployeeWhereInput | null
  }

  export type ReferralSourceNullableScalarRelationFilter = {
    is?: ReferralSourceWhereInput | null
    isNot?: ReferralSourceWhereInput | null
  }

  export type ReservationCountOrderByAggregateInput = {
    id?: SortOrder
    isEnabled?: SortOrder
    unitId?: SortOrder
    identity?: SortOrder
    queueNumber?: SortOrder
    reservationNumber?: SortOrder
    reservationDate?: SortOrder
    paymentMethodId?: SortOrder
    bpjsNumber?: SortOrder
    otherInsuranceNumber?: SortOrder
    createdAt?: SortOrder
    referralNumber?: SortOrder
    doctorId?: SortOrder
    notes?: SortOrder
    queueType?: SortOrder
    referralSourceId?: SortOrder
    isConfirmed?: SortOrder
    callStatus?: SortOrder
    isCancelled?: SortOrder
    cancelReason?: SortOrder
    educationId?: SortOrder
    type?: SortOrder
    patientType?: SortOrder
  }

  export type ReservationAvgOrderByAggregateInput = {
    unitId?: SortOrder
    queueNumber?: SortOrder
    paymentMethodId?: SortOrder
    doctorId?: SortOrder
    referralSourceId?: SortOrder
    educationId?: SortOrder
  }

  export type ReservationMaxOrderByAggregateInput = {
    id?: SortOrder
    isEnabled?: SortOrder
    unitId?: SortOrder
    identity?: SortOrder
    queueNumber?: SortOrder
    reservationNumber?: SortOrder
    reservationDate?: SortOrder
    paymentMethodId?: SortOrder
    bpjsNumber?: SortOrder
    otherInsuranceNumber?: SortOrder
    createdAt?: SortOrder
    referralNumber?: SortOrder
    doctorId?: SortOrder
    notes?: SortOrder
    queueType?: SortOrder
    referralSourceId?: SortOrder
    isConfirmed?: SortOrder
    callStatus?: SortOrder
    isCancelled?: SortOrder
    cancelReason?: SortOrder
    educationId?: SortOrder
    type?: SortOrder
    patientType?: SortOrder
  }

  export type ReservationMinOrderByAggregateInput = {
    id?: SortOrder
    isEnabled?: SortOrder
    unitId?: SortOrder
    identity?: SortOrder
    queueNumber?: SortOrder
    reservationNumber?: SortOrder
    reservationDate?: SortOrder
    paymentMethodId?: SortOrder
    bpjsNumber?: SortOrder
    otherInsuranceNumber?: SortOrder
    createdAt?: SortOrder
    referralNumber?: SortOrder
    doctorId?: SortOrder
    notes?: SortOrder
    queueType?: SortOrder
    referralSourceId?: SortOrder
    isConfirmed?: SortOrder
    callStatus?: SortOrder
    isCancelled?: SortOrder
    cancelReason?: SortOrder
    educationId?: SortOrder
    type?: SortOrder
    patientType?: SortOrder
  }

  export type ReservationSumOrderByAggregateInput = {
    unitId?: SortOrder
    queueNumber?: SortOrder
    paymentMethodId?: SortOrder
    doctorId?: SortOrder
    referralSourceId?: SortOrder
    educationId?: SortOrder
  }

  export type GenderNullableScalarRelationFilter = {
    is?: GenderWhereInput | null
    isNot?: GenderWhereInput | null
  }

  export type PatientCountOrderByAggregateInput = {
    id?: SortOrder
    isEnabled?: SortOrder
    name?: SortOrder
    identity?: SortOrder
    genderId?: SortOrder
    birthPlace?: SortOrder
    birthDate?: SortOrder
    motherName?: SortOrder
    fatherName?: SortOrder
    spouseName?: SortOrder
    bpjsNumber?: SortOrder
    otherInsuranceNumber?: SortOrder
    phoneNumber?: SortOrder
    registeredAt?: SortOrder
    homeAddress?: SortOrder
  }

  export type PatientAvgOrderByAggregateInput = {
    id?: SortOrder
    genderId?: SortOrder
  }

  export type PatientMaxOrderByAggregateInput = {
    id?: SortOrder
    isEnabled?: SortOrder
    name?: SortOrder
    identity?: SortOrder
    genderId?: SortOrder
    birthPlace?: SortOrder
    birthDate?: SortOrder
    motherName?: SortOrder
    fatherName?: SortOrder
    spouseName?: SortOrder
    bpjsNumber?: SortOrder
    otherInsuranceNumber?: SortOrder
    phoneNumber?: SortOrder
    registeredAt?: SortOrder
    homeAddress?: SortOrder
  }

  export type PatientMinOrderByAggregateInput = {
    id?: SortOrder
    isEnabled?: SortOrder
    name?: SortOrder
    identity?: SortOrder
    genderId?: SortOrder
    birthPlace?: SortOrder
    birthDate?: SortOrder
    motherName?: SortOrder
    fatherName?: SortOrder
    spouseName?: SortOrder
    bpjsNumber?: SortOrder
    otherInsuranceNumber?: SortOrder
    phoneNumber?: SortOrder
    registeredAt?: SortOrder
    homeAddress?: SortOrder
  }

  export type PatientSumOrderByAggregateInput = {
    id?: SortOrder
    genderId?: SortOrder
  }

  export type PatientListRelationFilter = {
    every?: PatientWhereInput
    some?: PatientWhereInput
    none?: PatientWhereInput
  }

  export type PatientOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GenderCountOrderByAggregateInput = {
    id?: SortOrder
    gender?: SortOrder
    isEnabled?: SortOrder
  }

  export type GenderAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type GenderMaxOrderByAggregateInput = {
    id?: SortOrder
    gender?: SortOrder
    isEnabled?: SortOrder
  }

  export type GenderMinOrderByAggregateInput = {
    id?: SortOrder
    gender?: SortOrder
    isEnabled?: SortOrder
  }

  export type GenderSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ReferralSourceCountOrderByAggregateInput = {
    id?: SortOrder
    source?: SortOrder
    isEnabled?: SortOrder
  }

  export type ReferralSourceAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ReferralSourceMaxOrderByAggregateInput = {
    id?: SortOrder
    source?: SortOrder
    isEnabled?: SortOrder
  }

  export type ReferralSourceMinOrderByAggregateInput = {
    id?: SortOrder
    source?: SortOrder
    isEnabled?: SortOrder
  }

  export type ReferralSourceSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ReservationCreateNestedManyWithoutPaymentMethodInput = {
    create?: XOR<ReservationCreateWithoutPaymentMethodInput, ReservationUncheckedCreateWithoutPaymentMethodInput> | ReservationCreateWithoutPaymentMethodInput[] | ReservationUncheckedCreateWithoutPaymentMethodInput[]
    connectOrCreate?: ReservationCreateOrConnectWithoutPaymentMethodInput | ReservationCreateOrConnectWithoutPaymentMethodInput[]
    createMany?: ReservationCreateManyPaymentMethodInputEnvelope
    connect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
  }

  export type ReservationUncheckedCreateNestedManyWithoutPaymentMethodInput = {
    create?: XOR<ReservationCreateWithoutPaymentMethodInput, ReservationUncheckedCreateWithoutPaymentMethodInput> | ReservationCreateWithoutPaymentMethodInput[] | ReservationUncheckedCreateWithoutPaymentMethodInput[]
    connectOrCreate?: ReservationCreateOrConnectWithoutPaymentMethodInput | ReservationCreateOrConnectWithoutPaymentMethodInput[]
    createMany?: ReservationCreateManyPaymentMethodInputEnvelope
    connect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type ReservationUpdateManyWithoutPaymentMethodNestedInput = {
    create?: XOR<ReservationCreateWithoutPaymentMethodInput, ReservationUncheckedCreateWithoutPaymentMethodInput> | ReservationCreateWithoutPaymentMethodInput[] | ReservationUncheckedCreateWithoutPaymentMethodInput[]
    connectOrCreate?: ReservationCreateOrConnectWithoutPaymentMethodInput | ReservationCreateOrConnectWithoutPaymentMethodInput[]
    upsert?: ReservationUpsertWithWhereUniqueWithoutPaymentMethodInput | ReservationUpsertWithWhereUniqueWithoutPaymentMethodInput[]
    createMany?: ReservationCreateManyPaymentMethodInputEnvelope
    set?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    disconnect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    delete?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    connect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    update?: ReservationUpdateWithWhereUniqueWithoutPaymentMethodInput | ReservationUpdateWithWhereUniqueWithoutPaymentMethodInput[]
    updateMany?: ReservationUpdateManyWithWhereWithoutPaymentMethodInput | ReservationUpdateManyWithWhereWithoutPaymentMethodInput[]
    deleteMany?: ReservationScalarWhereInput | ReservationScalarWhereInput[]
  }

  export type ReservationUncheckedUpdateManyWithoutPaymentMethodNestedInput = {
    create?: XOR<ReservationCreateWithoutPaymentMethodInput, ReservationUncheckedCreateWithoutPaymentMethodInput> | ReservationCreateWithoutPaymentMethodInput[] | ReservationUncheckedCreateWithoutPaymentMethodInput[]
    connectOrCreate?: ReservationCreateOrConnectWithoutPaymentMethodInput | ReservationCreateOrConnectWithoutPaymentMethodInput[]
    upsert?: ReservationUpsertWithWhereUniqueWithoutPaymentMethodInput | ReservationUpsertWithWhereUniqueWithoutPaymentMethodInput[]
    createMany?: ReservationCreateManyPaymentMethodInputEnvelope
    set?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    disconnect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    delete?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    connect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    update?: ReservationUpdateWithWhereUniqueWithoutPaymentMethodInput | ReservationUpdateWithWhereUniqueWithoutPaymentMethodInput[]
    updateMany?: ReservationUpdateManyWithWhereWithoutPaymentMethodInput | ReservationUpdateManyWithWhereWithoutPaymentMethodInput[]
    deleteMany?: ReservationScalarWhereInput | ReservationScalarWhereInput[]
  }

  export type RoomCreateNestedOneWithoutBedsInput = {
    create?: XOR<RoomCreateWithoutBedsInput, RoomUncheckedCreateWithoutBedsInput>
    connectOrCreate?: RoomCreateOrConnectWithoutBedsInput
    connect?: RoomWhereUniqueInput
  }

  export type BedStatusCreateNestedOneWithoutBedsInput = {
    create?: XOR<BedStatusCreateWithoutBedsInput, BedStatusUncheckedCreateWithoutBedsInput>
    connectOrCreate?: BedStatusCreateOrConnectWithoutBedsInput
    connect?: BedStatusWhereUniqueInput
  }

  export type RoomUpdateOneWithoutBedsNestedInput = {
    create?: XOR<RoomCreateWithoutBedsInput, RoomUncheckedCreateWithoutBedsInput>
    connectOrCreate?: RoomCreateOrConnectWithoutBedsInput
    upsert?: RoomUpsertWithoutBedsInput
    disconnect?: RoomWhereInput | boolean
    delete?: RoomWhereInput | boolean
    connect?: RoomWhereUniqueInput
    update?: XOR<XOR<RoomUpdateToOneWithWhereWithoutBedsInput, RoomUpdateWithoutBedsInput>, RoomUncheckedUpdateWithoutBedsInput>
  }

  export type BedStatusUpdateOneWithoutBedsNestedInput = {
    create?: XOR<BedStatusCreateWithoutBedsInput, BedStatusUncheckedCreateWithoutBedsInput>
    connectOrCreate?: BedStatusCreateOrConnectWithoutBedsInput
    upsert?: BedStatusUpsertWithoutBedsInput
    disconnect?: BedStatusWhereInput | boolean
    delete?: BedStatusWhereInput | boolean
    connect?: BedStatusWhereUniqueInput
    update?: XOR<XOR<BedStatusUpdateToOneWithWhereWithoutBedsInput, BedStatusUpdateWithoutBedsInput>, BedStatusUncheckedUpdateWithoutBedsInput>
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UnitCreateNestedOneWithoutRoomsInput = {
    create?: XOR<UnitCreateWithoutRoomsInput, UnitUncheckedCreateWithoutRoomsInput>
    connectOrCreate?: UnitCreateOrConnectWithoutRoomsInput
    connect?: UnitWhereUniqueInput
  }

  export type ClassCreateNestedOneWithoutRoomsInput = {
    create?: XOR<ClassCreateWithoutRoomsInput, ClassUncheckedCreateWithoutRoomsInput>
    connectOrCreate?: ClassCreateOrConnectWithoutRoomsInput
    connect?: ClassWhereUniqueInput
  }

  export type BedCreateNestedManyWithoutRoomInput = {
    create?: XOR<BedCreateWithoutRoomInput, BedUncheckedCreateWithoutRoomInput> | BedCreateWithoutRoomInput[] | BedUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: BedCreateOrConnectWithoutRoomInput | BedCreateOrConnectWithoutRoomInput[]
    createMany?: BedCreateManyRoomInputEnvelope
    connect?: BedWhereUniqueInput | BedWhereUniqueInput[]
  }

  export type BedUncheckedCreateNestedManyWithoutRoomInput = {
    create?: XOR<BedCreateWithoutRoomInput, BedUncheckedCreateWithoutRoomInput> | BedCreateWithoutRoomInput[] | BedUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: BedCreateOrConnectWithoutRoomInput | BedCreateOrConnectWithoutRoomInput[]
    createMany?: BedCreateManyRoomInputEnvelope
    connect?: BedWhereUniqueInput | BedWhereUniqueInput[]
  }

  export type UnitUpdateOneWithoutRoomsNestedInput = {
    create?: XOR<UnitCreateWithoutRoomsInput, UnitUncheckedCreateWithoutRoomsInput>
    connectOrCreate?: UnitCreateOrConnectWithoutRoomsInput
    upsert?: UnitUpsertWithoutRoomsInput
    disconnect?: UnitWhereInput | boolean
    delete?: UnitWhereInput | boolean
    connect?: UnitWhereUniqueInput
    update?: XOR<XOR<UnitUpdateToOneWithWhereWithoutRoomsInput, UnitUpdateWithoutRoomsInput>, UnitUncheckedUpdateWithoutRoomsInput>
  }

  export type ClassUpdateOneWithoutRoomsNestedInput = {
    create?: XOR<ClassCreateWithoutRoomsInput, ClassUncheckedCreateWithoutRoomsInput>
    connectOrCreate?: ClassCreateOrConnectWithoutRoomsInput
    upsert?: ClassUpsertWithoutRoomsInput
    disconnect?: ClassWhereInput | boolean
    delete?: ClassWhereInput | boolean
    connect?: ClassWhereUniqueInput
    update?: XOR<XOR<ClassUpdateToOneWithWhereWithoutRoomsInput, ClassUpdateWithoutRoomsInput>, ClassUncheckedUpdateWithoutRoomsInput>
  }

  export type BedUpdateManyWithoutRoomNestedInput = {
    create?: XOR<BedCreateWithoutRoomInput, BedUncheckedCreateWithoutRoomInput> | BedCreateWithoutRoomInput[] | BedUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: BedCreateOrConnectWithoutRoomInput | BedCreateOrConnectWithoutRoomInput[]
    upsert?: BedUpsertWithWhereUniqueWithoutRoomInput | BedUpsertWithWhereUniqueWithoutRoomInput[]
    createMany?: BedCreateManyRoomInputEnvelope
    set?: BedWhereUniqueInput | BedWhereUniqueInput[]
    disconnect?: BedWhereUniqueInput | BedWhereUniqueInput[]
    delete?: BedWhereUniqueInput | BedWhereUniqueInput[]
    connect?: BedWhereUniqueInput | BedWhereUniqueInput[]
    update?: BedUpdateWithWhereUniqueWithoutRoomInput | BedUpdateWithWhereUniqueWithoutRoomInput[]
    updateMany?: BedUpdateManyWithWhereWithoutRoomInput | BedUpdateManyWithWhereWithoutRoomInput[]
    deleteMany?: BedScalarWhereInput | BedScalarWhereInput[]
  }

  export type BedUncheckedUpdateManyWithoutRoomNestedInput = {
    create?: XOR<BedCreateWithoutRoomInput, BedUncheckedCreateWithoutRoomInput> | BedCreateWithoutRoomInput[] | BedUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: BedCreateOrConnectWithoutRoomInput | BedCreateOrConnectWithoutRoomInput[]
    upsert?: BedUpsertWithWhereUniqueWithoutRoomInput | BedUpsertWithWhereUniqueWithoutRoomInput[]
    createMany?: BedCreateManyRoomInputEnvelope
    set?: BedWhereUniqueInput | BedWhereUniqueInput[]
    disconnect?: BedWhereUniqueInput | BedWhereUniqueInput[]
    delete?: BedWhereUniqueInput | BedWhereUniqueInput[]
    connect?: BedWhereUniqueInput | BedWhereUniqueInput[]
    update?: BedUpdateWithWhereUniqueWithoutRoomInput | BedUpdateWithWhereUniqueWithoutRoomInput[]
    updateMany?: BedUpdateManyWithWhereWithoutRoomInput | BedUpdateManyWithWhereWithoutRoomInput[]
    deleteMany?: BedScalarWhereInput | BedScalarWhereInput[]
  }

  export type RoomCreateNestedManyWithoutUnitInput = {
    create?: XOR<RoomCreateWithoutUnitInput, RoomUncheckedCreateWithoutUnitInput> | RoomCreateWithoutUnitInput[] | RoomUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: RoomCreateOrConnectWithoutUnitInput | RoomCreateOrConnectWithoutUnitInput[]
    createMany?: RoomCreateManyUnitInputEnvelope
    connect?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
  }

  export type DepartmentCreateNestedOneWithoutUnitsInput = {
    create?: XOR<DepartmentCreateWithoutUnitsInput, DepartmentUncheckedCreateWithoutUnitsInput>
    connectOrCreate?: DepartmentCreateOrConnectWithoutUnitsInput
    connect?: DepartmentWhereUniqueInput
  }

  export type StockDetailCreateNestedManyWithoutUnitInput = {
    create?: XOR<StockDetailCreateWithoutUnitInput, StockDetailUncheckedCreateWithoutUnitInput> | StockDetailCreateWithoutUnitInput[] | StockDetailUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: StockDetailCreateOrConnectWithoutUnitInput | StockDetailCreateOrConnectWithoutUnitInput[]
    createMany?: StockDetailCreateManyUnitInputEnvelope
    connect?: StockDetailWhereUniqueInput | StockDetailWhereUniqueInput[]
  }

  export type DoctorScheduleCreateNestedManyWithoutUnitInput = {
    create?: XOR<DoctorScheduleCreateWithoutUnitInput, DoctorScheduleUncheckedCreateWithoutUnitInput> | DoctorScheduleCreateWithoutUnitInput[] | DoctorScheduleUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: DoctorScheduleCreateOrConnectWithoutUnitInput | DoctorScheduleCreateOrConnectWithoutUnitInput[]
    createMany?: DoctorScheduleCreateManyUnitInputEnvelope
    connect?: DoctorScheduleWhereUniqueInput | DoctorScheduleWhereUniqueInput[]
  }

  export type ReservationCreateNestedManyWithoutUnitInput = {
    create?: XOR<ReservationCreateWithoutUnitInput, ReservationUncheckedCreateWithoutUnitInput> | ReservationCreateWithoutUnitInput[] | ReservationUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: ReservationCreateOrConnectWithoutUnitInput | ReservationCreateOrConnectWithoutUnitInput[]
    createMany?: ReservationCreateManyUnitInputEnvelope
    connect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
  }

  export type RoomUncheckedCreateNestedManyWithoutUnitInput = {
    create?: XOR<RoomCreateWithoutUnitInput, RoomUncheckedCreateWithoutUnitInput> | RoomCreateWithoutUnitInput[] | RoomUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: RoomCreateOrConnectWithoutUnitInput | RoomCreateOrConnectWithoutUnitInput[]
    createMany?: RoomCreateManyUnitInputEnvelope
    connect?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
  }

  export type StockDetailUncheckedCreateNestedManyWithoutUnitInput = {
    create?: XOR<StockDetailCreateWithoutUnitInput, StockDetailUncheckedCreateWithoutUnitInput> | StockDetailCreateWithoutUnitInput[] | StockDetailUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: StockDetailCreateOrConnectWithoutUnitInput | StockDetailCreateOrConnectWithoutUnitInput[]
    createMany?: StockDetailCreateManyUnitInputEnvelope
    connect?: StockDetailWhereUniqueInput | StockDetailWhereUniqueInput[]
  }

  export type DoctorScheduleUncheckedCreateNestedManyWithoutUnitInput = {
    create?: XOR<DoctorScheduleCreateWithoutUnitInput, DoctorScheduleUncheckedCreateWithoutUnitInput> | DoctorScheduleCreateWithoutUnitInput[] | DoctorScheduleUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: DoctorScheduleCreateOrConnectWithoutUnitInput | DoctorScheduleCreateOrConnectWithoutUnitInput[]
    createMany?: DoctorScheduleCreateManyUnitInputEnvelope
    connect?: DoctorScheduleWhereUniqueInput | DoctorScheduleWhereUniqueInput[]
  }

  export type ReservationUncheckedCreateNestedManyWithoutUnitInput = {
    create?: XOR<ReservationCreateWithoutUnitInput, ReservationUncheckedCreateWithoutUnitInput> | ReservationCreateWithoutUnitInput[] | ReservationUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: ReservationCreateOrConnectWithoutUnitInput | ReservationCreateOrConnectWithoutUnitInput[]
    createMany?: ReservationCreateManyUnitInputEnvelope
    connect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
  }

  export type RoomUpdateManyWithoutUnitNestedInput = {
    create?: XOR<RoomCreateWithoutUnitInput, RoomUncheckedCreateWithoutUnitInput> | RoomCreateWithoutUnitInput[] | RoomUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: RoomCreateOrConnectWithoutUnitInput | RoomCreateOrConnectWithoutUnitInput[]
    upsert?: RoomUpsertWithWhereUniqueWithoutUnitInput | RoomUpsertWithWhereUniqueWithoutUnitInput[]
    createMany?: RoomCreateManyUnitInputEnvelope
    set?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
    disconnect?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
    delete?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
    connect?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
    update?: RoomUpdateWithWhereUniqueWithoutUnitInput | RoomUpdateWithWhereUniqueWithoutUnitInput[]
    updateMany?: RoomUpdateManyWithWhereWithoutUnitInput | RoomUpdateManyWithWhereWithoutUnitInput[]
    deleteMany?: RoomScalarWhereInput | RoomScalarWhereInput[]
  }

  export type DepartmentUpdateOneWithoutUnitsNestedInput = {
    create?: XOR<DepartmentCreateWithoutUnitsInput, DepartmentUncheckedCreateWithoutUnitsInput>
    connectOrCreate?: DepartmentCreateOrConnectWithoutUnitsInput
    upsert?: DepartmentUpsertWithoutUnitsInput
    disconnect?: DepartmentWhereInput | boolean
    delete?: DepartmentWhereInput | boolean
    connect?: DepartmentWhereUniqueInput
    update?: XOR<XOR<DepartmentUpdateToOneWithWhereWithoutUnitsInput, DepartmentUpdateWithoutUnitsInput>, DepartmentUncheckedUpdateWithoutUnitsInput>
  }

  export type StockDetailUpdateManyWithoutUnitNestedInput = {
    create?: XOR<StockDetailCreateWithoutUnitInput, StockDetailUncheckedCreateWithoutUnitInput> | StockDetailCreateWithoutUnitInput[] | StockDetailUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: StockDetailCreateOrConnectWithoutUnitInput | StockDetailCreateOrConnectWithoutUnitInput[]
    upsert?: StockDetailUpsertWithWhereUniqueWithoutUnitInput | StockDetailUpsertWithWhereUniqueWithoutUnitInput[]
    createMany?: StockDetailCreateManyUnitInputEnvelope
    set?: StockDetailWhereUniqueInput | StockDetailWhereUniqueInput[]
    disconnect?: StockDetailWhereUniqueInput | StockDetailWhereUniqueInput[]
    delete?: StockDetailWhereUniqueInput | StockDetailWhereUniqueInput[]
    connect?: StockDetailWhereUniqueInput | StockDetailWhereUniqueInput[]
    update?: StockDetailUpdateWithWhereUniqueWithoutUnitInput | StockDetailUpdateWithWhereUniqueWithoutUnitInput[]
    updateMany?: StockDetailUpdateManyWithWhereWithoutUnitInput | StockDetailUpdateManyWithWhereWithoutUnitInput[]
    deleteMany?: StockDetailScalarWhereInput | StockDetailScalarWhereInput[]
  }

  export type DoctorScheduleUpdateManyWithoutUnitNestedInput = {
    create?: XOR<DoctorScheduleCreateWithoutUnitInput, DoctorScheduleUncheckedCreateWithoutUnitInput> | DoctorScheduleCreateWithoutUnitInput[] | DoctorScheduleUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: DoctorScheduleCreateOrConnectWithoutUnitInput | DoctorScheduleCreateOrConnectWithoutUnitInput[]
    upsert?: DoctorScheduleUpsertWithWhereUniqueWithoutUnitInput | DoctorScheduleUpsertWithWhereUniqueWithoutUnitInput[]
    createMany?: DoctorScheduleCreateManyUnitInputEnvelope
    set?: DoctorScheduleWhereUniqueInput | DoctorScheduleWhereUniqueInput[]
    disconnect?: DoctorScheduleWhereUniqueInput | DoctorScheduleWhereUniqueInput[]
    delete?: DoctorScheduleWhereUniqueInput | DoctorScheduleWhereUniqueInput[]
    connect?: DoctorScheduleWhereUniqueInput | DoctorScheduleWhereUniqueInput[]
    update?: DoctorScheduleUpdateWithWhereUniqueWithoutUnitInput | DoctorScheduleUpdateWithWhereUniqueWithoutUnitInput[]
    updateMany?: DoctorScheduleUpdateManyWithWhereWithoutUnitInput | DoctorScheduleUpdateManyWithWhereWithoutUnitInput[]
    deleteMany?: DoctorScheduleScalarWhereInput | DoctorScheduleScalarWhereInput[]
  }

  export type ReservationUpdateManyWithoutUnitNestedInput = {
    create?: XOR<ReservationCreateWithoutUnitInput, ReservationUncheckedCreateWithoutUnitInput> | ReservationCreateWithoutUnitInput[] | ReservationUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: ReservationCreateOrConnectWithoutUnitInput | ReservationCreateOrConnectWithoutUnitInput[]
    upsert?: ReservationUpsertWithWhereUniqueWithoutUnitInput | ReservationUpsertWithWhereUniqueWithoutUnitInput[]
    createMany?: ReservationCreateManyUnitInputEnvelope
    set?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    disconnect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    delete?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    connect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    update?: ReservationUpdateWithWhereUniqueWithoutUnitInput | ReservationUpdateWithWhereUniqueWithoutUnitInput[]
    updateMany?: ReservationUpdateManyWithWhereWithoutUnitInput | ReservationUpdateManyWithWhereWithoutUnitInput[]
    deleteMany?: ReservationScalarWhereInput | ReservationScalarWhereInput[]
  }

  export type RoomUncheckedUpdateManyWithoutUnitNestedInput = {
    create?: XOR<RoomCreateWithoutUnitInput, RoomUncheckedCreateWithoutUnitInput> | RoomCreateWithoutUnitInput[] | RoomUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: RoomCreateOrConnectWithoutUnitInput | RoomCreateOrConnectWithoutUnitInput[]
    upsert?: RoomUpsertWithWhereUniqueWithoutUnitInput | RoomUpsertWithWhereUniqueWithoutUnitInput[]
    createMany?: RoomCreateManyUnitInputEnvelope
    set?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
    disconnect?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
    delete?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
    connect?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
    update?: RoomUpdateWithWhereUniqueWithoutUnitInput | RoomUpdateWithWhereUniqueWithoutUnitInput[]
    updateMany?: RoomUpdateManyWithWhereWithoutUnitInput | RoomUpdateManyWithWhereWithoutUnitInput[]
    deleteMany?: RoomScalarWhereInput | RoomScalarWhereInput[]
  }

  export type StockDetailUncheckedUpdateManyWithoutUnitNestedInput = {
    create?: XOR<StockDetailCreateWithoutUnitInput, StockDetailUncheckedCreateWithoutUnitInput> | StockDetailCreateWithoutUnitInput[] | StockDetailUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: StockDetailCreateOrConnectWithoutUnitInput | StockDetailCreateOrConnectWithoutUnitInput[]
    upsert?: StockDetailUpsertWithWhereUniqueWithoutUnitInput | StockDetailUpsertWithWhereUniqueWithoutUnitInput[]
    createMany?: StockDetailCreateManyUnitInputEnvelope
    set?: StockDetailWhereUniqueInput | StockDetailWhereUniqueInput[]
    disconnect?: StockDetailWhereUniqueInput | StockDetailWhereUniqueInput[]
    delete?: StockDetailWhereUniqueInput | StockDetailWhereUniqueInput[]
    connect?: StockDetailWhereUniqueInput | StockDetailWhereUniqueInput[]
    update?: StockDetailUpdateWithWhereUniqueWithoutUnitInput | StockDetailUpdateWithWhereUniqueWithoutUnitInput[]
    updateMany?: StockDetailUpdateManyWithWhereWithoutUnitInput | StockDetailUpdateManyWithWhereWithoutUnitInput[]
    deleteMany?: StockDetailScalarWhereInput | StockDetailScalarWhereInput[]
  }

  export type DoctorScheduleUncheckedUpdateManyWithoutUnitNestedInput = {
    create?: XOR<DoctorScheduleCreateWithoutUnitInput, DoctorScheduleUncheckedCreateWithoutUnitInput> | DoctorScheduleCreateWithoutUnitInput[] | DoctorScheduleUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: DoctorScheduleCreateOrConnectWithoutUnitInput | DoctorScheduleCreateOrConnectWithoutUnitInput[]
    upsert?: DoctorScheduleUpsertWithWhereUniqueWithoutUnitInput | DoctorScheduleUpsertWithWhereUniqueWithoutUnitInput[]
    createMany?: DoctorScheduleCreateManyUnitInputEnvelope
    set?: DoctorScheduleWhereUniqueInput | DoctorScheduleWhereUniqueInput[]
    disconnect?: DoctorScheduleWhereUniqueInput | DoctorScheduleWhereUniqueInput[]
    delete?: DoctorScheduleWhereUniqueInput | DoctorScheduleWhereUniqueInput[]
    connect?: DoctorScheduleWhereUniqueInput | DoctorScheduleWhereUniqueInput[]
    update?: DoctorScheduleUpdateWithWhereUniqueWithoutUnitInput | DoctorScheduleUpdateWithWhereUniqueWithoutUnitInput[]
    updateMany?: DoctorScheduleUpdateManyWithWhereWithoutUnitInput | DoctorScheduleUpdateManyWithWhereWithoutUnitInput[]
    deleteMany?: DoctorScheduleScalarWhereInput | DoctorScheduleScalarWhereInput[]
  }

  export type ReservationUncheckedUpdateManyWithoutUnitNestedInput = {
    create?: XOR<ReservationCreateWithoutUnitInput, ReservationUncheckedCreateWithoutUnitInput> | ReservationCreateWithoutUnitInput[] | ReservationUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: ReservationCreateOrConnectWithoutUnitInput | ReservationCreateOrConnectWithoutUnitInput[]
    upsert?: ReservationUpsertWithWhereUniqueWithoutUnitInput | ReservationUpsertWithWhereUniqueWithoutUnitInput[]
    createMany?: ReservationCreateManyUnitInputEnvelope
    set?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    disconnect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    delete?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    connect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    update?: ReservationUpdateWithWhereUniqueWithoutUnitInput | ReservationUpdateWithWhereUniqueWithoutUnitInput[]
    updateMany?: ReservationUpdateManyWithWhereWithoutUnitInput | ReservationUpdateManyWithWhereWithoutUnitInput[]
    deleteMany?: ReservationScalarWhereInput | ReservationScalarWhereInput[]
  }

  export type BedCreateNestedManyWithoutBedStatusInput = {
    create?: XOR<BedCreateWithoutBedStatusInput, BedUncheckedCreateWithoutBedStatusInput> | BedCreateWithoutBedStatusInput[] | BedUncheckedCreateWithoutBedStatusInput[]
    connectOrCreate?: BedCreateOrConnectWithoutBedStatusInput | BedCreateOrConnectWithoutBedStatusInput[]
    createMany?: BedCreateManyBedStatusInputEnvelope
    connect?: BedWhereUniqueInput | BedWhereUniqueInput[]
  }

  export type BedUncheckedCreateNestedManyWithoutBedStatusInput = {
    create?: XOR<BedCreateWithoutBedStatusInput, BedUncheckedCreateWithoutBedStatusInput> | BedCreateWithoutBedStatusInput[] | BedUncheckedCreateWithoutBedStatusInput[]
    connectOrCreate?: BedCreateOrConnectWithoutBedStatusInput | BedCreateOrConnectWithoutBedStatusInput[]
    createMany?: BedCreateManyBedStatusInputEnvelope
    connect?: BedWhereUniqueInput | BedWhereUniqueInput[]
  }

  export type BedUpdateManyWithoutBedStatusNestedInput = {
    create?: XOR<BedCreateWithoutBedStatusInput, BedUncheckedCreateWithoutBedStatusInput> | BedCreateWithoutBedStatusInput[] | BedUncheckedCreateWithoutBedStatusInput[]
    connectOrCreate?: BedCreateOrConnectWithoutBedStatusInput | BedCreateOrConnectWithoutBedStatusInput[]
    upsert?: BedUpsertWithWhereUniqueWithoutBedStatusInput | BedUpsertWithWhereUniqueWithoutBedStatusInput[]
    createMany?: BedCreateManyBedStatusInputEnvelope
    set?: BedWhereUniqueInput | BedWhereUniqueInput[]
    disconnect?: BedWhereUniqueInput | BedWhereUniqueInput[]
    delete?: BedWhereUniqueInput | BedWhereUniqueInput[]
    connect?: BedWhereUniqueInput | BedWhereUniqueInput[]
    update?: BedUpdateWithWhereUniqueWithoutBedStatusInput | BedUpdateWithWhereUniqueWithoutBedStatusInput[]
    updateMany?: BedUpdateManyWithWhereWithoutBedStatusInput | BedUpdateManyWithWhereWithoutBedStatusInput[]
    deleteMany?: BedScalarWhereInput | BedScalarWhereInput[]
  }

  export type BedUncheckedUpdateManyWithoutBedStatusNestedInput = {
    create?: XOR<BedCreateWithoutBedStatusInput, BedUncheckedCreateWithoutBedStatusInput> | BedCreateWithoutBedStatusInput[] | BedUncheckedCreateWithoutBedStatusInput[]
    connectOrCreate?: BedCreateOrConnectWithoutBedStatusInput | BedCreateOrConnectWithoutBedStatusInput[]
    upsert?: BedUpsertWithWhereUniqueWithoutBedStatusInput | BedUpsertWithWhereUniqueWithoutBedStatusInput[]
    createMany?: BedCreateManyBedStatusInputEnvelope
    set?: BedWhereUniqueInput | BedWhereUniqueInput[]
    disconnect?: BedWhereUniqueInput | BedWhereUniqueInput[]
    delete?: BedWhereUniqueInput | BedWhereUniqueInput[]
    connect?: BedWhereUniqueInput | BedWhereUniqueInput[]
    update?: BedUpdateWithWhereUniqueWithoutBedStatusInput | BedUpdateWithWhereUniqueWithoutBedStatusInput[]
    updateMany?: BedUpdateManyWithWhereWithoutBedStatusInput | BedUpdateManyWithWhereWithoutBedStatusInput[]
    deleteMany?: BedScalarWhereInput | BedScalarWhereInput[]
  }

  export type RoomCreateNestedManyWithoutClassInput = {
    create?: XOR<RoomCreateWithoutClassInput, RoomUncheckedCreateWithoutClassInput> | RoomCreateWithoutClassInput[] | RoomUncheckedCreateWithoutClassInput[]
    connectOrCreate?: RoomCreateOrConnectWithoutClassInput | RoomCreateOrConnectWithoutClassInput[]
    createMany?: RoomCreateManyClassInputEnvelope
    connect?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
  }

  export type RoomUncheckedCreateNestedManyWithoutClassInput = {
    create?: XOR<RoomCreateWithoutClassInput, RoomUncheckedCreateWithoutClassInput> | RoomCreateWithoutClassInput[] | RoomUncheckedCreateWithoutClassInput[]
    connectOrCreate?: RoomCreateOrConnectWithoutClassInput | RoomCreateOrConnectWithoutClassInput[]
    createMany?: RoomCreateManyClassInputEnvelope
    connect?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
  }

  export type RoomUpdateManyWithoutClassNestedInput = {
    create?: XOR<RoomCreateWithoutClassInput, RoomUncheckedCreateWithoutClassInput> | RoomCreateWithoutClassInput[] | RoomUncheckedCreateWithoutClassInput[]
    connectOrCreate?: RoomCreateOrConnectWithoutClassInput | RoomCreateOrConnectWithoutClassInput[]
    upsert?: RoomUpsertWithWhereUniqueWithoutClassInput | RoomUpsertWithWhereUniqueWithoutClassInput[]
    createMany?: RoomCreateManyClassInputEnvelope
    set?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
    disconnect?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
    delete?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
    connect?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
    update?: RoomUpdateWithWhereUniqueWithoutClassInput | RoomUpdateWithWhereUniqueWithoutClassInput[]
    updateMany?: RoomUpdateManyWithWhereWithoutClassInput | RoomUpdateManyWithWhereWithoutClassInput[]
    deleteMany?: RoomScalarWhereInput | RoomScalarWhereInput[]
  }

  export type RoomUncheckedUpdateManyWithoutClassNestedInput = {
    create?: XOR<RoomCreateWithoutClassInput, RoomUncheckedCreateWithoutClassInput> | RoomCreateWithoutClassInput[] | RoomUncheckedCreateWithoutClassInput[]
    connectOrCreate?: RoomCreateOrConnectWithoutClassInput | RoomCreateOrConnectWithoutClassInput[]
    upsert?: RoomUpsertWithWhereUniqueWithoutClassInput | RoomUpsertWithWhereUniqueWithoutClassInput[]
    createMany?: RoomCreateManyClassInputEnvelope
    set?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
    disconnect?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
    delete?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
    connect?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
    update?: RoomUpdateWithWhereUniqueWithoutClassInput | RoomUpdateWithWhereUniqueWithoutClassInput[]
    updateMany?: RoomUpdateManyWithWhereWithoutClassInput | RoomUpdateManyWithWhereWithoutClassInput[]
    deleteMany?: RoomScalarWhereInput | RoomScalarWhereInput[]
  }

  export type UnitCreateNestedManyWithoutDepartmentInput = {
    create?: XOR<UnitCreateWithoutDepartmentInput, UnitUncheckedCreateWithoutDepartmentInput> | UnitCreateWithoutDepartmentInput[] | UnitUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: UnitCreateOrConnectWithoutDepartmentInput | UnitCreateOrConnectWithoutDepartmentInput[]
    createMany?: UnitCreateManyDepartmentInputEnvelope
    connect?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
  }

  export type UnitUncheckedCreateNestedManyWithoutDepartmentInput = {
    create?: XOR<UnitCreateWithoutDepartmentInput, UnitUncheckedCreateWithoutDepartmentInput> | UnitCreateWithoutDepartmentInput[] | UnitUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: UnitCreateOrConnectWithoutDepartmentInput | UnitCreateOrConnectWithoutDepartmentInput[]
    createMany?: UnitCreateManyDepartmentInputEnvelope
    connect?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
  }

  export type UnitUpdateManyWithoutDepartmentNestedInput = {
    create?: XOR<UnitCreateWithoutDepartmentInput, UnitUncheckedCreateWithoutDepartmentInput> | UnitCreateWithoutDepartmentInput[] | UnitUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: UnitCreateOrConnectWithoutDepartmentInput | UnitCreateOrConnectWithoutDepartmentInput[]
    upsert?: UnitUpsertWithWhereUniqueWithoutDepartmentInput | UnitUpsertWithWhereUniqueWithoutDepartmentInput[]
    createMany?: UnitCreateManyDepartmentInputEnvelope
    set?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
    disconnect?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
    delete?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
    connect?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
    update?: UnitUpdateWithWhereUniqueWithoutDepartmentInput | UnitUpdateWithWhereUniqueWithoutDepartmentInput[]
    updateMany?: UnitUpdateManyWithWhereWithoutDepartmentInput | UnitUpdateManyWithWhereWithoutDepartmentInput[]
    deleteMany?: UnitScalarWhereInput | UnitScalarWhereInput[]
  }

  export type UnitUncheckedUpdateManyWithoutDepartmentNestedInput = {
    create?: XOR<UnitCreateWithoutDepartmentInput, UnitUncheckedCreateWithoutDepartmentInput> | UnitCreateWithoutDepartmentInput[] | UnitUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: UnitCreateOrConnectWithoutDepartmentInput | UnitCreateOrConnectWithoutDepartmentInput[]
    upsert?: UnitUpsertWithWhereUniqueWithoutDepartmentInput | UnitUpsertWithWhereUniqueWithoutDepartmentInput[]
    createMany?: UnitCreateManyDepartmentInputEnvelope
    set?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
    disconnect?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
    delete?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
    connect?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
    update?: UnitUpdateWithWhereUniqueWithoutDepartmentInput | UnitUpdateWithWhereUniqueWithoutDepartmentInput[]
    updateMany?: UnitUpdateManyWithWhereWithoutDepartmentInput | UnitUpdateManyWithWhereWithoutDepartmentInput[]
    deleteMany?: UnitScalarWhereInput | UnitScalarWhereInput[]
  }

  export type StockDetailCreateNestedManyWithoutProductInput = {
    create?: XOR<StockDetailCreateWithoutProductInput, StockDetailUncheckedCreateWithoutProductInput> | StockDetailCreateWithoutProductInput[] | StockDetailUncheckedCreateWithoutProductInput[]
    connectOrCreate?: StockDetailCreateOrConnectWithoutProductInput | StockDetailCreateOrConnectWithoutProductInput[]
    createMany?: StockDetailCreateManyProductInputEnvelope
    connect?: StockDetailWhereUniqueInput | StockDetailWhereUniqueInput[]
  }

  export type StockDetailUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<StockDetailCreateWithoutProductInput, StockDetailUncheckedCreateWithoutProductInput> | StockDetailCreateWithoutProductInput[] | StockDetailUncheckedCreateWithoutProductInput[]
    connectOrCreate?: StockDetailCreateOrConnectWithoutProductInput | StockDetailCreateOrConnectWithoutProductInput[]
    createMany?: StockDetailCreateManyProductInputEnvelope
    connect?: StockDetailWhereUniqueInput | StockDetailWhereUniqueInput[]
  }

  export type StockDetailUpdateManyWithoutProductNestedInput = {
    create?: XOR<StockDetailCreateWithoutProductInput, StockDetailUncheckedCreateWithoutProductInput> | StockDetailCreateWithoutProductInput[] | StockDetailUncheckedCreateWithoutProductInput[]
    connectOrCreate?: StockDetailCreateOrConnectWithoutProductInput | StockDetailCreateOrConnectWithoutProductInput[]
    upsert?: StockDetailUpsertWithWhereUniqueWithoutProductInput | StockDetailUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: StockDetailCreateManyProductInputEnvelope
    set?: StockDetailWhereUniqueInput | StockDetailWhereUniqueInput[]
    disconnect?: StockDetailWhereUniqueInput | StockDetailWhereUniqueInput[]
    delete?: StockDetailWhereUniqueInput | StockDetailWhereUniqueInput[]
    connect?: StockDetailWhereUniqueInput | StockDetailWhereUniqueInput[]
    update?: StockDetailUpdateWithWhereUniqueWithoutProductInput | StockDetailUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: StockDetailUpdateManyWithWhereWithoutProductInput | StockDetailUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: StockDetailScalarWhereInput | StockDetailScalarWhereInput[]
  }

  export type StockDetailUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<StockDetailCreateWithoutProductInput, StockDetailUncheckedCreateWithoutProductInput> | StockDetailCreateWithoutProductInput[] | StockDetailUncheckedCreateWithoutProductInput[]
    connectOrCreate?: StockDetailCreateOrConnectWithoutProductInput | StockDetailCreateOrConnectWithoutProductInput[]
    upsert?: StockDetailUpsertWithWhereUniqueWithoutProductInput | StockDetailUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: StockDetailCreateManyProductInputEnvelope
    set?: StockDetailWhereUniqueInput | StockDetailWhereUniqueInput[]
    disconnect?: StockDetailWhereUniqueInput | StockDetailWhereUniqueInput[]
    delete?: StockDetailWhereUniqueInput | StockDetailWhereUniqueInput[]
    connect?: StockDetailWhereUniqueInput | StockDetailWhereUniqueInput[]
    update?: StockDetailUpdateWithWhereUniqueWithoutProductInput | StockDetailUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: StockDetailUpdateManyWithWhereWithoutProductInput | StockDetailUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: StockDetailScalarWhereInput | StockDetailScalarWhereInput[]
  }

  export type StockDetailCreateNestedManyWithoutReceiptInput = {
    create?: XOR<StockDetailCreateWithoutReceiptInput, StockDetailUncheckedCreateWithoutReceiptInput> | StockDetailCreateWithoutReceiptInput[] | StockDetailUncheckedCreateWithoutReceiptInput[]
    connectOrCreate?: StockDetailCreateOrConnectWithoutReceiptInput | StockDetailCreateOrConnectWithoutReceiptInput[]
    createMany?: StockDetailCreateManyReceiptInputEnvelope
    connect?: StockDetailWhereUniqueInput | StockDetailWhereUniqueInput[]
  }

  export type StockDetailUncheckedCreateNestedManyWithoutReceiptInput = {
    create?: XOR<StockDetailCreateWithoutReceiptInput, StockDetailUncheckedCreateWithoutReceiptInput> | StockDetailCreateWithoutReceiptInput[] | StockDetailUncheckedCreateWithoutReceiptInput[]
    connectOrCreate?: StockDetailCreateOrConnectWithoutReceiptInput | StockDetailCreateOrConnectWithoutReceiptInput[]
    createMany?: StockDetailCreateManyReceiptInputEnvelope
    connect?: StockDetailWhereUniqueInput | StockDetailWhereUniqueInput[]
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type StockDetailUpdateManyWithoutReceiptNestedInput = {
    create?: XOR<StockDetailCreateWithoutReceiptInput, StockDetailUncheckedCreateWithoutReceiptInput> | StockDetailCreateWithoutReceiptInput[] | StockDetailUncheckedCreateWithoutReceiptInput[]
    connectOrCreate?: StockDetailCreateOrConnectWithoutReceiptInput | StockDetailCreateOrConnectWithoutReceiptInput[]
    upsert?: StockDetailUpsertWithWhereUniqueWithoutReceiptInput | StockDetailUpsertWithWhereUniqueWithoutReceiptInput[]
    createMany?: StockDetailCreateManyReceiptInputEnvelope
    set?: StockDetailWhereUniqueInput | StockDetailWhereUniqueInput[]
    disconnect?: StockDetailWhereUniqueInput | StockDetailWhereUniqueInput[]
    delete?: StockDetailWhereUniqueInput | StockDetailWhereUniqueInput[]
    connect?: StockDetailWhereUniqueInput | StockDetailWhereUniqueInput[]
    update?: StockDetailUpdateWithWhereUniqueWithoutReceiptInput | StockDetailUpdateWithWhereUniqueWithoutReceiptInput[]
    updateMany?: StockDetailUpdateManyWithWhereWithoutReceiptInput | StockDetailUpdateManyWithWhereWithoutReceiptInput[]
    deleteMany?: StockDetailScalarWhereInput | StockDetailScalarWhereInput[]
  }

  export type StockDetailUncheckedUpdateManyWithoutReceiptNestedInput = {
    create?: XOR<StockDetailCreateWithoutReceiptInput, StockDetailUncheckedCreateWithoutReceiptInput> | StockDetailCreateWithoutReceiptInput[] | StockDetailUncheckedCreateWithoutReceiptInput[]
    connectOrCreate?: StockDetailCreateOrConnectWithoutReceiptInput | StockDetailCreateOrConnectWithoutReceiptInput[]
    upsert?: StockDetailUpsertWithWhereUniqueWithoutReceiptInput | StockDetailUpsertWithWhereUniqueWithoutReceiptInput[]
    createMany?: StockDetailCreateManyReceiptInputEnvelope
    set?: StockDetailWhereUniqueInput | StockDetailWhereUniqueInput[]
    disconnect?: StockDetailWhereUniqueInput | StockDetailWhereUniqueInput[]
    delete?: StockDetailWhereUniqueInput | StockDetailWhereUniqueInput[]
    connect?: StockDetailWhereUniqueInput | StockDetailWhereUniqueInput[]
    update?: StockDetailUpdateWithWhereUniqueWithoutReceiptInput | StockDetailUpdateWithWhereUniqueWithoutReceiptInput[]
    updateMany?: StockDetailUpdateManyWithWhereWithoutReceiptInput | StockDetailUpdateManyWithWhereWithoutReceiptInput[]
    deleteMany?: StockDetailScalarWhereInput | StockDetailScalarWhereInput[]
  }

  export type ProductCreateNestedOneWithoutStockDetailsInput = {
    create?: XOR<ProductCreateWithoutStockDetailsInput, ProductUncheckedCreateWithoutStockDetailsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutStockDetailsInput
    connect?: ProductWhereUniqueInput
  }

  export type UnitCreateNestedOneWithoutStockDetailsInput = {
    create?: XOR<UnitCreateWithoutStockDetailsInput, UnitUncheckedCreateWithoutStockDetailsInput>
    connectOrCreate?: UnitCreateOrConnectWithoutStockDetailsInput
    connect?: UnitWhereUniqueInput
  }

  export type ServiceReceiptCreateNestedOneWithoutStockDetailsInput = {
    create?: XOR<ServiceReceiptCreateWithoutStockDetailsInput, ServiceReceiptUncheckedCreateWithoutStockDetailsInput>
    connectOrCreate?: ServiceReceiptCreateOrConnectWithoutStockDetailsInput
    connect?: ServiceReceiptWhereUniqueInput
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type ProductUpdateOneRequiredWithoutStockDetailsNestedInput = {
    create?: XOR<ProductCreateWithoutStockDetailsInput, ProductUncheckedCreateWithoutStockDetailsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutStockDetailsInput
    upsert?: ProductUpsertWithoutStockDetailsInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutStockDetailsInput, ProductUpdateWithoutStockDetailsInput>, ProductUncheckedUpdateWithoutStockDetailsInput>
  }

  export type UnitUpdateOneRequiredWithoutStockDetailsNestedInput = {
    create?: XOR<UnitCreateWithoutStockDetailsInput, UnitUncheckedCreateWithoutStockDetailsInput>
    connectOrCreate?: UnitCreateOrConnectWithoutStockDetailsInput
    upsert?: UnitUpsertWithoutStockDetailsInput
    connect?: UnitWhereUniqueInput
    update?: XOR<XOR<UnitUpdateToOneWithWhereWithoutStockDetailsInput, UnitUpdateWithoutStockDetailsInput>, UnitUncheckedUpdateWithoutStockDetailsInput>
  }

  export type ServiceReceiptUpdateOneRequiredWithoutStockDetailsNestedInput = {
    create?: XOR<ServiceReceiptCreateWithoutStockDetailsInput, ServiceReceiptUncheckedCreateWithoutStockDetailsInput>
    connectOrCreate?: ServiceReceiptCreateOrConnectWithoutStockDetailsInput
    upsert?: ServiceReceiptUpsertWithoutStockDetailsInput
    connect?: ServiceReceiptWhereUniqueInput
    update?: XOR<XOR<ServiceReceiptUpdateToOneWithWhereWithoutStockDetailsInput, ServiceReceiptUpdateWithoutStockDetailsInput>, ServiceReceiptUncheckedUpdateWithoutStockDetailsInput>
  }

  export type UnitCreateNestedOneWithoutDoctorSchedulesInput = {
    create?: XOR<UnitCreateWithoutDoctorSchedulesInput, UnitUncheckedCreateWithoutDoctorSchedulesInput>
    connectOrCreate?: UnitCreateOrConnectWithoutDoctorSchedulesInput
    connect?: UnitWhereUniqueInput
  }

  export type EmployeeCreateNestedOneWithoutDoctorSchedulesInput = {
    create?: XOR<EmployeeCreateWithoutDoctorSchedulesInput, EmployeeUncheckedCreateWithoutDoctorSchedulesInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutDoctorSchedulesInput
    connect?: EmployeeWhereUniqueInput
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type UnitUpdateOneRequiredWithoutDoctorSchedulesNestedInput = {
    create?: XOR<UnitCreateWithoutDoctorSchedulesInput, UnitUncheckedCreateWithoutDoctorSchedulesInput>
    connectOrCreate?: UnitCreateOrConnectWithoutDoctorSchedulesInput
    upsert?: UnitUpsertWithoutDoctorSchedulesInput
    connect?: UnitWhereUniqueInput
    update?: XOR<XOR<UnitUpdateToOneWithWhereWithoutDoctorSchedulesInput, UnitUpdateWithoutDoctorSchedulesInput>, UnitUncheckedUpdateWithoutDoctorSchedulesInput>
  }

  export type EmployeeUpdateOneRequiredWithoutDoctorSchedulesNestedInput = {
    create?: XOR<EmployeeCreateWithoutDoctorSchedulesInput, EmployeeUncheckedCreateWithoutDoctorSchedulesInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutDoctorSchedulesInput
    upsert?: EmployeeUpsertWithoutDoctorSchedulesInput
    connect?: EmployeeWhereUniqueInput
    update?: XOR<XOR<EmployeeUpdateToOneWithWhereWithoutDoctorSchedulesInput, EmployeeUpdateWithoutDoctorSchedulesInput>, EmployeeUncheckedUpdateWithoutDoctorSchedulesInput>
  }

  export type DoctorScheduleCreateNestedManyWithoutDoctorInput = {
    create?: XOR<DoctorScheduleCreateWithoutDoctorInput, DoctorScheduleUncheckedCreateWithoutDoctorInput> | DoctorScheduleCreateWithoutDoctorInput[] | DoctorScheduleUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: DoctorScheduleCreateOrConnectWithoutDoctorInput | DoctorScheduleCreateOrConnectWithoutDoctorInput[]
    createMany?: DoctorScheduleCreateManyDoctorInputEnvelope
    connect?: DoctorScheduleWhereUniqueInput | DoctorScheduleWhereUniqueInput[]
  }

  export type ReservationCreateNestedManyWithoutDoctorInput = {
    create?: XOR<ReservationCreateWithoutDoctorInput, ReservationUncheckedCreateWithoutDoctorInput> | ReservationCreateWithoutDoctorInput[] | ReservationUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: ReservationCreateOrConnectWithoutDoctorInput | ReservationCreateOrConnectWithoutDoctorInput[]
    createMany?: ReservationCreateManyDoctorInputEnvelope
    connect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
  }

  export type DoctorScheduleUncheckedCreateNestedManyWithoutDoctorInput = {
    create?: XOR<DoctorScheduleCreateWithoutDoctorInput, DoctorScheduleUncheckedCreateWithoutDoctorInput> | DoctorScheduleCreateWithoutDoctorInput[] | DoctorScheduleUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: DoctorScheduleCreateOrConnectWithoutDoctorInput | DoctorScheduleCreateOrConnectWithoutDoctorInput[]
    createMany?: DoctorScheduleCreateManyDoctorInputEnvelope
    connect?: DoctorScheduleWhereUniqueInput | DoctorScheduleWhereUniqueInput[]
  }

  export type ReservationUncheckedCreateNestedManyWithoutDoctorInput = {
    create?: XOR<ReservationCreateWithoutDoctorInput, ReservationUncheckedCreateWithoutDoctorInput> | ReservationCreateWithoutDoctorInput[] | ReservationUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: ReservationCreateOrConnectWithoutDoctorInput | ReservationCreateOrConnectWithoutDoctorInput[]
    createMany?: ReservationCreateManyDoctorInputEnvelope
    connect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
  }

  export type DoctorScheduleUpdateManyWithoutDoctorNestedInput = {
    create?: XOR<DoctorScheduleCreateWithoutDoctorInput, DoctorScheduleUncheckedCreateWithoutDoctorInput> | DoctorScheduleCreateWithoutDoctorInput[] | DoctorScheduleUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: DoctorScheduleCreateOrConnectWithoutDoctorInput | DoctorScheduleCreateOrConnectWithoutDoctorInput[]
    upsert?: DoctorScheduleUpsertWithWhereUniqueWithoutDoctorInput | DoctorScheduleUpsertWithWhereUniqueWithoutDoctorInput[]
    createMany?: DoctorScheduleCreateManyDoctorInputEnvelope
    set?: DoctorScheduleWhereUniqueInput | DoctorScheduleWhereUniqueInput[]
    disconnect?: DoctorScheduleWhereUniqueInput | DoctorScheduleWhereUniqueInput[]
    delete?: DoctorScheduleWhereUniqueInput | DoctorScheduleWhereUniqueInput[]
    connect?: DoctorScheduleWhereUniqueInput | DoctorScheduleWhereUniqueInput[]
    update?: DoctorScheduleUpdateWithWhereUniqueWithoutDoctorInput | DoctorScheduleUpdateWithWhereUniqueWithoutDoctorInput[]
    updateMany?: DoctorScheduleUpdateManyWithWhereWithoutDoctorInput | DoctorScheduleUpdateManyWithWhereWithoutDoctorInput[]
    deleteMany?: DoctorScheduleScalarWhereInput | DoctorScheduleScalarWhereInput[]
  }

  export type ReservationUpdateManyWithoutDoctorNestedInput = {
    create?: XOR<ReservationCreateWithoutDoctorInput, ReservationUncheckedCreateWithoutDoctorInput> | ReservationCreateWithoutDoctorInput[] | ReservationUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: ReservationCreateOrConnectWithoutDoctorInput | ReservationCreateOrConnectWithoutDoctorInput[]
    upsert?: ReservationUpsertWithWhereUniqueWithoutDoctorInput | ReservationUpsertWithWhereUniqueWithoutDoctorInput[]
    createMany?: ReservationCreateManyDoctorInputEnvelope
    set?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    disconnect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    delete?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    connect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    update?: ReservationUpdateWithWhereUniqueWithoutDoctorInput | ReservationUpdateWithWhereUniqueWithoutDoctorInput[]
    updateMany?: ReservationUpdateManyWithWhereWithoutDoctorInput | ReservationUpdateManyWithWhereWithoutDoctorInput[]
    deleteMany?: ReservationScalarWhereInput | ReservationScalarWhereInput[]
  }

  export type DoctorScheduleUncheckedUpdateManyWithoutDoctorNestedInput = {
    create?: XOR<DoctorScheduleCreateWithoutDoctorInput, DoctorScheduleUncheckedCreateWithoutDoctorInput> | DoctorScheduleCreateWithoutDoctorInput[] | DoctorScheduleUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: DoctorScheduleCreateOrConnectWithoutDoctorInput | DoctorScheduleCreateOrConnectWithoutDoctorInput[]
    upsert?: DoctorScheduleUpsertWithWhereUniqueWithoutDoctorInput | DoctorScheduleUpsertWithWhereUniqueWithoutDoctorInput[]
    createMany?: DoctorScheduleCreateManyDoctorInputEnvelope
    set?: DoctorScheduleWhereUniqueInput | DoctorScheduleWhereUniqueInput[]
    disconnect?: DoctorScheduleWhereUniqueInput | DoctorScheduleWhereUniqueInput[]
    delete?: DoctorScheduleWhereUniqueInput | DoctorScheduleWhereUniqueInput[]
    connect?: DoctorScheduleWhereUniqueInput | DoctorScheduleWhereUniqueInput[]
    update?: DoctorScheduleUpdateWithWhereUniqueWithoutDoctorInput | DoctorScheduleUpdateWithWhereUniqueWithoutDoctorInput[]
    updateMany?: DoctorScheduleUpdateManyWithWhereWithoutDoctorInput | DoctorScheduleUpdateManyWithWhereWithoutDoctorInput[]
    deleteMany?: DoctorScheduleScalarWhereInput | DoctorScheduleScalarWhereInput[]
  }

  export type ReservationUncheckedUpdateManyWithoutDoctorNestedInput = {
    create?: XOR<ReservationCreateWithoutDoctorInput, ReservationUncheckedCreateWithoutDoctorInput> | ReservationCreateWithoutDoctorInput[] | ReservationUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: ReservationCreateOrConnectWithoutDoctorInput | ReservationCreateOrConnectWithoutDoctorInput[]
    upsert?: ReservationUpsertWithWhereUniqueWithoutDoctorInput | ReservationUpsertWithWhereUniqueWithoutDoctorInput[]
    createMany?: ReservationCreateManyDoctorInputEnvelope
    set?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    disconnect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    delete?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    connect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    update?: ReservationUpdateWithWhereUniqueWithoutDoctorInput | ReservationUpdateWithWhereUniqueWithoutDoctorInput[]
    updateMany?: ReservationUpdateManyWithWhereWithoutDoctorInput | ReservationUpdateManyWithWhereWithoutDoctorInput[]
    deleteMany?: ReservationScalarWhereInput | ReservationScalarWhereInput[]
  }

  export type UnitCreateNestedOneWithoutReservationsInput = {
    create?: XOR<UnitCreateWithoutReservationsInput, UnitUncheckedCreateWithoutReservationsInput>
    connectOrCreate?: UnitCreateOrConnectWithoutReservationsInput
    connect?: UnitWhereUniqueInput
  }

  export type PatientCreateNestedOneWithoutReservationsInput = {
    create?: XOR<PatientCreateWithoutReservationsInput, PatientUncheckedCreateWithoutReservationsInput>
    connectOrCreate?: PatientCreateOrConnectWithoutReservationsInput
    connect?: PatientWhereUniqueInput
  }

  export type PaymentMethodCreateNestedOneWithoutReservationsInput = {
    create?: XOR<PaymentMethodCreateWithoutReservationsInput, PaymentMethodUncheckedCreateWithoutReservationsInput>
    connectOrCreate?: PaymentMethodCreateOrConnectWithoutReservationsInput
    connect?: PaymentMethodWhereUniqueInput
  }

  export type EmployeeCreateNestedOneWithoutReservationsInput = {
    create?: XOR<EmployeeCreateWithoutReservationsInput, EmployeeUncheckedCreateWithoutReservationsInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutReservationsInput
    connect?: EmployeeWhereUniqueInput
  }

  export type ReferralSourceCreateNestedOneWithoutReservationsInput = {
    create?: XOR<ReferralSourceCreateWithoutReservationsInput, ReferralSourceUncheckedCreateWithoutReservationsInput>
    connectOrCreate?: ReferralSourceCreateOrConnectWithoutReservationsInput
    connect?: ReferralSourceWhereUniqueInput
  }

  export type UnitUpdateOneRequiredWithoutReservationsNestedInput = {
    create?: XOR<UnitCreateWithoutReservationsInput, UnitUncheckedCreateWithoutReservationsInput>
    connectOrCreate?: UnitCreateOrConnectWithoutReservationsInput
    upsert?: UnitUpsertWithoutReservationsInput
    connect?: UnitWhereUniqueInput
    update?: XOR<XOR<UnitUpdateToOneWithWhereWithoutReservationsInput, UnitUpdateWithoutReservationsInput>, UnitUncheckedUpdateWithoutReservationsInput>
  }

  export type PatientUpdateOneWithoutReservationsNestedInput = {
    create?: XOR<PatientCreateWithoutReservationsInput, PatientUncheckedCreateWithoutReservationsInput>
    connectOrCreate?: PatientCreateOrConnectWithoutReservationsInput
    upsert?: PatientUpsertWithoutReservationsInput
    disconnect?: PatientWhereInput | boolean
    delete?: PatientWhereInput | boolean
    connect?: PatientWhereUniqueInput
    update?: XOR<XOR<PatientUpdateToOneWithWhereWithoutReservationsInput, PatientUpdateWithoutReservationsInput>, PatientUncheckedUpdateWithoutReservationsInput>
  }

  export type PaymentMethodUpdateOneRequiredWithoutReservationsNestedInput = {
    create?: XOR<PaymentMethodCreateWithoutReservationsInput, PaymentMethodUncheckedCreateWithoutReservationsInput>
    connectOrCreate?: PaymentMethodCreateOrConnectWithoutReservationsInput
    upsert?: PaymentMethodUpsertWithoutReservationsInput
    connect?: PaymentMethodWhereUniqueInput
    update?: XOR<XOR<PaymentMethodUpdateToOneWithWhereWithoutReservationsInput, PaymentMethodUpdateWithoutReservationsInput>, PaymentMethodUncheckedUpdateWithoutReservationsInput>
  }

  export type EmployeeUpdateOneWithoutReservationsNestedInput = {
    create?: XOR<EmployeeCreateWithoutReservationsInput, EmployeeUncheckedCreateWithoutReservationsInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutReservationsInput
    upsert?: EmployeeUpsertWithoutReservationsInput
    disconnect?: EmployeeWhereInput | boolean
    delete?: EmployeeWhereInput | boolean
    connect?: EmployeeWhereUniqueInput
    update?: XOR<XOR<EmployeeUpdateToOneWithWhereWithoutReservationsInput, EmployeeUpdateWithoutReservationsInput>, EmployeeUncheckedUpdateWithoutReservationsInput>
  }

  export type ReferralSourceUpdateOneWithoutReservationsNestedInput = {
    create?: XOR<ReferralSourceCreateWithoutReservationsInput, ReferralSourceUncheckedCreateWithoutReservationsInput>
    connectOrCreate?: ReferralSourceCreateOrConnectWithoutReservationsInput
    upsert?: ReferralSourceUpsertWithoutReservationsInput
    disconnect?: ReferralSourceWhereInput | boolean
    delete?: ReferralSourceWhereInput | boolean
    connect?: ReferralSourceWhereUniqueInput
    update?: XOR<XOR<ReferralSourceUpdateToOneWithWhereWithoutReservationsInput, ReferralSourceUpdateWithoutReservationsInput>, ReferralSourceUncheckedUpdateWithoutReservationsInput>
  }

  export type GenderCreateNestedOneWithoutPatientsInput = {
    create?: XOR<GenderCreateWithoutPatientsInput, GenderUncheckedCreateWithoutPatientsInput>
    connectOrCreate?: GenderCreateOrConnectWithoutPatientsInput
    connect?: GenderWhereUniqueInput
  }

  export type ReservationCreateNestedManyWithoutPatientInput = {
    create?: XOR<ReservationCreateWithoutPatientInput, ReservationUncheckedCreateWithoutPatientInput> | ReservationCreateWithoutPatientInput[] | ReservationUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: ReservationCreateOrConnectWithoutPatientInput | ReservationCreateOrConnectWithoutPatientInput[]
    createMany?: ReservationCreateManyPatientInputEnvelope
    connect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
  }

  export type ReservationUncheckedCreateNestedManyWithoutPatientInput = {
    create?: XOR<ReservationCreateWithoutPatientInput, ReservationUncheckedCreateWithoutPatientInput> | ReservationCreateWithoutPatientInput[] | ReservationUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: ReservationCreateOrConnectWithoutPatientInput | ReservationCreateOrConnectWithoutPatientInput[]
    createMany?: ReservationCreateManyPatientInputEnvelope
    connect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
  }

  export type GenderUpdateOneWithoutPatientsNestedInput = {
    create?: XOR<GenderCreateWithoutPatientsInput, GenderUncheckedCreateWithoutPatientsInput>
    connectOrCreate?: GenderCreateOrConnectWithoutPatientsInput
    upsert?: GenderUpsertWithoutPatientsInput
    disconnect?: GenderWhereInput | boolean
    delete?: GenderWhereInput | boolean
    connect?: GenderWhereUniqueInput
    update?: XOR<XOR<GenderUpdateToOneWithWhereWithoutPatientsInput, GenderUpdateWithoutPatientsInput>, GenderUncheckedUpdateWithoutPatientsInput>
  }

  export type ReservationUpdateManyWithoutPatientNestedInput = {
    create?: XOR<ReservationCreateWithoutPatientInput, ReservationUncheckedCreateWithoutPatientInput> | ReservationCreateWithoutPatientInput[] | ReservationUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: ReservationCreateOrConnectWithoutPatientInput | ReservationCreateOrConnectWithoutPatientInput[]
    upsert?: ReservationUpsertWithWhereUniqueWithoutPatientInput | ReservationUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: ReservationCreateManyPatientInputEnvelope
    set?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    disconnect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    delete?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    connect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    update?: ReservationUpdateWithWhereUniqueWithoutPatientInput | ReservationUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: ReservationUpdateManyWithWhereWithoutPatientInput | ReservationUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: ReservationScalarWhereInput | ReservationScalarWhereInput[]
  }

  export type ReservationUncheckedUpdateManyWithoutPatientNestedInput = {
    create?: XOR<ReservationCreateWithoutPatientInput, ReservationUncheckedCreateWithoutPatientInput> | ReservationCreateWithoutPatientInput[] | ReservationUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: ReservationCreateOrConnectWithoutPatientInput | ReservationCreateOrConnectWithoutPatientInput[]
    upsert?: ReservationUpsertWithWhereUniqueWithoutPatientInput | ReservationUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: ReservationCreateManyPatientInputEnvelope
    set?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    disconnect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    delete?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    connect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    update?: ReservationUpdateWithWhereUniqueWithoutPatientInput | ReservationUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: ReservationUpdateManyWithWhereWithoutPatientInput | ReservationUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: ReservationScalarWhereInput | ReservationScalarWhereInput[]
  }

  export type PatientCreateNestedManyWithoutGenderInput = {
    create?: XOR<PatientCreateWithoutGenderInput, PatientUncheckedCreateWithoutGenderInput> | PatientCreateWithoutGenderInput[] | PatientUncheckedCreateWithoutGenderInput[]
    connectOrCreate?: PatientCreateOrConnectWithoutGenderInput | PatientCreateOrConnectWithoutGenderInput[]
    createMany?: PatientCreateManyGenderInputEnvelope
    connect?: PatientWhereUniqueInput | PatientWhereUniqueInput[]
  }

  export type PatientUncheckedCreateNestedManyWithoutGenderInput = {
    create?: XOR<PatientCreateWithoutGenderInput, PatientUncheckedCreateWithoutGenderInput> | PatientCreateWithoutGenderInput[] | PatientUncheckedCreateWithoutGenderInput[]
    connectOrCreate?: PatientCreateOrConnectWithoutGenderInput | PatientCreateOrConnectWithoutGenderInput[]
    createMany?: PatientCreateManyGenderInputEnvelope
    connect?: PatientWhereUniqueInput | PatientWhereUniqueInput[]
  }

  export type PatientUpdateManyWithoutGenderNestedInput = {
    create?: XOR<PatientCreateWithoutGenderInput, PatientUncheckedCreateWithoutGenderInput> | PatientCreateWithoutGenderInput[] | PatientUncheckedCreateWithoutGenderInput[]
    connectOrCreate?: PatientCreateOrConnectWithoutGenderInput | PatientCreateOrConnectWithoutGenderInput[]
    upsert?: PatientUpsertWithWhereUniqueWithoutGenderInput | PatientUpsertWithWhereUniqueWithoutGenderInput[]
    createMany?: PatientCreateManyGenderInputEnvelope
    set?: PatientWhereUniqueInput | PatientWhereUniqueInput[]
    disconnect?: PatientWhereUniqueInput | PatientWhereUniqueInput[]
    delete?: PatientWhereUniqueInput | PatientWhereUniqueInput[]
    connect?: PatientWhereUniqueInput | PatientWhereUniqueInput[]
    update?: PatientUpdateWithWhereUniqueWithoutGenderInput | PatientUpdateWithWhereUniqueWithoutGenderInput[]
    updateMany?: PatientUpdateManyWithWhereWithoutGenderInput | PatientUpdateManyWithWhereWithoutGenderInput[]
    deleteMany?: PatientScalarWhereInput | PatientScalarWhereInput[]
  }

  export type PatientUncheckedUpdateManyWithoutGenderNestedInput = {
    create?: XOR<PatientCreateWithoutGenderInput, PatientUncheckedCreateWithoutGenderInput> | PatientCreateWithoutGenderInput[] | PatientUncheckedCreateWithoutGenderInput[]
    connectOrCreate?: PatientCreateOrConnectWithoutGenderInput | PatientCreateOrConnectWithoutGenderInput[]
    upsert?: PatientUpsertWithWhereUniqueWithoutGenderInput | PatientUpsertWithWhereUniqueWithoutGenderInput[]
    createMany?: PatientCreateManyGenderInputEnvelope
    set?: PatientWhereUniqueInput | PatientWhereUniqueInput[]
    disconnect?: PatientWhereUniqueInput | PatientWhereUniqueInput[]
    delete?: PatientWhereUniqueInput | PatientWhereUniqueInput[]
    connect?: PatientWhereUniqueInput | PatientWhereUniqueInput[]
    update?: PatientUpdateWithWhereUniqueWithoutGenderInput | PatientUpdateWithWhereUniqueWithoutGenderInput[]
    updateMany?: PatientUpdateManyWithWhereWithoutGenderInput | PatientUpdateManyWithWhereWithoutGenderInput[]
    deleteMany?: PatientScalarWhereInput | PatientScalarWhereInput[]
  }

  export type ReservationCreateNestedManyWithoutReferralSourceInput = {
    create?: XOR<ReservationCreateWithoutReferralSourceInput, ReservationUncheckedCreateWithoutReferralSourceInput> | ReservationCreateWithoutReferralSourceInput[] | ReservationUncheckedCreateWithoutReferralSourceInput[]
    connectOrCreate?: ReservationCreateOrConnectWithoutReferralSourceInput | ReservationCreateOrConnectWithoutReferralSourceInput[]
    createMany?: ReservationCreateManyReferralSourceInputEnvelope
    connect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
  }

  export type ReservationUncheckedCreateNestedManyWithoutReferralSourceInput = {
    create?: XOR<ReservationCreateWithoutReferralSourceInput, ReservationUncheckedCreateWithoutReferralSourceInput> | ReservationCreateWithoutReferralSourceInput[] | ReservationUncheckedCreateWithoutReferralSourceInput[]
    connectOrCreate?: ReservationCreateOrConnectWithoutReferralSourceInput | ReservationCreateOrConnectWithoutReferralSourceInput[]
    createMany?: ReservationCreateManyReferralSourceInputEnvelope
    connect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
  }

  export type ReservationUpdateManyWithoutReferralSourceNestedInput = {
    create?: XOR<ReservationCreateWithoutReferralSourceInput, ReservationUncheckedCreateWithoutReferralSourceInput> | ReservationCreateWithoutReferralSourceInput[] | ReservationUncheckedCreateWithoutReferralSourceInput[]
    connectOrCreate?: ReservationCreateOrConnectWithoutReferralSourceInput | ReservationCreateOrConnectWithoutReferralSourceInput[]
    upsert?: ReservationUpsertWithWhereUniqueWithoutReferralSourceInput | ReservationUpsertWithWhereUniqueWithoutReferralSourceInput[]
    createMany?: ReservationCreateManyReferralSourceInputEnvelope
    set?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    disconnect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    delete?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    connect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    update?: ReservationUpdateWithWhereUniqueWithoutReferralSourceInput | ReservationUpdateWithWhereUniqueWithoutReferralSourceInput[]
    updateMany?: ReservationUpdateManyWithWhereWithoutReferralSourceInput | ReservationUpdateManyWithWhereWithoutReferralSourceInput[]
    deleteMany?: ReservationScalarWhereInput | ReservationScalarWhereInput[]
  }

  export type ReservationUncheckedUpdateManyWithoutReferralSourceNestedInput = {
    create?: XOR<ReservationCreateWithoutReferralSourceInput, ReservationUncheckedCreateWithoutReferralSourceInput> | ReservationCreateWithoutReferralSourceInput[] | ReservationUncheckedCreateWithoutReferralSourceInput[]
    connectOrCreate?: ReservationCreateOrConnectWithoutReferralSourceInput | ReservationCreateOrConnectWithoutReferralSourceInput[]
    upsert?: ReservationUpsertWithWhereUniqueWithoutReferralSourceInput | ReservationUpsertWithWhereUniqueWithoutReferralSourceInput[]
    createMany?: ReservationCreateManyReferralSourceInputEnvelope
    set?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    disconnect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    delete?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    connect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    update?: ReservationUpdateWithWhereUniqueWithoutReferralSourceInput | ReservationUpdateWithWhereUniqueWithoutReferralSourceInput[]
    updateMany?: ReservationUpdateManyWithWhereWithoutReferralSourceInput | ReservationUpdateManyWithWhereWithoutReferralSourceInput[]
    deleteMany?: ReservationScalarWhereInput | ReservationScalarWhereInput[]
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type ReservationCreateWithoutPaymentMethodInput = {
    id: string
    isEnabled?: boolean
    queueNumber: number
    reservationNumber: string
    reservationDate: Date | string
    bpjsNumber?: string | null
    otherInsuranceNumber?: string | null
    createdAt?: Date | string
    referralNumber?: string | null
    notes?: string | null
    queueType: string
    isConfirmed?: boolean
    callStatus?: string
    isCancelled?: boolean
    cancelReason?: string | null
    educationId?: number | null
    type?: string | null
    patientType?: string | null
    unit: UnitCreateNestedOneWithoutReservationsInput
    patient?: PatientCreateNestedOneWithoutReservationsInput
    doctor?: EmployeeCreateNestedOneWithoutReservationsInput
    referralSource?: ReferralSourceCreateNestedOneWithoutReservationsInput
  }

  export type ReservationUncheckedCreateWithoutPaymentMethodInput = {
    id: string
    isEnabled?: boolean
    unitId: number
    identity: string
    queueNumber: number
    reservationNumber: string
    reservationDate: Date | string
    bpjsNumber?: string | null
    otherInsuranceNumber?: string | null
    createdAt?: Date | string
    referralNumber?: string | null
    doctorId?: number | null
    notes?: string | null
    queueType: string
    referralSourceId?: number | null
    isConfirmed?: boolean
    callStatus?: string
    isCancelled?: boolean
    cancelReason?: string | null
    educationId?: number | null
    type?: string | null
    patientType?: string | null
  }

  export type ReservationCreateOrConnectWithoutPaymentMethodInput = {
    where: ReservationWhereUniqueInput
    create: XOR<ReservationCreateWithoutPaymentMethodInput, ReservationUncheckedCreateWithoutPaymentMethodInput>
  }

  export type ReservationCreateManyPaymentMethodInputEnvelope = {
    data: ReservationCreateManyPaymentMethodInput | ReservationCreateManyPaymentMethodInput[]
    skipDuplicates?: boolean
  }

  export type ReservationUpsertWithWhereUniqueWithoutPaymentMethodInput = {
    where: ReservationWhereUniqueInput
    update: XOR<ReservationUpdateWithoutPaymentMethodInput, ReservationUncheckedUpdateWithoutPaymentMethodInput>
    create: XOR<ReservationCreateWithoutPaymentMethodInput, ReservationUncheckedCreateWithoutPaymentMethodInput>
  }

  export type ReservationUpdateWithWhereUniqueWithoutPaymentMethodInput = {
    where: ReservationWhereUniqueInput
    data: XOR<ReservationUpdateWithoutPaymentMethodInput, ReservationUncheckedUpdateWithoutPaymentMethodInput>
  }

  export type ReservationUpdateManyWithWhereWithoutPaymentMethodInput = {
    where: ReservationScalarWhereInput
    data: XOR<ReservationUpdateManyMutationInput, ReservationUncheckedUpdateManyWithoutPaymentMethodInput>
  }

  export type ReservationScalarWhereInput = {
    AND?: ReservationScalarWhereInput | ReservationScalarWhereInput[]
    OR?: ReservationScalarWhereInput[]
    NOT?: ReservationScalarWhereInput | ReservationScalarWhereInput[]
    id?: StringFilter<"Reservation"> | string
    isEnabled?: BoolFilter<"Reservation"> | boolean
    unitId?: IntFilter<"Reservation"> | number
    identity?: StringFilter<"Reservation"> | string
    queueNumber?: IntFilter<"Reservation"> | number
    reservationNumber?: StringFilter<"Reservation"> | string
    reservationDate?: DateTimeFilter<"Reservation"> | Date | string
    paymentMethodId?: IntFilter<"Reservation"> | number
    bpjsNumber?: StringNullableFilter<"Reservation"> | string | null
    otherInsuranceNumber?: StringNullableFilter<"Reservation"> | string | null
    createdAt?: DateTimeFilter<"Reservation"> | Date | string
    referralNumber?: StringNullableFilter<"Reservation"> | string | null
    doctorId?: IntNullableFilter<"Reservation"> | number | null
    notes?: StringNullableFilter<"Reservation"> | string | null
    queueType?: StringFilter<"Reservation"> | string
    referralSourceId?: IntNullableFilter<"Reservation"> | number | null
    isConfirmed?: BoolFilter<"Reservation"> | boolean
    callStatus?: StringFilter<"Reservation"> | string
    isCancelled?: BoolFilter<"Reservation"> | boolean
    cancelReason?: StringNullableFilter<"Reservation"> | string | null
    educationId?: IntNullableFilter<"Reservation"> | number | null
    type?: StringNullableFilter<"Reservation"> | string | null
    patientType?: StringNullableFilter<"Reservation"> | string | null
  }

  export type RoomCreateWithoutBedsInput = {
    id: number
    roomName: string
    isEnabled: boolean
    unit?: UnitCreateNestedOneWithoutRoomsInput
    class?: ClassCreateNestedOneWithoutRoomsInput
  }

  export type RoomUncheckedCreateWithoutBedsInput = {
    id: number
    roomName: string
    isEnabled: boolean
    unitId?: number | null
    classId?: number | null
  }

  export type RoomCreateOrConnectWithoutBedsInput = {
    where: RoomWhereUniqueInput
    create: XOR<RoomCreateWithoutBedsInput, RoomUncheckedCreateWithoutBedsInput>
  }

  export type BedStatusCreateWithoutBedsInput = {
    id: number
    status: string
    isEnabled: boolean
  }

  export type BedStatusUncheckedCreateWithoutBedsInput = {
    id: number
    status: string
    isEnabled: boolean
  }

  export type BedStatusCreateOrConnectWithoutBedsInput = {
    where: BedStatusWhereUniqueInput
    create: XOR<BedStatusCreateWithoutBedsInput, BedStatusUncheckedCreateWithoutBedsInput>
  }

  export type RoomUpsertWithoutBedsInput = {
    update: XOR<RoomUpdateWithoutBedsInput, RoomUncheckedUpdateWithoutBedsInput>
    create: XOR<RoomCreateWithoutBedsInput, RoomUncheckedCreateWithoutBedsInput>
    where?: RoomWhereInput
  }

  export type RoomUpdateToOneWithWhereWithoutBedsInput = {
    where?: RoomWhereInput
    data: XOR<RoomUpdateWithoutBedsInput, RoomUncheckedUpdateWithoutBedsInput>
  }

  export type RoomUpdateWithoutBedsInput = {
    id?: IntFieldUpdateOperationsInput | number
    roomName?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    unit?: UnitUpdateOneWithoutRoomsNestedInput
    class?: ClassUpdateOneWithoutRoomsNestedInput
  }

  export type RoomUncheckedUpdateWithoutBedsInput = {
    id?: IntFieldUpdateOperationsInput | number
    roomName?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    unitId?: NullableIntFieldUpdateOperationsInput | number | null
    classId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type BedStatusUpsertWithoutBedsInput = {
    update: XOR<BedStatusUpdateWithoutBedsInput, BedStatusUncheckedUpdateWithoutBedsInput>
    create: XOR<BedStatusCreateWithoutBedsInput, BedStatusUncheckedCreateWithoutBedsInput>
    where?: BedStatusWhereInput
  }

  export type BedStatusUpdateToOneWithWhereWithoutBedsInput = {
    where?: BedStatusWhereInput
    data: XOR<BedStatusUpdateWithoutBedsInput, BedStatusUncheckedUpdateWithoutBedsInput>
  }

  export type BedStatusUpdateWithoutBedsInput = {
    id?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
  }

  export type BedStatusUncheckedUpdateWithoutBedsInput = {
    id?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UnitCreateWithoutRoomsInput = {
    id: number
    unitName: string
    isEnabled: boolean
    department?: DepartmentCreateNestedOneWithoutUnitsInput
    stockDetails?: StockDetailCreateNestedManyWithoutUnitInput
    doctorSchedules?: DoctorScheduleCreateNestedManyWithoutUnitInput
    reservations?: ReservationCreateNestedManyWithoutUnitInput
  }

  export type UnitUncheckedCreateWithoutRoomsInput = {
    id: number
    unitName: string
    isEnabled: boolean
    departmentId?: number | null
    stockDetails?: StockDetailUncheckedCreateNestedManyWithoutUnitInput
    doctorSchedules?: DoctorScheduleUncheckedCreateNestedManyWithoutUnitInput
    reservations?: ReservationUncheckedCreateNestedManyWithoutUnitInput
  }

  export type UnitCreateOrConnectWithoutRoomsInput = {
    where: UnitWhereUniqueInput
    create: XOR<UnitCreateWithoutRoomsInput, UnitUncheckedCreateWithoutRoomsInput>
  }

  export type ClassCreateWithoutRoomsInput = {
    id: number
    className: string
    isEnabled: boolean
  }

  export type ClassUncheckedCreateWithoutRoomsInput = {
    id: number
    className: string
    isEnabled: boolean
  }

  export type ClassCreateOrConnectWithoutRoomsInput = {
    where: ClassWhereUniqueInput
    create: XOR<ClassCreateWithoutRoomsInput, ClassUncheckedCreateWithoutRoomsInput>
  }

  export type BedCreateWithoutRoomInput = {
    id: number
    displayName: string
    bedNumber: number
    isEnabled: boolean
    bedStatus?: BedStatusCreateNestedOneWithoutBedsInput
  }

  export type BedUncheckedCreateWithoutRoomInput = {
    id: number
    displayName: string
    bedNumber: number
    isEnabled: boolean
    bedStatusId?: number | null
  }

  export type BedCreateOrConnectWithoutRoomInput = {
    where: BedWhereUniqueInput
    create: XOR<BedCreateWithoutRoomInput, BedUncheckedCreateWithoutRoomInput>
  }

  export type BedCreateManyRoomInputEnvelope = {
    data: BedCreateManyRoomInput | BedCreateManyRoomInput[]
    skipDuplicates?: boolean
  }

  export type UnitUpsertWithoutRoomsInput = {
    update: XOR<UnitUpdateWithoutRoomsInput, UnitUncheckedUpdateWithoutRoomsInput>
    create: XOR<UnitCreateWithoutRoomsInput, UnitUncheckedCreateWithoutRoomsInput>
    where?: UnitWhereInput
  }

  export type UnitUpdateToOneWithWhereWithoutRoomsInput = {
    where?: UnitWhereInput
    data: XOR<UnitUpdateWithoutRoomsInput, UnitUncheckedUpdateWithoutRoomsInput>
  }

  export type UnitUpdateWithoutRoomsInput = {
    id?: IntFieldUpdateOperationsInput | number
    unitName?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    department?: DepartmentUpdateOneWithoutUnitsNestedInput
    stockDetails?: StockDetailUpdateManyWithoutUnitNestedInput
    doctorSchedules?: DoctorScheduleUpdateManyWithoutUnitNestedInput
    reservations?: ReservationUpdateManyWithoutUnitNestedInput
  }

  export type UnitUncheckedUpdateWithoutRoomsInput = {
    id?: IntFieldUpdateOperationsInput | number
    unitName?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    departmentId?: NullableIntFieldUpdateOperationsInput | number | null
    stockDetails?: StockDetailUncheckedUpdateManyWithoutUnitNestedInput
    doctorSchedules?: DoctorScheduleUncheckedUpdateManyWithoutUnitNestedInput
    reservations?: ReservationUncheckedUpdateManyWithoutUnitNestedInput
  }

  export type ClassUpsertWithoutRoomsInput = {
    update: XOR<ClassUpdateWithoutRoomsInput, ClassUncheckedUpdateWithoutRoomsInput>
    create: XOR<ClassCreateWithoutRoomsInput, ClassUncheckedCreateWithoutRoomsInput>
    where?: ClassWhereInput
  }

  export type ClassUpdateToOneWithWhereWithoutRoomsInput = {
    where?: ClassWhereInput
    data: XOR<ClassUpdateWithoutRoomsInput, ClassUncheckedUpdateWithoutRoomsInput>
  }

  export type ClassUpdateWithoutRoomsInput = {
    id?: IntFieldUpdateOperationsInput | number
    className?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ClassUncheckedUpdateWithoutRoomsInput = {
    id?: IntFieldUpdateOperationsInput | number
    className?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
  }

  export type BedUpsertWithWhereUniqueWithoutRoomInput = {
    where: BedWhereUniqueInput
    update: XOR<BedUpdateWithoutRoomInput, BedUncheckedUpdateWithoutRoomInput>
    create: XOR<BedCreateWithoutRoomInput, BedUncheckedCreateWithoutRoomInput>
  }

  export type BedUpdateWithWhereUniqueWithoutRoomInput = {
    where: BedWhereUniqueInput
    data: XOR<BedUpdateWithoutRoomInput, BedUncheckedUpdateWithoutRoomInput>
  }

  export type BedUpdateManyWithWhereWithoutRoomInput = {
    where: BedScalarWhereInput
    data: XOR<BedUpdateManyMutationInput, BedUncheckedUpdateManyWithoutRoomInput>
  }

  export type BedScalarWhereInput = {
    AND?: BedScalarWhereInput | BedScalarWhereInput[]
    OR?: BedScalarWhereInput[]
    NOT?: BedScalarWhereInput | BedScalarWhereInput[]
    id?: IntFilter<"Bed"> | number
    displayName?: StringFilter<"Bed"> | string
    bedNumber?: IntFilter<"Bed"> | number
    isEnabled?: BoolFilter<"Bed"> | boolean
    roomId?: IntNullableFilter<"Bed"> | number | null
    bedStatusId?: IntNullableFilter<"Bed"> | number | null
  }

  export type RoomCreateWithoutUnitInput = {
    id: number
    roomName: string
    isEnabled: boolean
    class?: ClassCreateNestedOneWithoutRoomsInput
    beds?: BedCreateNestedManyWithoutRoomInput
  }

  export type RoomUncheckedCreateWithoutUnitInput = {
    id: number
    roomName: string
    isEnabled: boolean
    classId?: number | null
    beds?: BedUncheckedCreateNestedManyWithoutRoomInput
  }

  export type RoomCreateOrConnectWithoutUnitInput = {
    where: RoomWhereUniqueInput
    create: XOR<RoomCreateWithoutUnitInput, RoomUncheckedCreateWithoutUnitInput>
  }

  export type RoomCreateManyUnitInputEnvelope = {
    data: RoomCreateManyUnitInput | RoomCreateManyUnitInput[]
    skipDuplicates?: boolean
  }

  export type DepartmentCreateWithoutUnitsInput = {
    id: number
    departmentName: string
    isEnabled: boolean
  }

  export type DepartmentUncheckedCreateWithoutUnitsInput = {
    id: number
    departmentName: string
    isEnabled: boolean
  }

  export type DepartmentCreateOrConnectWithoutUnitsInput = {
    where: DepartmentWhereUniqueInput
    create: XOR<DepartmentCreateWithoutUnitsInput, DepartmentUncheckedCreateWithoutUnitsInput>
  }

  export type StockDetailCreateWithoutUnitInput = {
    id: string
    sourceProductId?: number | null
    netPrice?: number | null
    discountPrice?: number | null
    quantity: number
    isEnabled: boolean
    expiredAt?: Date | string | null
    product: ProductCreateNestedOneWithoutStockDetailsInput
    receipt: ServiceReceiptCreateNestedOneWithoutStockDetailsInput
  }

  export type StockDetailUncheckedCreateWithoutUnitInput = {
    id: string
    productId: number
    receiptId: string
    sourceProductId?: number | null
    netPrice?: number | null
    discountPrice?: number | null
    quantity: number
    isEnabled: boolean
    expiredAt?: Date | string | null
  }

  export type StockDetailCreateOrConnectWithoutUnitInput = {
    where: StockDetailWhereUniqueInput
    create: XOR<StockDetailCreateWithoutUnitInput, StockDetailUncheckedCreateWithoutUnitInput>
  }

  export type StockDetailCreateManyUnitInputEnvelope = {
    data: StockDetailCreateManyUnitInput | StockDetailCreateManyUnitInput[]
    skipDuplicates?: boolean
  }

  export type DoctorScheduleCreateWithoutUnitInput = {
    id: number
    startTime: Date | string
    endTime: Date | string
    note?: string | null
    days: string
    quota: number
    isEnabled: boolean
    doctor: EmployeeCreateNestedOneWithoutDoctorSchedulesInput
  }

  export type DoctorScheduleUncheckedCreateWithoutUnitInput = {
    id: number
    doctorId: number
    startTime: Date | string
    endTime: Date | string
    note?: string | null
    days: string
    quota: number
    isEnabled: boolean
  }

  export type DoctorScheduleCreateOrConnectWithoutUnitInput = {
    where: DoctorScheduleWhereUniqueInput
    create: XOR<DoctorScheduleCreateWithoutUnitInput, DoctorScheduleUncheckedCreateWithoutUnitInput>
  }

  export type DoctorScheduleCreateManyUnitInputEnvelope = {
    data: DoctorScheduleCreateManyUnitInput | DoctorScheduleCreateManyUnitInput[]
    skipDuplicates?: boolean
  }

  export type ReservationCreateWithoutUnitInput = {
    id: string
    isEnabled?: boolean
    queueNumber: number
    reservationNumber: string
    reservationDate: Date | string
    bpjsNumber?: string | null
    otherInsuranceNumber?: string | null
    createdAt?: Date | string
    referralNumber?: string | null
    notes?: string | null
    queueType: string
    isConfirmed?: boolean
    callStatus?: string
    isCancelled?: boolean
    cancelReason?: string | null
    educationId?: number | null
    type?: string | null
    patientType?: string | null
    patient?: PatientCreateNestedOneWithoutReservationsInput
    paymentMethod: PaymentMethodCreateNestedOneWithoutReservationsInput
    doctor?: EmployeeCreateNestedOneWithoutReservationsInput
    referralSource?: ReferralSourceCreateNestedOneWithoutReservationsInput
  }

  export type ReservationUncheckedCreateWithoutUnitInput = {
    id: string
    isEnabled?: boolean
    identity: string
    queueNumber: number
    reservationNumber: string
    reservationDate: Date | string
    paymentMethodId: number
    bpjsNumber?: string | null
    otherInsuranceNumber?: string | null
    createdAt?: Date | string
    referralNumber?: string | null
    doctorId?: number | null
    notes?: string | null
    queueType: string
    referralSourceId?: number | null
    isConfirmed?: boolean
    callStatus?: string
    isCancelled?: boolean
    cancelReason?: string | null
    educationId?: number | null
    type?: string | null
    patientType?: string | null
  }

  export type ReservationCreateOrConnectWithoutUnitInput = {
    where: ReservationWhereUniqueInput
    create: XOR<ReservationCreateWithoutUnitInput, ReservationUncheckedCreateWithoutUnitInput>
  }

  export type ReservationCreateManyUnitInputEnvelope = {
    data: ReservationCreateManyUnitInput | ReservationCreateManyUnitInput[]
    skipDuplicates?: boolean
  }

  export type RoomUpsertWithWhereUniqueWithoutUnitInput = {
    where: RoomWhereUniqueInput
    update: XOR<RoomUpdateWithoutUnitInput, RoomUncheckedUpdateWithoutUnitInput>
    create: XOR<RoomCreateWithoutUnitInput, RoomUncheckedCreateWithoutUnitInput>
  }

  export type RoomUpdateWithWhereUniqueWithoutUnitInput = {
    where: RoomWhereUniqueInput
    data: XOR<RoomUpdateWithoutUnitInput, RoomUncheckedUpdateWithoutUnitInput>
  }

  export type RoomUpdateManyWithWhereWithoutUnitInput = {
    where: RoomScalarWhereInput
    data: XOR<RoomUpdateManyMutationInput, RoomUncheckedUpdateManyWithoutUnitInput>
  }

  export type RoomScalarWhereInput = {
    AND?: RoomScalarWhereInput | RoomScalarWhereInput[]
    OR?: RoomScalarWhereInput[]
    NOT?: RoomScalarWhereInput | RoomScalarWhereInput[]
    id?: IntFilter<"Room"> | number
    roomName?: StringFilter<"Room"> | string
    isEnabled?: BoolFilter<"Room"> | boolean
    unitId?: IntNullableFilter<"Room"> | number | null
    classId?: IntNullableFilter<"Room"> | number | null
  }

  export type DepartmentUpsertWithoutUnitsInput = {
    update: XOR<DepartmentUpdateWithoutUnitsInput, DepartmentUncheckedUpdateWithoutUnitsInput>
    create: XOR<DepartmentCreateWithoutUnitsInput, DepartmentUncheckedCreateWithoutUnitsInput>
    where?: DepartmentWhereInput
  }

  export type DepartmentUpdateToOneWithWhereWithoutUnitsInput = {
    where?: DepartmentWhereInput
    data: XOR<DepartmentUpdateWithoutUnitsInput, DepartmentUncheckedUpdateWithoutUnitsInput>
  }

  export type DepartmentUpdateWithoutUnitsInput = {
    id?: IntFieldUpdateOperationsInput | number
    departmentName?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
  }

  export type DepartmentUncheckedUpdateWithoutUnitsInput = {
    id?: IntFieldUpdateOperationsInput | number
    departmentName?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
  }

  export type StockDetailUpsertWithWhereUniqueWithoutUnitInput = {
    where: StockDetailWhereUniqueInput
    update: XOR<StockDetailUpdateWithoutUnitInput, StockDetailUncheckedUpdateWithoutUnitInput>
    create: XOR<StockDetailCreateWithoutUnitInput, StockDetailUncheckedCreateWithoutUnitInput>
  }

  export type StockDetailUpdateWithWhereUniqueWithoutUnitInput = {
    where: StockDetailWhereUniqueInput
    data: XOR<StockDetailUpdateWithoutUnitInput, StockDetailUncheckedUpdateWithoutUnitInput>
  }

  export type StockDetailUpdateManyWithWhereWithoutUnitInput = {
    where: StockDetailScalarWhereInput
    data: XOR<StockDetailUpdateManyMutationInput, StockDetailUncheckedUpdateManyWithoutUnitInput>
  }

  export type StockDetailScalarWhereInput = {
    AND?: StockDetailScalarWhereInput | StockDetailScalarWhereInput[]
    OR?: StockDetailScalarWhereInput[]
    NOT?: StockDetailScalarWhereInput | StockDetailScalarWhereInput[]
    id?: StringFilter<"StockDetail"> | string
    productId?: IntFilter<"StockDetail"> | number
    unitId?: IntFilter<"StockDetail"> | number
    receiptId?: StringFilter<"StockDetail"> | string
    sourceProductId?: IntNullableFilter<"StockDetail"> | number | null
    netPrice?: FloatNullableFilter<"StockDetail"> | number | null
    discountPrice?: FloatNullableFilter<"StockDetail"> | number | null
    quantity?: FloatFilter<"StockDetail"> | number
    isEnabled?: BoolFilter<"StockDetail"> | boolean
    expiredAt?: DateTimeNullableFilter<"StockDetail"> | Date | string | null
  }

  export type DoctorScheduleUpsertWithWhereUniqueWithoutUnitInput = {
    where: DoctorScheduleWhereUniqueInput
    update: XOR<DoctorScheduleUpdateWithoutUnitInput, DoctorScheduleUncheckedUpdateWithoutUnitInput>
    create: XOR<DoctorScheduleCreateWithoutUnitInput, DoctorScheduleUncheckedCreateWithoutUnitInput>
  }

  export type DoctorScheduleUpdateWithWhereUniqueWithoutUnitInput = {
    where: DoctorScheduleWhereUniqueInput
    data: XOR<DoctorScheduleUpdateWithoutUnitInput, DoctorScheduleUncheckedUpdateWithoutUnitInput>
  }

  export type DoctorScheduleUpdateManyWithWhereWithoutUnitInput = {
    where: DoctorScheduleScalarWhereInput
    data: XOR<DoctorScheduleUpdateManyMutationInput, DoctorScheduleUncheckedUpdateManyWithoutUnitInput>
  }

  export type DoctorScheduleScalarWhereInput = {
    AND?: DoctorScheduleScalarWhereInput | DoctorScheduleScalarWhereInput[]
    OR?: DoctorScheduleScalarWhereInput[]
    NOT?: DoctorScheduleScalarWhereInput | DoctorScheduleScalarWhereInput[]
    id?: IntFilter<"DoctorSchedule"> | number
    unitId?: IntFilter<"DoctorSchedule"> | number
    doctorId?: IntFilter<"DoctorSchedule"> | number
    startTime?: DateTimeFilter<"DoctorSchedule"> | Date | string
    endTime?: DateTimeFilter<"DoctorSchedule"> | Date | string
    note?: StringNullableFilter<"DoctorSchedule"> | string | null
    days?: StringFilter<"DoctorSchedule"> | string
    quota?: IntFilter<"DoctorSchedule"> | number
    isEnabled?: BoolFilter<"DoctorSchedule"> | boolean
  }

  export type ReservationUpsertWithWhereUniqueWithoutUnitInput = {
    where: ReservationWhereUniqueInput
    update: XOR<ReservationUpdateWithoutUnitInput, ReservationUncheckedUpdateWithoutUnitInput>
    create: XOR<ReservationCreateWithoutUnitInput, ReservationUncheckedCreateWithoutUnitInput>
  }

  export type ReservationUpdateWithWhereUniqueWithoutUnitInput = {
    where: ReservationWhereUniqueInput
    data: XOR<ReservationUpdateWithoutUnitInput, ReservationUncheckedUpdateWithoutUnitInput>
  }

  export type ReservationUpdateManyWithWhereWithoutUnitInput = {
    where: ReservationScalarWhereInput
    data: XOR<ReservationUpdateManyMutationInput, ReservationUncheckedUpdateManyWithoutUnitInput>
  }

  export type BedCreateWithoutBedStatusInput = {
    id: number
    displayName: string
    bedNumber: number
    isEnabled: boolean
    room?: RoomCreateNestedOneWithoutBedsInput
  }

  export type BedUncheckedCreateWithoutBedStatusInput = {
    id: number
    displayName: string
    bedNumber: number
    isEnabled: boolean
    roomId?: number | null
  }

  export type BedCreateOrConnectWithoutBedStatusInput = {
    where: BedWhereUniqueInput
    create: XOR<BedCreateWithoutBedStatusInput, BedUncheckedCreateWithoutBedStatusInput>
  }

  export type BedCreateManyBedStatusInputEnvelope = {
    data: BedCreateManyBedStatusInput | BedCreateManyBedStatusInput[]
    skipDuplicates?: boolean
  }

  export type BedUpsertWithWhereUniqueWithoutBedStatusInput = {
    where: BedWhereUniqueInput
    update: XOR<BedUpdateWithoutBedStatusInput, BedUncheckedUpdateWithoutBedStatusInput>
    create: XOR<BedCreateWithoutBedStatusInput, BedUncheckedCreateWithoutBedStatusInput>
  }

  export type BedUpdateWithWhereUniqueWithoutBedStatusInput = {
    where: BedWhereUniqueInput
    data: XOR<BedUpdateWithoutBedStatusInput, BedUncheckedUpdateWithoutBedStatusInput>
  }

  export type BedUpdateManyWithWhereWithoutBedStatusInput = {
    where: BedScalarWhereInput
    data: XOR<BedUpdateManyMutationInput, BedUncheckedUpdateManyWithoutBedStatusInput>
  }

  export type RoomCreateWithoutClassInput = {
    id: number
    roomName: string
    isEnabled: boolean
    unit?: UnitCreateNestedOneWithoutRoomsInput
    beds?: BedCreateNestedManyWithoutRoomInput
  }

  export type RoomUncheckedCreateWithoutClassInput = {
    id: number
    roomName: string
    isEnabled: boolean
    unitId?: number | null
    beds?: BedUncheckedCreateNestedManyWithoutRoomInput
  }

  export type RoomCreateOrConnectWithoutClassInput = {
    where: RoomWhereUniqueInput
    create: XOR<RoomCreateWithoutClassInput, RoomUncheckedCreateWithoutClassInput>
  }

  export type RoomCreateManyClassInputEnvelope = {
    data: RoomCreateManyClassInput | RoomCreateManyClassInput[]
    skipDuplicates?: boolean
  }

  export type RoomUpsertWithWhereUniqueWithoutClassInput = {
    where: RoomWhereUniqueInput
    update: XOR<RoomUpdateWithoutClassInput, RoomUncheckedUpdateWithoutClassInput>
    create: XOR<RoomCreateWithoutClassInput, RoomUncheckedCreateWithoutClassInput>
  }

  export type RoomUpdateWithWhereUniqueWithoutClassInput = {
    where: RoomWhereUniqueInput
    data: XOR<RoomUpdateWithoutClassInput, RoomUncheckedUpdateWithoutClassInput>
  }

  export type RoomUpdateManyWithWhereWithoutClassInput = {
    where: RoomScalarWhereInput
    data: XOR<RoomUpdateManyMutationInput, RoomUncheckedUpdateManyWithoutClassInput>
  }

  export type UnitCreateWithoutDepartmentInput = {
    id: number
    unitName: string
    isEnabled: boolean
    rooms?: RoomCreateNestedManyWithoutUnitInput
    stockDetails?: StockDetailCreateNestedManyWithoutUnitInput
    doctorSchedules?: DoctorScheduleCreateNestedManyWithoutUnitInput
    reservations?: ReservationCreateNestedManyWithoutUnitInput
  }

  export type UnitUncheckedCreateWithoutDepartmentInput = {
    id: number
    unitName: string
    isEnabled: boolean
    rooms?: RoomUncheckedCreateNestedManyWithoutUnitInput
    stockDetails?: StockDetailUncheckedCreateNestedManyWithoutUnitInput
    doctorSchedules?: DoctorScheduleUncheckedCreateNestedManyWithoutUnitInput
    reservations?: ReservationUncheckedCreateNestedManyWithoutUnitInput
  }

  export type UnitCreateOrConnectWithoutDepartmentInput = {
    where: UnitWhereUniqueInput
    create: XOR<UnitCreateWithoutDepartmentInput, UnitUncheckedCreateWithoutDepartmentInput>
  }

  export type UnitCreateManyDepartmentInputEnvelope = {
    data: UnitCreateManyDepartmentInput | UnitCreateManyDepartmentInput[]
    skipDuplicates?: boolean
  }

  export type UnitUpsertWithWhereUniqueWithoutDepartmentInput = {
    where: UnitWhereUniqueInput
    update: XOR<UnitUpdateWithoutDepartmentInput, UnitUncheckedUpdateWithoutDepartmentInput>
    create: XOR<UnitCreateWithoutDepartmentInput, UnitUncheckedCreateWithoutDepartmentInput>
  }

  export type UnitUpdateWithWhereUniqueWithoutDepartmentInput = {
    where: UnitWhereUniqueInput
    data: XOR<UnitUpdateWithoutDepartmentInput, UnitUncheckedUpdateWithoutDepartmentInput>
  }

  export type UnitUpdateManyWithWhereWithoutDepartmentInput = {
    where: UnitScalarWhereInput
    data: XOR<UnitUpdateManyMutationInput, UnitUncheckedUpdateManyWithoutDepartmentInput>
  }

  export type UnitScalarWhereInput = {
    AND?: UnitScalarWhereInput | UnitScalarWhereInput[]
    OR?: UnitScalarWhereInput[]
    NOT?: UnitScalarWhereInput | UnitScalarWhereInput[]
    id?: IntFilter<"Unit"> | number
    unitName?: StringFilter<"Unit"> | string
    isEnabled?: BoolFilter<"Unit"> | boolean
    departmentId?: IntNullableFilter<"Unit"> | number | null
  }

  export type StockDetailCreateWithoutProductInput = {
    id: string
    sourceProductId?: number | null
    netPrice?: number | null
    discountPrice?: number | null
    quantity: number
    isEnabled: boolean
    expiredAt?: Date | string | null
    unit: UnitCreateNestedOneWithoutStockDetailsInput
    receipt: ServiceReceiptCreateNestedOneWithoutStockDetailsInput
  }

  export type StockDetailUncheckedCreateWithoutProductInput = {
    id: string
    unitId: number
    receiptId: string
    sourceProductId?: number | null
    netPrice?: number | null
    discountPrice?: number | null
    quantity: number
    isEnabled: boolean
    expiredAt?: Date | string | null
  }

  export type StockDetailCreateOrConnectWithoutProductInput = {
    where: StockDetailWhereUniqueInput
    create: XOR<StockDetailCreateWithoutProductInput, StockDetailUncheckedCreateWithoutProductInput>
  }

  export type StockDetailCreateManyProductInputEnvelope = {
    data: StockDetailCreateManyProductInput | StockDetailCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type StockDetailUpsertWithWhereUniqueWithoutProductInput = {
    where: StockDetailWhereUniqueInput
    update: XOR<StockDetailUpdateWithoutProductInput, StockDetailUncheckedUpdateWithoutProductInput>
    create: XOR<StockDetailCreateWithoutProductInput, StockDetailUncheckedCreateWithoutProductInput>
  }

  export type StockDetailUpdateWithWhereUniqueWithoutProductInput = {
    where: StockDetailWhereUniqueInput
    data: XOR<StockDetailUpdateWithoutProductInput, StockDetailUncheckedUpdateWithoutProductInput>
  }

  export type StockDetailUpdateManyWithWhereWithoutProductInput = {
    where: StockDetailScalarWhereInput
    data: XOR<StockDetailUpdateManyMutationInput, StockDetailUncheckedUpdateManyWithoutProductInput>
  }

  export type StockDetailCreateWithoutReceiptInput = {
    id: string
    sourceProductId?: number | null
    netPrice?: number | null
    discountPrice?: number | null
    quantity: number
    isEnabled: boolean
    expiredAt?: Date | string | null
    product: ProductCreateNestedOneWithoutStockDetailsInput
    unit: UnitCreateNestedOneWithoutStockDetailsInput
  }

  export type StockDetailUncheckedCreateWithoutReceiptInput = {
    id: string
    productId: number
    unitId: number
    sourceProductId?: number | null
    netPrice?: number | null
    discountPrice?: number | null
    quantity: number
    isEnabled: boolean
    expiredAt?: Date | string | null
  }

  export type StockDetailCreateOrConnectWithoutReceiptInput = {
    where: StockDetailWhereUniqueInput
    create: XOR<StockDetailCreateWithoutReceiptInput, StockDetailUncheckedCreateWithoutReceiptInput>
  }

  export type StockDetailCreateManyReceiptInputEnvelope = {
    data: StockDetailCreateManyReceiptInput | StockDetailCreateManyReceiptInput[]
    skipDuplicates?: boolean
  }

  export type StockDetailUpsertWithWhereUniqueWithoutReceiptInput = {
    where: StockDetailWhereUniqueInput
    update: XOR<StockDetailUpdateWithoutReceiptInput, StockDetailUncheckedUpdateWithoutReceiptInput>
    create: XOR<StockDetailCreateWithoutReceiptInput, StockDetailUncheckedCreateWithoutReceiptInput>
  }

  export type StockDetailUpdateWithWhereUniqueWithoutReceiptInput = {
    where: StockDetailWhereUniqueInput
    data: XOR<StockDetailUpdateWithoutReceiptInput, StockDetailUncheckedUpdateWithoutReceiptInput>
  }

  export type StockDetailUpdateManyWithWhereWithoutReceiptInput = {
    where: StockDetailScalarWhereInput
    data: XOR<StockDetailUpdateManyMutationInput, StockDetailUncheckedUpdateManyWithoutReceiptInput>
  }

  export type ProductCreateWithoutStockDetailsInput = {
    id: number
    productName: string
    isEnabled?: boolean
  }

  export type ProductUncheckedCreateWithoutStockDetailsInput = {
    id: number
    productName: string
    isEnabled?: boolean
  }

  export type ProductCreateOrConnectWithoutStockDetailsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutStockDetailsInput, ProductUncheckedCreateWithoutStockDetailsInput>
  }

  export type UnitCreateWithoutStockDetailsInput = {
    id: number
    unitName: string
    isEnabled: boolean
    rooms?: RoomCreateNestedManyWithoutUnitInput
    department?: DepartmentCreateNestedOneWithoutUnitsInput
    doctorSchedules?: DoctorScheduleCreateNestedManyWithoutUnitInput
    reservations?: ReservationCreateNestedManyWithoutUnitInput
  }

  export type UnitUncheckedCreateWithoutStockDetailsInput = {
    id: number
    unitName: string
    isEnabled: boolean
    departmentId?: number | null
    rooms?: RoomUncheckedCreateNestedManyWithoutUnitInput
    doctorSchedules?: DoctorScheduleUncheckedCreateNestedManyWithoutUnitInput
    reservations?: ReservationUncheckedCreateNestedManyWithoutUnitInput
  }

  export type UnitCreateOrConnectWithoutStockDetailsInput = {
    where: UnitWhereUniqueInput
    create: XOR<UnitCreateWithoutStockDetailsInput, UnitUncheckedCreateWithoutStockDetailsInput>
  }

  export type ServiceReceiptCreateWithoutStockDetailsInput = {
    id: string
    receiptAt: Date | string
  }

  export type ServiceReceiptUncheckedCreateWithoutStockDetailsInput = {
    id: string
    receiptAt: Date | string
  }

  export type ServiceReceiptCreateOrConnectWithoutStockDetailsInput = {
    where: ServiceReceiptWhereUniqueInput
    create: XOR<ServiceReceiptCreateWithoutStockDetailsInput, ServiceReceiptUncheckedCreateWithoutStockDetailsInput>
  }

  export type ProductUpsertWithoutStockDetailsInput = {
    update: XOR<ProductUpdateWithoutStockDetailsInput, ProductUncheckedUpdateWithoutStockDetailsInput>
    create: XOR<ProductCreateWithoutStockDetailsInput, ProductUncheckedCreateWithoutStockDetailsInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutStockDetailsInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutStockDetailsInput, ProductUncheckedUpdateWithoutStockDetailsInput>
  }

  export type ProductUpdateWithoutStockDetailsInput = {
    id?: IntFieldUpdateOperationsInput | number
    productName?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ProductUncheckedUpdateWithoutStockDetailsInput = {
    id?: IntFieldUpdateOperationsInput | number
    productName?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UnitUpsertWithoutStockDetailsInput = {
    update: XOR<UnitUpdateWithoutStockDetailsInput, UnitUncheckedUpdateWithoutStockDetailsInput>
    create: XOR<UnitCreateWithoutStockDetailsInput, UnitUncheckedCreateWithoutStockDetailsInput>
    where?: UnitWhereInput
  }

  export type UnitUpdateToOneWithWhereWithoutStockDetailsInput = {
    where?: UnitWhereInput
    data: XOR<UnitUpdateWithoutStockDetailsInput, UnitUncheckedUpdateWithoutStockDetailsInput>
  }

  export type UnitUpdateWithoutStockDetailsInput = {
    id?: IntFieldUpdateOperationsInput | number
    unitName?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    rooms?: RoomUpdateManyWithoutUnitNestedInput
    department?: DepartmentUpdateOneWithoutUnitsNestedInput
    doctorSchedules?: DoctorScheduleUpdateManyWithoutUnitNestedInput
    reservations?: ReservationUpdateManyWithoutUnitNestedInput
  }

  export type UnitUncheckedUpdateWithoutStockDetailsInput = {
    id?: IntFieldUpdateOperationsInput | number
    unitName?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    departmentId?: NullableIntFieldUpdateOperationsInput | number | null
    rooms?: RoomUncheckedUpdateManyWithoutUnitNestedInput
    doctorSchedules?: DoctorScheduleUncheckedUpdateManyWithoutUnitNestedInput
    reservations?: ReservationUncheckedUpdateManyWithoutUnitNestedInput
  }

  export type ServiceReceiptUpsertWithoutStockDetailsInput = {
    update: XOR<ServiceReceiptUpdateWithoutStockDetailsInput, ServiceReceiptUncheckedUpdateWithoutStockDetailsInput>
    create: XOR<ServiceReceiptCreateWithoutStockDetailsInput, ServiceReceiptUncheckedCreateWithoutStockDetailsInput>
    where?: ServiceReceiptWhereInput
  }

  export type ServiceReceiptUpdateToOneWithWhereWithoutStockDetailsInput = {
    where?: ServiceReceiptWhereInput
    data: XOR<ServiceReceiptUpdateWithoutStockDetailsInput, ServiceReceiptUncheckedUpdateWithoutStockDetailsInput>
  }

  export type ServiceReceiptUpdateWithoutStockDetailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    receiptAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceReceiptUncheckedUpdateWithoutStockDetailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    receiptAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UnitCreateWithoutDoctorSchedulesInput = {
    id: number
    unitName: string
    isEnabled: boolean
    rooms?: RoomCreateNestedManyWithoutUnitInput
    department?: DepartmentCreateNestedOneWithoutUnitsInput
    stockDetails?: StockDetailCreateNestedManyWithoutUnitInput
    reservations?: ReservationCreateNestedManyWithoutUnitInput
  }

  export type UnitUncheckedCreateWithoutDoctorSchedulesInput = {
    id: number
    unitName: string
    isEnabled: boolean
    departmentId?: number | null
    rooms?: RoomUncheckedCreateNestedManyWithoutUnitInput
    stockDetails?: StockDetailUncheckedCreateNestedManyWithoutUnitInput
    reservations?: ReservationUncheckedCreateNestedManyWithoutUnitInput
  }

  export type UnitCreateOrConnectWithoutDoctorSchedulesInput = {
    where: UnitWhereUniqueInput
    create: XOR<UnitCreateWithoutDoctorSchedulesInput, UnitUncheckedCreateWithoutDoctorSchedulesInput>
  }

  export type EmployeeCreateWithoutDoctorSchedulesInput = {
    id: number
    fullName: string
    identityNo?: string | null
    isEnabled: boolean
    reservations?: ReservationCreateNestedManyWithoutDoctorInput
  }

  export type EmployeeUncheckedCreateWithoutDoctorSchedulesInput = {
    id: number
    fullName: string
    identityNo?: string | null
    isEnabled: boolean
    reservations?: ReservationUncheckedCreateNestedManyWithoutDoctorInput
  }

  export type EmployeeCreateOrConnectWithoutDoctorSchedulesInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutDoctorSchedulesInput, EmployeeUncheckedCreateWithoutDoctorSchedulesInput>
  }

  export type UnitUpsertWithoutDoctorSchedulesInput = {
    update: XOR<UnitUpdateWithoutDoctorSchedulesInput, UnitUncheckedUpdateWithoutDoctorSchedulesInput>
    create: XOR<UnitCreateWithoutDoctorSchedulesInput, UnitUncheckedCreateWithoutDoctorSchedulesInput>
    where?: UnitWhereInput
  }

  export type UnitUpdateToOneWithWhereWithoutDoctorSchedulesInput = {
    where?: UnitWhereInput
    data: XOR<UnitUpdateWithoutDoctorSchedulesInput, UnitUncheckedUpdateWithoutDoctorSchedulesInput>
  }

  export type UnitUpdateWithoutDoctorSchedulesInput = {
    id?: IntFieldUpdateOperationsInput | number
    unitName?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    rooms?: RoomUpdateManyWithoutUnitNestedInput
    department?: DepartmentUpdateOneWithoutUnitsNestedInput
    stockDetails?: StockDetailUpdateManyWithoutUnitNestedInput
    reservations?: ReservationUpdateManyWithoutUnitNestedInput
  }

  export type UnitUncheckedUpdateWithoutDoctorSchedulesInput = {
    id?: IntFieldUpdateOperationsInput | number
    unitName?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    departmentId?: NullableIntFieldUpdateOperationsInput | number | null
    rooms?: RoomUncheckedUpdateManyWithoutUnitNestedInput
    stockDetails?: StockDetailUncheckedUpdateManyWithoutUnitNestedInput
    reservations?: ReservationUncheckedUpdateManyWithoutUnitNestedInput
  }

  export type EmployeeUpsertWithoutDoctorSchedulesInput = {
    update: XOR<EmployeeUpdateWithoutDoctorSchedulesInput, EmployeeUncheckedUpdateWithoutDoctorSchedulesInput>
    create: XOR<EmployeeCreateWithoutDoctorSchedulesInput, EmployeeUncheckedCreateWithoutDoctorSchedulesInput>
    where?: EmployeeWhereInput
  }

  export type EmployeeUpdateToOneWithWhereWithoutDoctorSchedulesInput = {
    where?: EmployeeWhereInput
    data: XOR<EmployeeUpdateWithoutDoctorSchedulesInput, EmployeeUncheckedUpdateWithoutDoctorSchedulesInput>
  }

  export type EmployeeUpdateWithoutDoctorSchedulesInput = {
    id?: IntFieldUpdateOperationsInput | number
    fullName?: StringFieldUpdateOperationsInput | string
    identityNo?: NullableStringFieldUpdateOperationsInput | string | null
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    reservations?: ReservationUpdateManyWithoutDoctorNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutDoctorSchedulesInput = {
    id?: IntFieldUpdateOperationsInput | number
    fullName?: StringFieldUpdateOperationsInput | string
    identityNo?: NullableStringFieldUpdateOperationsInput | string | null
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    reservations?: ReservationUncheckedUpdateManyWithoutDoctorNestedInput
  }

  export type DoctorScheduleCreateWithoutDoctorInput = {
    id: number
    startTime: Date | string
    endTime: Date | string
    note?: string | null
    days: string
    quota: number
    isEnabled: boolean
    unit: UnitCreateNestedOneWithoutDoctorSchedulesInput
  }

  export type DoctorScheduleUncheckedCreateWithoutDoctorInput = {
    id: number
    unitId: number
    startTime: Date | string
    endTime: Date | string
    note?: string | null
    days: string
    quota: number
    isEnabled: boolean
  }

  export type DoctorScheduleCreateOrConnectWithoutDoctorInput = {
    where: DoctorScheduleWhereUniqueInput
    create: XOR<DoctorScheduleCreateWithoutDoctorInput, DoctorScheduleUncheckedCreateWithoutDoctorInput>
  }

  export type DoctorScheduleCreateManyDoctorInputEnvelope = {
    data: DoctorScheduleCreateManyDoctorInput | DoctorScheduleCreateManyDoctorInput[]
    skipDuplicates?: boolean
  }

  export type ReservationCreateWithoutDoctorInput = {
    id: string
    isEnabled?: boolean
    queueNumber: number
    reservationNumber: string
    reservationDate: Date | string
    bpjsNumber?: string | null
    otherInsuranceNumber?: string | null
    createdAt?: Date | string
    referralNumber?: string | null
    notes?: string | null
    queueType: string
    isConfirmed?: boolean
    callStatus?: string
    isCancelled?: boolean
    cancelReason?: string | null
    educationId?: number | null
    type?: string | null
    patientType?: string | null
    unit: UnitCreateNestedOneWithoutReservationsInput
    patient?: PatientCreateNestedOneWithoutReservationsInput
    paymentMethod: PaymentMethodCreateNestedOneWithoutReservationsInput
    referralSource?: ReferralSourceCreateNestedOneWithoutReservationsInput
  }

  export type ReservationUncheckedCreateWithoutDoctorInput = {
    id: string
    isEnabled?: boolean
    unitId: number
    identity: string
    queueNumber: number
    reservationNumber: string
    reservationDate: Date | string
    paymentMethodId: number
    bpjsNumber?: string | null
    otherInsuranceNumber?: string | null
    createdAt?: Date | string
    referralNumber?: string | null
    notes?: string | null
    queueType: string
    referralSourceId?: number | null
    isConfirmed?: boolean
    callStatus?: string
    isCancelled?: boolean
    cancelReason?: string | null
    educationId?: number | null
    type?: string | null
    patientType?: string | null
  }

  export type ReservationCreateOrConnectWithoutDoctorInput = {
    where: ReservationWhereUniqueInput
    create: XOR<ReservationCreateWithoutDoctorInput, ReservationUncheckedCreateWithoutDoctorInput>
  }

  export type ReservationCreateManyDoctorInputEnvelope = {
    data: ReservationCreateManyDoctorInput | ReservationCreateManyDoctorInput[]
    skipDuplicates?: boolean
  }

  export type DoctorScheduleUpsertWithWhereUniqueWithoutDoctorInput = {
    where: DoctorScheduleWhereUniqueInput
    update: XOR<DoctorScheduleUpdateWithoutDoctorInput, DoctorScheduleUncheckedUpdateWithoutDoctorInput>
    create: XOR<DoctorScheduleCreateWithoutDoctorInput, DoctorScheduleUncheckedCreateWithoutDoctorInput>
  }

  export type DoctorScheduleUpdateWithWhereUniqueWithoutDoctorInput = {
    where: DoctorScheduleWhereUniqueInput
    data: XOR<DoctorScheduleUpdateWithoutDoctorInput, DoctorScheduleUncheckedUpdateWithoutDoctorInput>
  }

  export type DoctorScheduleUpdateManyWithWhereWithoutDoctorInput = {
    where: DoctorScheduleScalarWhereInput
    data: XOR<DoctorScheduleUpdateManyMutationInput, DoctorScheduleUncheckedUpdateManyWithoutDoctorInput>
  }

  export type ReservationUpsertWithWhereUniqueWithoutDoctorInput = {
    where: ReservationWhereUniqueInput
    update: XOR<ReservationUpdateWithoutDoctorInput, ReservationUncheckedUpdateWithoutDoctorInput>
    create: XOR<ReservationCreateWithoutDoctorInput, ReservationUncheckedCreateWithoutDoctorInput>
  }

  export type ReservationUpdateWithWhereUniqueWithoutDoctorInput = {
    where: ReservationWhereUniqueInput
    data: XOR<ReservationUpdateWithoutDoctorInput, ReservationUncheckedUpdateWithoutDoctorInput>
  }

  export type ReservationUpdateManyWithWhereWithoutDoctorInput = {
    where: ReservationScalarWhereInput
    data: XOR<ReservationUpdateManyMutationInput, ReservationUncheckedUpdateManyWithoutDoctorInput>
  }

  export type UnitCreateWithoutReservationsInput = {
    id: number
    unitName: string
    isEnabled: boolean
    rooms?: RoomCreateNestedManyWithoutUnitInput
    department?: DepartmentCreateNestedOneWithoutUnitsInput
    stockDetails?: StockDetailCreateNestedManyWithoutUnitInput
    doctorSchedules?: DoctorScheduleCreateNestedManyWithoutUnitInput
  }

  export type UnitUncheckedCreateWithoutReservationsInput = {
    id: number
    unitName: string
    isEnabled: boolean
    departmentId?: number | null
    rooms?: RoomUncheckedCreateNestedManyWithoutUnitInput
    stockDetails?: StockDetailUncheckedCreateNestedManyWithoutUnitInput
    doctorSchedules?: DoctorScheduleUncheckedCreateNestedManyWithoutUnitInput
  }

  export type UnitCreateOrConnectWithoutReservationsInput = {
    where: UnitWhereUniqueInput
    create: XOR<UnitCreateWithoutReservationsInput, UnitUncheckedCreateWithoutReservationsInput>
  }

  export type PatientCreateWithoutReservationsInput = {
    id: number
    isEnabled?: boolean
    name?: string | null
    identity: string
    birthPlace?: string | null
    birthDate?: Date | string | null
    motherName?: string | null
    fatherName?: string | null
    spouseName?: string | null
    bpjsNumber?: string | null
    otherInsuranceNumber?: string | null
    phoneNumber?: string | null
    registeredAt?: Date | string | null
    homeAddress?: string | null
    gender?: GenderCreateNestedOneWithoutPatientsInput
  }

  export type PatientUncheckedCreateWithoutReservationsInput = {
    id: number
    isEnabled?: boolean
    name?: string | null
    identity: string
    genderId?: number | null
    birthPlace?: string | null
    birthDate?: Date | string | null
    motherName?: string | null
    fatherName?: string | null
    spouseName?: string | null
    bpjsNumber?: string | null
    otherInsuranceNumber?: string | null
    phoneNumber?: string | null
    registeredAt?: Date | string | null
    homeAddress?: string | null
  }

  export type PatientCreateOrConnectWithoutReservationsInput = {
    where: PatientWhereUniqueInput
    create: XOR<PatientCreateWithoutReservationsInput, PatientUncheckedCreateWithoutReservationsInput>
  }

  export type PaymentMethodCreateWithoutReservationsInput = {
    id: number
    isEnabled: boolean
    displayName: string
  }

  export type PaymentMethodUncheckedCreateWithoutReservationsInput = {
    id: number
    isEnabled: boolean
    displayName: string
  }

  export type PaymentMethodCreateOrConnectWithoutReservationsInput = {
    where: PaymentMethodWhereUniqueInput
    create: XOR<PaymentMethodCreateWithoutReservationsInput, PaymentMethodUncheckedCreateWithoutReservationsInput>
  }

  export type EmployeeCreateWithoutReservationsInput = {
    id: number
    fullName: string
    identityNo?: string | null
    isEnabled: boolean
    doctorSchedules?: DoctorScheduleCreateNestedManyWithoutDoctorInput
  }

  export type EmployeeUncheckedCreateWithoutReservationsInput = {
    id: number
    fullName: string
    identityNo?: string | null
    isEnabled: boolean
    doctorSchedules?: DoctorScheduleUncheckedCreateNestedManyWithoutDoctorInput
  }

  export type EmployeeCreateOrConnectWithoutReservationsInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutReservationsInput, EmployeeUncheckedCreateWithoutReservationsInput>
  }

  export type ReferralSourceCreateWithoutReservationsInput = {
    id: number
    source: string
    isEnabled: boolean
  }

  export type ReferralSourceUncheckedCreateWithoutReservationsInput = {
    id: number
    source: string
    isEnabled: boolean
  }

  export type ReferralSourceCreateOrConnectWithoutReservationsInput = {
    where: ReferralSourceWhereUniqueInput
    create: XOR<ReferralSourceCreateWithoutReservationsInput, ReferralSourceUncheckedCreateWithoutReservationsInput>
  }

  export type UnitUpsertWithoutReservationsInput = {
    update: XOR<UnitUpdateWithoutReservationsInput, UnitUncheckedUpdateWithoutReservationsInput>
    create: XOR<UnitCreateWithoutReservationsInput, UnitUncheckedCreateWithoutReservationsInput>
    where?: UnitWhereInput
  }

  export type UnitUpdateToOneWithWhereWithoutReservationsInput = {
    where?: UnitWhereInput
    data: XOR<UnitUpdateWithoutReservationsInput, UnitUncheckedUpdateWithoutReservationsInput>
  }

  export type UnitUpdateWithoutReservationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    unitName?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    rooms?: RoomUpdateManyWithoutUnitNestedInput
    department?: DepartmentUpdateOneWithoutUnitsNestedInput
    stockDetails?: StockDetailUpdateManyWithoutUnitNestedInput
    doctorSchedules?: DoctorScheduleUpdateManyWithoutUnitNestedInput
  }

  export type UnitUncheckedUpdateWithoutReservationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    unitName?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    departmentId?: NullableIntFieldUpdateOperationsInput | number | null
    rooms?: RoomUncheckedUpdateManyWithoutUnitNestedInput
    stockDetails?: StockDetailUncheckedUpdateManyWithoutUnitNestedInput
    doctorSchedules?: DoctorScheduleUncheckedUpdateManyWithoutUnitNestedInput
  }

  export type PatientUpsertWithoutReservationsInput = {
    update: XOR<PatientUpdateWithoutReservationsInput, PatientUncheckedUpdateWithoutReservationsInput>
    create: XOR<PatientCreateWithoutReservationsInput, PatientUncheckedCreateWithoutReservationsInput>
    where?: PatientWhereInput
  }

  export type PatientUpdateToOneWithWhereWithoutReservationsInput = {
    where?: PatientWhereInput
    data: XOR<PatientUpdateWithoutReservationsInput, PatientUncheckedUpdateWithoutReservationsInput>
  }

  export type PatientUpdateWithoutReservationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    name?: NullableStringFieldUpdateOperationsInput | string | null
    identity?: StringFieldUpdateOperationsInput | string
    birthPlace?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    motherName?: NullableStringFieldUpdateOperationsInput | string | null
    fatherName?: NullableStringFieldUpdateOperationsInput | string | null
    spouseName?: NullableStringFieldUpdateOperationsInput | string | null
    bpjsNumber?: NullableStringFieldUpdateOperationsInput | string | null
    otherInsuranceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    registeredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    homeAddress?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: GenderUpdateOneWithoutPatientsNestedInput
  }

  export type PatientUncheckedUpdateWithoutReservationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    name?: NullableStringFieldUpdateOperationsInput | string | null
    identity?: StringFieldUpdateOperationsInput | string
    genderId?: NullableIntFieldUpdateOperationsInput | number | null
    birthPlace?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    motherName?: NullableStringFieldUpdateOperationsInput | string | null
    fatherName?: NullableStringFieldUpdateOperationsInput | string | null
    spouseName?: NullableStringFieldUpdateOperationsInput | string | null
    bpjsNumber?: NullableStringFieldUpdateOperationsInput | string | null
    otherInsuranceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    registeredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    homeAddress?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PaymentMethodUpsertWithoutReservationsInput = {
    update: XOR<PaymentMethodUpdateWithoutReservationsInput, PaymentMethodUncheckedUpdateWithoutReservationsInput>
    create: XOR<PaymentMethodCreateWithoutReservationsInput, PaymentMethodUncheckedCreateWithoutReservationsInput>
    where?: PaymentMethodWhereInput
  }

  export type PaymentMethodUpdateToOneWithWhereWithoutReservationsInput = {
    where?: PaymentMethodWhereInput
    data: XOR<PaymentMethodUpdateWithoutReservationsInput, PaymentMethodUncheckedUpdateWithoutReservationsInput>
  }

  export type PaymentMethodUpdateWithoutReservationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    displayName?: StringFieldUpdateOperationsInput | string
  }

  export type PaymentMethodUncheckedUpdateWithoutReservationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    displayName?: StringFieldUpdateOperationsInput | string
  }

  export type EmployeeUpsertWithoutReservationsInput = {
    update: XOR<EmployeeUpdateWithoutReservationsInput, EmployeeUncheckedUpdateWithoutReservationsInput>
    create: XOR<EmployeeCreateWithoutReservationsInput, EmployeeUncheckedCreateWithoutReservationsInput>
    where?: EmployeeWhereInput
  }

  export type EmployeeUpdateToOneWithWhereWithoutReservationsInput = {
    where?: EmployeeWhereInput
    data: XOR<EmployeeUpdateWithoutReservationsInput, EmployeeUncheckedUpdateWithoutReservationsInput>
  }

  export type EmployeeUpdateWithoutReservationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    fullName?: StringFieldUpdateOperationsInput | string
    identityNo?: NullableStringFieldUpdateOperationsInput | string | null
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    doctorSchedules?: DoctorScheduleUpdateManyWithoutDoctorNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutReservationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    fullName?: StringFieldUpdateOperationsInput | string
    identityNo?: NullableStringFieldUpdateOperationsInput | string | null
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    doctorSchedules?: DoctorScheduleUncheckedUpdateManyWithoutDoctorNestedInput
  }

  export type ReferralSourceUpsertWithoutReservationsInput = {
    update: XOR<ReferralSourceUpdateWithoutReservationsInput, ReferralSourceUncheckedUpdateWithoutReservationsInput>
    create: XOR<ReferralSourceCreateWithoutReservationsInput, ReferralSourceUncheckedCreateWithoutReservationsInput>
    where?: ReferralSourceWhereInput
  }

  export type ReferralSourceUpdateToOneWithWhereWithoutReservationsInput = {
    where?: ReferralSourceWhereInput
    data: XOR<ReferralSourceUpdateWithoutReservationsInput, ReferralSourceUncheckedUpdateWithoutReservationsInput>
  }

  export type ReferralSourceUpdateWithoutReservationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    source?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ReferralSourceUncheckedUpdateWithoutReservationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    source?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
  }

  export type GenderCreateWithoutPatientsInput = {
    id: number
    gender: string
    isEnabled: boolean
  }

  export type GenderUncheckedCreateWithoutPatientsInput = {
    id: number
    gender: string
    isEnabled: boolean
  }

  export type GenderCreateOrConnectWithoutPatientsInput = {
    where: GenderWhereUniqueInput
    create: XOR<GenderCreateWithoutPatientsInput, GenderUncheckedCreateWithoutPatientsInput>
  }

  export type ReservationCreateWithoutPatientInput = {
    id: string
    isEnabled?: boolean
    queueNumber: number
    reservationNumber: string
    reservationDate: Date | string
    bpjsNumber?: string | null
    otherInsuranceNumber?: string | null
    createdAt?: Date | string
    referralNumber?: string | null
    notes?: string | null
    queueType: string
    isConfirmed?: boolean
    callStatus?: string
    isCancelled?: boolean
    cancelReason?: string | null
    educationId?: number | null
    type?: string | null
    patientType?: string | null
    unit: UnitCreateNestedOneWithoutReservationsInput
    paymentMethod: PaymentMethodCreateNestedOneWithoutReservationsInput
    doctor?: EmployeeCreateNestedOneWithoutReservationsInput
    referralSource?: ReferralSourceCreateNestedOneWithoutReservationsInput
  }

  export type ReservationUncheckedCreateWithoutPatientInput = {
    id: string
    isEnabled?: boolean
    unitId: number
    queueNumber: number
    reservationNumber: string
    reservationDate: Date | string
    paymentMethodId: number
    bpjsNumber?: string | null
    otherInsuranceNumber?: string | null
    createdAt?: Date | string
    referralNumber?: string | null
    doctorId?: number | null
    notes?: string | null
    queueType: string
    referralSourceId?: number | null
    isConfirmed?: boolean
    callStatus?: string
    isCancelled?: boolean
    cancelReason?: string | null
    educationId?: number | null
    type?: string | null
    patientType?: string | null
  }

  export type ReservationCreateOrConnectWithoutPatientInput = {
    where: ReservationWhereUniqueInput
    create: XOR<ReservationCreateWithoutPatientInput, ReservationUncheckedCreateWithoutPatientInput>
  }

  export type ReservationCreateManyPatientInputEnvelope = {
    data: ReservationCreateManyPatientInput | ReservationCreateManyPatientInput[]
    skipDuplicates?: boolean
  }

  export type GenderUpsertWithoutPatientsInput = {
    update: XOR<GenderUpdateWithoutPatientsInput, GenderUncheckedUpdateWithoutPatientsInput>
    create: XOR<GenderCreateWithoutPatientsInput, GenderUncheckedCreateWithoutPatientsInput>
    where?: GenderWhereInput
  }

  export type GenderUpdateToOneWithWhereWithoutPatientsInput = {
    where?: GenderWhereInput
    data: XOR<GenderUpdateWithoutPatientsInput, GenderUncheckedUpdateWithoutPatientsInput>
  }

  export type GenderUpdateWithoutPatientsInput = {
    id?: IntFieldUpdateOperationsInput | number
    gender?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
  }

  export type GenderUncheckedUpdateWithoutPatientsInput = {
    id?: IntFieldUpdateOperationsInput | number
    gender?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ReservationUpsertWithWhereUniqueWithoutPatientInput = {
    where: ReservationWhereUniqueInput
    update: XOR<ReservationUpdateWithoutPatientInput, ReservationUncheckedUpdateWithoutPatientInput>
    create: XOR<ReservationCreateWithoutPatientInput, ReservationUncheckedCreateWithoutPatientInput>
  }

  export type ReservationUpdateWithWhereUniqueWithoutPatientInput = {
    where: ReservationWhereUniqueInput
    data: XOR<ReservationUpdateWithoutPatientInput, ReservationUncheckedUpdateWithoutPatientInput>
  }

  export type ReservationUpdateManyWithWhereWithoutPatientInput = {
    where: ReservationScalarWhereInput
    data: XOR<ReservationUpdateManyMutationInput, ReservationUncheckedUpdateManyWithoutPatientInput>
  }

  export type PatientCreateWithoutGenderInput = {
    id: number
    isEnabled?: boolean
    name?: string | null
    identity: string
    birthPlace?: string | null
    birthDate?: Date | string | null
    motherName?: string | null
    fatherName?: string | null
    spouseName?: string | null
    bpjsNumber?: string | null
    otherInsuranceNumber?: string | null
    phoneNumber?: string | null
    registeredAt?: Date | string | null
    homeAddress?: string | null
    reservations?: ReservationCreateNestedManyWithoutPatientInput
  }

  export type PatientUncheckedCreateWithoutGenderInput = {
    id: number
    isEnabled?: boolean
    name?: string | null
    identity: string
    birthPlace?: string | null
    birthDate?: Date | string | null
    motherName?: string | null
    fatherName?: string | null
    spouseName?: string | null
    bpjsNumber?: string | null
    otherInsuranceNumber?: string | null
    phoneNumber?: string | null
    registeredAt?: Date | string | null
    homeAddress?: string | null
    reservations?: ReservationUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientCreateOrConnectWithoutGenderInput = {
    where: PatientWhereUniqueInput
    create: XOR<PatientCreateWithoutGenderInput, PatientUncheckedCreateWithoutGenderInput>
  }

  export type PatientCreateManyGenderInputEnvelope = {
    data: PatientCreateManyGenderInput | PatientCreateManyGenderInput[]
    skipDuplicates?: boolean
  }

  export type PatientUpsertWithWhereUniqueWithoutGenderInput = {
    where: PatientWhereUniqueInput
    update: XOR<PatientUpdateWithoutGenderInput, PatientUncheckedUpdateWithoutGenderInput>
    create: XOR<PatientCreateWithoutGenderInput, PatientUncheckedCreateWithoutGenderInput>
  }

  export type PatientUpdateWithWhereUniqueWithoutGenderInput = {
    where: PatientWhereUniqueInput
    data: XOR<PatientUpdateWithoutGenderInput, PatientUncheckedUpdateWithoutGenderInput>
  }

  export type PatientUpdateManyWithWhereWithoutGenderInput = {
    where: PatientScalarWhereInput
    data: XOR<PatientUpdateManyMutationInput, PatientUncheckedUpdateManyWithoutGenderInput>
  }

  export type PatientScalarWhereInput = {
    AND?: PatientScalarWhereInput | PatientScalarWhereInput[]
    OR?: PatientScalarWhereInput[]
    NOT?: PatientScalarWhereInput | PatientScalarWhereInput[]
    id?: IntFilter<"Patient"> | number
    isEnabled?: BoolFilter<"Patient"> | boolean
    name?: StringNullableFilter<"Patient"> | string | null
    identity?: StringFilter<"Patient"> | string
    genderId?: IntNullableFilter<"Patient"> | number | null
    birthPlace?: StringNullableFilter<"Patient"> | string | null
    birthDate?: DateTimeNullableFilter<"Patient"> | Date | string | null
    motherName?: StringNullableFilter<"Patient"> | string | null
    fatherName?: StringNullableFilter<"Patient"> | string | null
    spouseName?: StringNullableFilter<"Patient"> | string | null
    bpjsNumber?: StringNullableFilter<"Patient"> | string | null
    otherInsuranceNumber?: StringNullableFilter<"Patient"> | string | null
    phoneNumber?: StringNullableFilter<"Patient"> | string | null
    registeredAt?: DateTimeNullableFilter<"Patient"> | Date | string | null
    homeAddress?: StringNullableFilter<"Patient"> | string | null
  }

  export type ReservationCreateWithoutReferralSourceInput = {
    id: string
    isEnabled?: boolean
    queueNumber: number
    reservationNumber: string
    reservationDate: Date | string
    bpjsNumber?: string | null
    otherInsuranceNumber?: string | null
    createdAt?: Date | string
    referralNumber?: string | null
    notes?: string | null
    queueType: string
    isConfirmed?: boolean
    callStatus?: string
    isCancelled?: boolean
    cancelReason?: string | null
    educationId?: number | null
    type?: string | null
    patientType?: string | null
    unit: UnitCreateNestedOneWithoutReservationsInput
    patient?: PatientCreateNestedOneWithoutReservationsInput
    paymentMethod: PaymentMethodCreateNestedOneWithoutReservationsInput
    doctor?: EmployeeCreateNestedOneWithoutReservationsInput
  }

  export type ReservationUncheckedCreateWithoutReferralSourceInput = {
    id: string
    isEnabled?: boolean
    unitId: number
    identity: string
    queueNumber: number
    reservationNumber: string
    reservationDate: Date | string
    paymentMethodId: number
    bpjsNumber?: string | null
    otherInsuranceNumber?: string | null
    createdAt?: Date | string
    referralNumber?: string | null
    doctorId?: number | null
    notes?: string | null
    queueType: string
    isConfirmed?: boolean
    callStatus?: string
    isCancelled?: boolean
    cancelReason?: string | null
    educationId?: number | null
    type?: string | null
    patientType?: string | null
  }

  export type ReservationCreateOrConnectWithoutReferralSourceInput = {
    where: ReservationWhereUniqueInput
    create: XOR<ReservationCreateWithoutReferralSourceInput, ReservationUncheckedCreateWithoutReferralSourceInput>
  }

  export type ReservationCreateManyReferralSourceInputEnvelope = {
    data: ReservationCreateManyReferralSourceInput | ReservationCreateManyReferralSourceInput[]
    skipDuplicates?: boolean
  }

  export type ReservationUpsertWithWhereUniqueWithoutReferralSourceInput = {
    where: ReservationWhereUniqueInput
    update: XOR<ReservationUpdateWithoutReferralSourceInput, ReservationUncheckedUpdateWithoutReferralSourceInput>
    create: XOR<ReservationCreateWithoutReferralSourceInput, ReservationUncheckedCreateWithoutReferralSourceInput>
  }

  export type ReservationUpdateWithWhereUniqueWithoutReferralSourceInput = {
    where: ReservationWhereUniqueInput
    data: XOR<ReservationUpdateWithoutReferralSourceInput, ReservationUncheckedUpdateWithoutReferralSourceInput>
  }

  export type ReservationUpdateManyWithWhereWithoutReferralSourceInput = {
    where: ReservationScalarWhereInput
    data: XOR<ReservationUpdateManyMutationInput, ReservationUncheckedUpdateManyWithoutReferralSourceInput>
  }

  export type ReservationCreateManyPaymentMethodInput = {
    id: string
    isEnabled?: boolean
    unitId: number
    identity: string
    queueNumber: number
    reservationNumber: string
    reservationDate: Date | string
    bpjsNumber?: string | null
    otherInsuranceNumber?: string | null
    createdAt?: Date | string
    referralNumber?: string | null
    doctorId?: number | null
    notes?: string | null
    queueType: string
    referralSourceId?: number | null
    isConfirmed?: boolean
    callStatus?: string
    isCancelled?: boolean
    cancelReason?: string | null
    educationId?: number | null
    type?: string | null
    patientType?: string | null
  }

  export type ReservationUpdateWithoutPaymentMethodInput = {
    id?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    queueNumber?: IntFieldUpdateOperationsInput | number
    reservationNumber?: StringFieldUpdateOperationsInput | string
    reservationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    bpjsNumber?: NullableStringFieldUpdateOperationsInput | string | null
    otherInsuranceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referralNumber?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    queueType?: StringFieldUpdateOperationsInput | string
    isConfirmed?: BoolFieldUpdateOperationsInput | boolean
    callStatus?: StringFieldUpdateOperationsInput | string
    isCancelled?: BoolFieldUpdateOperationsInput | boolean
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    educationId?: NullableIntFieldUpdateOperationsInput | number | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    patientType?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: UnitUpdateOneRequiredWithoutReservationsNestedInput
    patient?: PatientUpdateOneWithoutReservationsNestedInput
    doctor?: EmployeeUpdateOneWithoutReservationsNestedInput
    referralSource?: ReferralSourceUpdateOneWithoutReservationsNestedInput
  }

  export type ReservationUncheckedUpdateWithoutPaymentMethodInput = {
    id?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    unitId?: IntFieldUpdateOperationsInput | number
    identity?: StringFieldUpdateOperationsInput | string
    queueNumber?: IntFieldUpdateOperationsInput | number
    reservationNumber?: StringFieldUpdateOperationsInput | string
    reservationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    bpjsNumber?: NullableStringFieldUpdateOperationsInput | string | null
    otherInsuranceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referralNumber?: NullableStringFieldUpdateOperationsInput | string | null
    doctorId?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    queueType?: StringFieldUpdateOperationsInput | string
    referralSourceId?: NullableIntFieldUpdateOperationsInput | number | null
    isConfirmed?: BoolFieldUpdateOperationsInput | boolean
    callStatus?: StringFieldUpdateOperationsInput | string
    isCancelled?: BoolFieldUpdateOperationsInput | boolean
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    educationId?: NullableIntFieldUpdateOperationsInput | number | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    patientType?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ReservationUncheckedUpdateManyWithoutPaymentMethodInput = {
    id?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    unitId?: IntFieldUpdateOperationsInput | number
    identity?: StringFieldUpdateOperationsInput | string
    queueNumber?: IntFieldUpdateOperationsInput | number
    reservationNumber?: StringFieldUpdateOperationsInput | string
    reservationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    bpjsNumber?: NullableStringFieldUpdateOperationsInput | string | null
    otherInsuranceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referralNumber?: NullableStringFieldUpdateOperationsInput | string | null
    doctorId?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    queueType?: StringFieldUpdateOperationsInput | string
    referralSourceId?: NullableIntFieldUpdateOperationsInput | number | null
    isConfirmed?: BoolFieldUpdateOperationsInput | boolean
    callStatus?: StringFieldUpdateOperationsInput | string
    isCancelled?: BoolFieldUpdateOperationsInput | boolean
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    educationId?: NullableIntFieldUpdateOperationsInput | number | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    patientType?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BedCreateManyRoomInput = {
    id: number
    displayName: string
    bedNumber: number
    isEnabled: boolean
    bedStatusId?: number | null
  }

  export type BedUpdateWithoutRoomInput = {
    id?: IntFieldUpdateOperationsInput | number
    displayName?: StringFieldUpdateOperationsInput | string
    bedNumber?: IntFieldUpdateOperationsInput | number
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    bedStatus?: BedStatusUpdateOneWithoutBedsNestedInput
  }

  export type BedUncheckedUpdateWithoutRoomInput = {
    id?: IntFieldUpdateOperationsInput | number
    displayName?: StringFieldUpdateOperationsInput | string
    bedNumber?: IntFieldUpdateOperationsInput | number
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    bedStatusId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type BedUncheckedUpdateManyWithoutRoomInput = {
    id?: IntFieldUpdateOperationsInput | number
    displayName?: StringFieldUpdateOperationsInput | string
    bedNumber?: IntFieldUpdateOperationsInput | number
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    bedStatusId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type RoomCreateManyUnitInput = {
    id: number
    roomName: string
    isEnabled: boolean
    classId?: number | null
  }

  export type StockDetailCreateManyUnitInput = {
    id: string
    productId: number
    receiptId: string
    sourceProductId?: number | null
    netPrice?: number | null
    discountPrice?: number | null
    quantity: number
    isEnabled: boolean
    expiredAt?: Date | string | null
  }

  export type DoctorScheduleCreateManyUnitInput = {
    id: number
    doctorId: number
    startTime: Date | string
    endTime: Date | string
    note?: string | null
    days: string
    quota: number
    isEnabled: boolean
  }

  export type ReservationCreateManyUnitInput = {
    id: string
    isEnabled?: boolean
    identity: string
    queueNumber: number
    reservationNumber: string
    reservationDate: Date | string
    paymentMethodId: number
    bpjsNumber?: string | null
    otherInsuranceNumber?: string | null
    createdAt?: Date | string
    referralNumber?: string | null
    doctorId?: number | null
    notes?: string | null
    queueType: string
    referralSourceId?: number | null
    isConfirmed?: boolean
    callStatus?: string
    isCancelled?: boolean
    cancelReason?: string | null
    educationId?: number | null
    type?: string | null
    patientType?: string | null
  }

  export type RoomUpdateWithoutUnitInput = {
    id?: IntFieldUpdateOperationsInput | number
    roomName?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    class?: ClassUpdateOneWithoutRoomsNestedInput
    beds?: BedUpdateManyWithoutRoomNestedInput
  }

  export type RoomUncheckedUpdateWithoutUnitInput = {
    id?: IntFieldUpdateOperationsInput | number
    roomName?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    classId?: NullableIntFieldUpdateOperationsInput | number | null
    beds?: BedUncheckedUpdateManyWithoutRoomNestedInput
  }

  export type RoomUncheckedUpdateManyWithoutUnitInput = {
    id?: IntFieldUpdateOperationsInput | number
    roomName?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    classId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type StockDetailUpdateWithoutUnitInput = {
    id?: StringFieldUpdateOperationsInput | string
    sourceProductId?: NullableIntFieldUpdateOperationsInput | number | null
    netPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    discountPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    quantity?: FloatFieldUpdateOperationsInput | number
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    expiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    product?: ProductUpdateOneRequiredWithoutStockDetailsNestedInput
    receipt?: ServiceReceiptUpdateOneRequiredWithoutStockDetailsNestedInput
  }

  export type StockDetailUncheckedUpdateWithoutUnitInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: IntFieldUpdateOperationsInput | number
    receiptId?: StringFieldUpdateOperationsInput | string
    sourceProductId?: NullableIntFieldUpdateOperationsInput | number | null
    netPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    discountPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    quantity?: FloatFieldUpdateOperationsInput | number
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    expiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type StockDetailUncheckedUpdateManyWithoutUnitInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: IntFieldUpdateOperationsInput | number
    receiptId?: StringFieldUpdateOperationsInput | string
    sourceProductId?: NullableIntFieldUpdateOperationsInput | number | null
    netPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    discountPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    quantity?: FloatFieldUpdateOperationsInput | number
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    expiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DoctorScheduleUpdateWithoutUnitInput = {
    id?: IntFieldUpdateOperationsInput | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    days?: StringFieldUpdateOperationsInput | string
    quota?: IntFieldUpdateOperationsInput | number
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    doctor?: EmployeeUpdateOneRequiredWithoutDoctorSchedulesNestedInput
  }

  export type DoctorScheduleUncheckedUpdateWithoutUnitInput = {
    id?: IntFieldUpdateOperationsInput | number
    doctorId?: IntFieldUpdateOperationsInput | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    days?: StringFieldUpdateOperationsInput | string
    quota?: IntFieldUpdateOperationsInput | number
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
  }

  export type DoctorScheduleUncheckedUpdateManyWithoutUnitInput = {
    id?: IntFieldUpdateOperationsInput | number
    doctorId?: IntFieldUpdateOperationsInput | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    days?: StringFieldUpdateOperationsInput | string
    quota?: IntFieldUpdateOperationsInput | number
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ReservationUpdateWithoutUnitInput = {
    id?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    queueNumber?: IntFieldUpdateOperationsInput | number
    reservationNumber?: StringFieldUpdateOperationsInput | string
    reservationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    bpjsNumber?: NullableStringFieldUpdateOperationsInput | string | null
    otherInsuranceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referralNumber?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    queueType?: StringFieldUpdateOperationsInput | string
    isConfirmed?: BoolFieldUpdateOperationsInput | boolean
    callStatus?: StringFieldUpdateOperationsInput | string
    isCancelled?: BoolFieldUpdateOperationsInput | boolean
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    educationId?: NullableIntFieldUpdateOperationsInput | number | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    patientType?: NullableStringFieldUpdateOperationsInput | string | null
    patient?: PatientUpdateOneWithoutReservationsNestedInput
    paymentMethod?: PaymentMethodUpdateOneRequiredWithoutReservationsNestedInput
    doctor?: EmployeeUpdateOneWithoutReservationsNestedInput
    referralSource?: ReferralSourceUpdateOneWithoutReservationsNestedInput
  }

  export type ReservationUncheckedUpdateWithoutUnitInput = {
    id?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    identity?: StringFieldUpdateOperationsInput | string
    queueNumber?: IntFieldUpdateOperationsInput | number
    reservationNumber?: StringFieldUpdateOperationsInput | string
    reservationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMethodId?: IntFieldUpdateOperationsInput | number
    bpjsNumber?: NullableStringFieldUpdateOperationsInput | string | null
    otherInsuranceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referralNumber?: NullableStringFieldUpdateOperationsInput | string | null
    doctorId?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    queueType?: StringFieldUpdateOperationsInput | string
    referralSourceId?: NullableIntFieldUpdateOperationsInput | number | null
    isConfirmed?: BoolFieldUpdateOperationsInput | boolean
    callStatus?: StringFieldUpdateOperationsInput | string
    isCancelled?: BoolFieldUpdateOperationsInput | boolean
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    educationId?: NullableIntFieldUpdateOperationsInput | number | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    patientType?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ReservationUncheckedUpdateManyWithoutUnitInput = {
    id?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    identity?: StringFieldUpdateOperationsInput | string
    queueNumber?: IntFieldUpdateOperationsInput | number
    reservationNumber?: StringFieldUpdateOperationsInput | string
    reservationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMethodId?: IntFieldUpdateOperationsInput | number
    bpjsNumber?: NullableStringFieldUpdateOperationsInput | string | null
    otherInsuranceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referralNumber?: NullableStringFieldUpdateOperationsInput | string | null
    doctorId?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    queueType?: StringFieldUpdateOperationsInput | string
    referralSourceId?: NullableIntFieldUpdateOperationsInput | number | null
    isConfirmed?: BoolFieldUpdateOperationsInput | boolean
    callStatus?: StringFieldUpdateOperationsInput | string
    isCancelled?: BoolFieldUpdateOperationsInput | boolean
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    educationId?: NullableIntFieldUpdateOperationsInput | number | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    patientType?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BedCreateManyBedStatusInput = {
    id: number
    displayName: string
    bedNumber: number
    isEnabled: boolean
    roomId?: number | null
  }

  export type BedUpdateWithoutBedStatusInput = {
    id?: IntFieldUpdateOperationsInput | number
    displayName?: StringFieldUpdateOperationsInput | string
    bedNumber?: IntFieldUpdateOperationsInput | number
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    room?: RoomUpdateOneWithoutBedsNestedInput
  }

  export type BedUncheckedUpdateWithoutBedStatusInput = {
    id?: IntFieldUpdateOperationsInput | number
    displayName?: StringFieldUpdateOperationsInput | string
    bedNumber?: IntFieldUpdateOperationsInput | number
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    roomId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type BedUncheckedUpdateManyWithoutBedStatusInput = {
    id?: IntFieldUpdateOperationsInput | number
    displayName?: StringFieldUpdateOperationsInput | string
    bedNumber?: IntFieldUpdateOperationsInput | number
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    roomId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type RoomCreateManyClassInput = {
    id: number
    roomName: string
    isEnabled: boolean
    unitId?: number | null
  }

  export type RoomUpdateWithoutClassInput = {
    id?: IntFieldUpdateOperationsInput | number
    roomName?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    unit?: UnitUpdateOneWithoutRoomsNestedInput
    beds?: BedUpdateManyWithoutRoomNestedInput
  }

  export type RoomUncheckedUpdateWithoutClassInput = {
    id?: IntFieldUpdateOperationsInput | number
    roomName?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    unitId?: NullableIntFieldUpdateOperationsInput | number | null
    beds?: BedUncheckedUpdateManyWithoutRoomNestedInput
  }

  export type RoomUncheckedUpdateManyWithoutClassInput = {
    id?: IntFieldUpdateOperationsInput | number
    roomName?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    unitId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type UnitCreateManyDepartmentInput = {
    id: number
    unitName: string
    isEnabled: boolean
  }

  export type UnitUpdateWithoutDepartmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    unitName?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    rooms?: RoomUpdateManyWithoutUnitNestedInput
    stockDetails?: StockDetailUpdateManyWithoutUnitNestedInput
    doctorSchedules?: DoctorScheduleUpdateManyWithoutUnitNestedInput
    reservations?: ReservationUpdateManyWithoutUnitNestedInput
  }

  export type UnitUncheckedUpdateWithoutDepartmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    unitName?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    rooms?: RoomUncheckedUpdateManyWithoutUnitNestedInput
    stockDetails?: StockDetailUncheckedUpdateManyWithoutUnitNestedInput
    doctorSchedules?: DoctorScheduleUncheckedUpdateManyWithoutUnitNestedInput
    reservations?: ReservationUncheckedUpdateManyWithoutUnitNestedInput
  }

  export type UnitUncheckedUpdateManyWithoutDepartmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    unitName?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
  }

  export type StockDetailCreateManyProductInput = {
    id: string
    unitId: number
    receiptId: string
    sourceProductId?: number | null
    netPrice?: number | null
    discountPrice?: number | null
    quantity: number
    isEnabled: boolean
    expiredAt?: Date | string | null
  }

  export type StockDetailUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    sourceProductId?: NullableIntFieldUpdateOperationsInput | number | null
    netPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    discountPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    quantity?: FloatFieldUpdateOperationsInput | number
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    expiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    unit?: UnitUpdateOneRequiredWithoutStockDetailsNestedInput
    receipt?: ServiceReceiptUpdateOneRequiredWithoutStockDetailsNestedInput
  }

  export type StockDetailUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    unitId?: IntFieldUpdateOperationsInput | number
    receiptId?: StringFieldUpdateOperationsInput | string
    sourceProductId?: NullableIntFieldUpdateOperationsInput | number | null
    netPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    discountPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    quantity?: FloatFieldUpdateOperationsInput | number
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    expiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type StockDetailUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    unitId?: IntFieldUpdateOperationsInput | number
    receiptId?: StringFieldUpdateOperationsInput | string
    sourceProductId?: NullableIntFieldUpdateOperationsInput | number | null
    netPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    discountPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    quantity?: FloatFieldUpdateOperationsInput | number
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    expiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type StockDetailCreateManyReceiptInput = {
    id: string
    productId: number
    unitId: number
    sourceProductId?: number | null
    netPrice?: number | null
    discountPrice?: number | null
    quantity: number
    isEnabled: boolean
    expiredAt?: Date | string | null
  }

  export type StockDetailUpdateWithoutReceiptInput = {
    id?: StringFieldUpdateOperationsInput | string
    sourceProductId?: NullableIntFieldUpdateOperationsInput | number | null
    netPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    discountPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    quantity?: FloatFieldUpdateOperationsInput | number
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    expiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    product?: ProductUpdateOneRequiredWithoutStockDetailsNestedInput
    unit?: UnitUpdateOneRequiredWithoutStockDetailsNestedInput
  }

  export type StockDetailUncheckedUpdateWithoutReceiptInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: IntFieldUpdateOperationsInput | number
    unitId?: IntFieldUpdateOperationsInput | number
    sourceProductId?: NullableIntFieldUpdateOperationsInput | number | null
    netPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    discountPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    quantity?: FloatFieldUpdateOperationsInput | number
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    expiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type StockDetailUncheckedUpdateManyWithoutReceiptInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: IntFieldUpdateOperationsInput | number
    unitId?: IntFieldUpdateOperationsInput | number
    sourceProductId?: NullableIntFieldUpdateOperationsInput | number | null
    netPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    discountPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    quantity?: FloatFieldUpdateOperationsInput | number
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    expiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DoctorScheduleCreateManyDoctorInput = {
    id: number
    unitId: number
    startTime: Date | string
    endTime: Date | string
    note?: string | null
    days: string
    quota: number
    isEnabled: boolean
  }

  export type ReservationCreateManyDoctorInput = {
    id: string
    isEnabled?: boolean
    unitId: number
    identity: string
    queueNumber: number
    reservationNumber: string
    reservationDate: Date | string
    paymentMethodId: number
    bpjsNumber?: string | null
    otherInsuranceNumber?: string | null
    createdAt?: Date | string
    referralNumber?: string | null
    notes?: string | null
    queueType: string
    referralSourceId?: number | null
    isConfirmed?: boolean
    callStatus?: string
    isCancelled?: boolean
    cancelReason?: string | null
    educationId?: number | null
    type?: string | null
    patientType?: string | null
  }

  export type DoctorScheduleUpdateWithoutDoctorInput = {
    id?: IntFieldUpdateOperationsInput | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    days?: StringFieldUpdateOperationsInput | string
    quota?: IntFieldUpdateOperationsInput | number
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    unit?: UnitUpdateOneRequiredWithoutDoctorSchedulesNestedInput
  }

  export type DoctorScheduleUncheckedUpdateWithoutDoctorInput = {
    id?: IntFieldUpdateOperationsInput | number
    unitId?: IntFieldUpdateOperationsInput | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    days?: StringFieldUpdateOperationsInput | string
    quota?: IntFieldUpdateOperationsInput | number
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
  }

  export type DoctorScheduleUncheckedUpdateManyWithoutDoctorInput = {
    id?: IntFieldUpdateOperationsInput | number
    unitId?: IntFieldUpdateOperationsInput | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    days?: StringFieldUpdateOperationsInput | string
    quota?: IntFieldUpdateOperationsInput | number
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ReservationUpdateWithoutDoctorInput = {
    id?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    queueNumber?: IntFieldUpdateOperationsInput | number
    reservationNumber?: StringFieldUpdateOperationsInput | string
    reservationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    bpjsNumber?: NullableStringFieldUpdateOperationsInput | string | null
    otherInsuranceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referralNumber?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    queueType?: StringFieldUpdateOperationsInput | string
    isConfirmed?: BoolFieldUpdateOperationsInput | boolean
    callStatus?: StringFieldUpdateOperationsInput | string
    isCancelled?: BoolFieldUpdateOperationsInput | boolean
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    educationId?: NullableIntFieldUpdateOperationsInput | number | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    patientType?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: UnitUpdateOneRequiredWithoutReservationsNestedInput
    patient?: PatientUpdateOneWithoutReservationsNestedInput
    paymentMethod?: PaymentMethodUpdateOneRequiredWithoutReservationsNestedInput
    referralSource?: ReferralSourceUpdateOneWithoutReservationsNestedInput
  }

  export type ReservationUncheckedUpdateWithoutDoctorInput = {
    id?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    unitId?: IntFieldUpdateOperationsInput | number
    identity?: StringFieldUpdateOperationsInput | string
    queueNumber?: IntFieldUpdateOperationsInput | number
    reservationNumber?: StringFieldUpdateOperationsInput | string
    reservationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMethodId?: IntFieldUpdateOperationsInput | number
    bpjsNumber?: NullableStringFieldUpdateOperationsInput | string | null
    otherInsuranceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referralNumber?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    queueType?: StringFieldUpdateOperationsInput | string
    referralSourceId?: NullableIntFieldUpdateOperationsInput | number | null
    isConfirmed?: BoolFieldUpdateOperationsInput | boolean
    callStatus?: StringFieldUpdateOperationsInput | string
    isCancelled?: BoolFieldUpdateOperationsInput | boolean
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    educationId?: NullableIntFieldUpdateOperationsInput | number | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    patientType?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ReservationUncheckedUpdateManyWithoutDoctorInput = {
    id?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    unitId?: IntFieldUpdateOperationsInput | number
    identity?: StringFieldUpdateOperationsInput | string
    queueNumber?: IntFieldUpdateOperationsInput | number
    reservationNumber?: StringFieldUpdateOperationsInput | string
    reservationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMethodId?: IntFieldUpdateOperationsInput | number
    bpjsNumber?: NullableStringFieldUpdateOperationsInput | string | null
    otherInsuranceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referralNumber?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    queueType?: StringFieldUpdateOperationsInput | string
    referralSourceId?: NullableIntFieldUpdateOperationsInput | number | null
    isConfirmed?: BoolFieldUpdateOperationsInput | boolean
    callStatus?: StringFieldUpdateOperationsInput | string
    isCancelled?: BoolFieldUpdateOperationsInput | boolean
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    educationId?: NullableIntFieldUpdateOperationsInput | number | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    patientType?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ReservationCreateManyPatientInput = {
    id: string
    isEnabled?: boolean
    unitId: number
    queueNumber: number
    reservationNumber: string
    reservationDate: Date | string
    paymentMethodId: number
    bpjsNumber?: string | null
    otherInsuranceNumber?: string | null
    createdAt?: Date | string
    referralNumber?: string | null
    doctorId?: number | null
    notes?: string | null
    queueType: string
    referralSourceId?: number | null
    isConfirmed?: boolean
    callStatus?: string
    isCancelled?: boolean
    cancelReason?: string | null
    educationId?: number | null
    type?: string | null
    patientType?: string | null
  }

  export type ReservationUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    queueNumber?: IntFieldUpdateOperationsInput | number
    reservationNumber?: StringFieldUpdateOperationsInput | string
    reservationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    bpjsNumber?: NullableStringFieldUpdateOperationsInput | string | null
    otherInsuranceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referralNumber?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    queueType?: StringFieldUpdateOperationsInput | string
    isConfirmed?: BoolFieldUpdateOperationsInput | boolean
    callStatus?: StringFieldUpdateOperationsInput | string
    isCancelled?: BoolFieldUpdateOperationsInput | boolean
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    educationId?: NullableIntFieldUpdateOperationsInput | number | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    patientType?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: UnitUpdateOneRequiredWithoutReservationsNestedInput
    paymentMethod?: PaymentMethodUpdateOneRequiredWithoutReservationsNestedInput
    doctor?: EmployeeUpdateOneWithoutReservationsNestedInput
    referralSource?: ReferralSourceUpdateOneWithoutReservationsNestedInput
  }

  export type ReservationUncheckedUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    unitId?: IntFieldUpdateOperationsInput | number
    queueNumber?: IntFieldUpdateOperationsInput | number
    reservationNumber?: StringFieldUpdateOperationsInput | string
    reservationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMethodId?: IntFieldUpdateOperationsInput | number
    bpjsNumber?: NullableStringFieldUpdateOperationsInput | string | null
    otherInsuranceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referralNumber?: NullableStringFieldUpdateOperationsInput | string | null
    doctorId?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    queueType?: StringFieldUpdateOperationsInput | string
    referralSourceId?: NullableIntFieldUpdateOperationsInput | number | null
    isConfirmed?: BoolFieldUpdateOperationsInput | boolean
    callStatus?: StringFieldUpdateOperationsInput | string
    isCancelled?: BoolFieldUpdateOperationsInput | boolean
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    educationId?: NullableIntFieldUpdateOperationsInput | number | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    patientType?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ReservationUncheckedUpdateManyWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    unitId?: IntFieldUpdateOperationsInput | number
    queueNumber?: IntFieldUpdateOperationsInput | number
    reservationNumber?: StringFieldUpdateOperationsInput | string
    reservationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMethodId?: IntFieldUpdateOperationsInput | number
    bpjsNumber?: NullableStringFieldUpdateOperationsInput | string | null
    otherInsuranceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referralNumber?: NullableStringFieldUpdateOperationsInput | string | null
    doctorId?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    queueType?: StringFieldUpdateOperationsInput | string
    referralSourceId?: NullableIntFieldUpdateOperationsInput | number | null
    isConfirmed?: BoolFieldUpdateOperationsInput | boolean
    callStatus?: StringFieldUpdateOperationsInput | string
    isCancelled?: BoolFieldUpdateOperationsInput | boolean
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    educationId?: NullableIntFieldUpdateOperationsInput | number | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    patientType?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PatientCreateManyGenderInput = {
    id: number
    isEnabled?: boolean
    name?: string | null
    identity: string
    birthPlace?: string | null
    birthDate?: Date | string | null
    motherName?: string | null
    fatherName?: string | null
    spouseName?: string | null
    bpjsNumber?: string | null
    otherInsuranceNumber?: string | null
    phoneNumber?: string | null
    registeredAt?: Date | string | null
    homeAddress?: string | null
  }

  export type PatientUpdateWithoutGenderInput = {
    id?: IntFieldUpdateOperationsInput | number
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    name?: NullableStringFieldUpdateOperationsInput | string | null
    identity?: StringFieldUpdateOperationsInput | string
    birthPlace?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    motherName?: NullableStringFieldUpdateOperationsInput | string | null
    fatherName?: NullableStringFieldUpdateOperationsInput | string | null
    spouseName?: NullableStringFieldUpdateOperationsInput | string | null
    bpjsNumber?: NullableStringFieldUpdateOperationsInput | string | null
    otherInsuranceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    registeredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    homeAddress?: NullableStringFieldUpdateOperationsInput | string | null
    reservations?: ReservationUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateWithoutGenderInput = {
    id?: IntFieldUpdateOperationsInput | number
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    name?: NullableStringFieldUpdateOperationsInput | string | null
    identity?: StringFieldUpdateOperationsInput | string
    birthPlace?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    motherName?: NullableStringFieldUpdateOperationsInput | string | null
    fatherName?: NullableStringFieldUpdateOperationsInput | string | null
    spouseName?: NullableStringFieldUpdateOperationsInput | string | null
    bpjsNumber?: NullableStringFieldUpdateOperationsInput | string | null
    otherInsuranceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    registeredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    homeAddress?: NullableStringFieldUpdateOperationsInput | string | null
    reservations?: ReservationUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateManyWithoutGenderInput = {
    id?: IntFieldUpdateOperationsInput | number
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    name?: NullableStringFieldUpdateOperationsInput | string | null
    identity?: StringFieldUpdateOperationsInput | string
    birthPlace?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    motherName?: NullableStringFieldUpdateOperationsInput | string | null
    fatherName?: NullableStringFieldUpdateOperationsInput | string | null
    spouseName?: NullableStringFieldUpdateOperationsInput | string | null
    bpjsNumber?: NullableStringFieldUpdateOperationsInput | string | null
    otherInsuranceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    registeredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    homeAddress?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ReservationCreateManyReferralSourceInput = {
    id: string
    isEnabled?: boolean
    unitId: number
    identity: string
    queueNumber: number
    reservationNumber: string
    reservationDate: Date | string
    paymentMethodId: number
    bpjsNumber?: string | null
    otherInsuranceNumber?: string | null
    createdAt?: Date | string
    referralNumber?: string | null
    doctorId?: number | null
    notes?: string | null
    queueType: string
    isConfirmed?: boolean
    callStatus?: string
    isCancelled?: boolean
    cancelReason?: string | null
    educationId?: number | null
    type?: string | null
    patientType?: string | null
  }

  export type ReservationUpdateWithoutReferralSourceInput = {
    id?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    queueNumber?: IntFieldUpdateOperationsInput | number
    reservationNumber?: StringFieldUpdateOperationsInput | string
    reservationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    bpjsNumber?: NullableStringFieldUpdateOperationsInput | string | null
    otherInsuranceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referralNumber?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    queueType?: StringFieldUpdateOperationsInput | string
    isConfirmed?: BoolFieldUpdateOperationsInput | boolean
    callStatus?: StringFieldUpdateOperationsInput | string
    isCancelled?: BoolFieldUpdateOperationsInput | boolean
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    educationId?: NullableIntFieldUpdateOperationsInput | number | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    patientType?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: UnitUpdateOneRequiredWithoutReservationsNestedInput
    patient?: PatientUpdateOneWithoutReservationsNestedInput
    paymentMethod?: PaymentMethodUpdateOneRequiredWithoutReservationsNestedInput
    doctor?: EmployeeUpdateOneWithoutReservationsNestedInput
  }

  export type ReservationUncheckedUpdateWithoutReferralSourceInput = {
    id?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    unitId?: IntFieldUpdateOperationsInput | number
    identity?: StringFieldUpdateOperationsInput | string
    queueNumber?: IntFieldUpdateOperationsInput | number
    reservationNumber?: StringFieldUpdateOperationsInput | string
    reservationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMethodId?: IntFieldUpdateOperationsInput | number
    bpjsNumber?: NullableStringFieldUpdateOperationsInput | string | null
    otherInsuranceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referralNumber?: NullableStringFieldUpdateOperationsInput | string | null
    doctorId?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    queueType?: StringFieldUpdateOperationsInput | string
    isConfirmed?: BoolFieldUpdateOperationsInput | boolean
    callStatus?: StringFieldUpdateOperationsInput | string
    isCancelled?: BoolFieldUpdateOperationsInput | boolean
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    educationId?: NullableIntFieldUpdateOperationsInput | number | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    patientType?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ReservationUncheckedUpdateManyWithoutReferralSourceInput = {
    id?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    unitId?: IntFieldUpdateOperationsInput | number
    identity?: StringFieldUpdateOperationsInput | string
    queueNumber?: IntFieldUpdateOperationsInput | number
    reservationNumber?: StringFieldUpdateOperationsInput | string
    reservationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMethodId?: IntFieldUpdateOperationsInput | number
    bpjsNumber?: NullableStringFieldUpdateOperationsInput | string | null
    otherInsuranceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referralNumber?: NullableStringFieldUpdateOperationsInput | string | null
    doctorId?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    queueType?: StringFieldUpdateOperationsInput | string
    isConfirmed?: BoolFieldUpdateOperationsInput | boolean
    callStatus?: StringFieldUpdateOperationsInput | string
    isCancelled?: BoolFieldUpdateOperationsInput | boolean
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    educationId?: NullableIntFieldUpdateOperationsInput | number | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    patientType?: NullableStringFieldUpdateOperationsInput | string | null
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}